///////////////// INTERFACE.H
#pragma once

#include "stdafx.h"
#include "Import.h"
#include <functional>
#include "CustomJewelBank.h"

#define MAX_OBJECT			500
#define MAX_WIN_WIDTH		640
#define MAX_WIN_HEIGHT		480

enum ObjWindowsEx
{
	exWinNews			= 1,
	exWinReset			= 2,
	exWinGrandReset		= 3,
	exWinRanking		= 4,
	exWinDonate			= 5,
	exWinPremium		= 6,
	exWinMiniMenu		= 7,
	exWinSettings		= 8,
	exWinPTSearchMaster	= 9,
	exWinPTSearchUser	= 10,
	exWinPersonalSearch	= 12,
	exWinPersonalPrice	= 13,
	exWinNPCBuffer,
	exWinSmithy,
	exWinSmithyCheck,
	exWinCheckOffAfk,
	exWinMarriage,
	exWinAddPoints,
	exWinAddResetPoint,
	exWinCustomMenu,
	exWinCustomMenuChangeClass,
	exWinDungeonSiege,
	exWinTeamVsTeam,
	exWinTeamVsTeamStatistic,
	exWinAchievements,
	exWinAchievementsPower,
	exWinTeleport,
	exWinTeleportEvo,
	exWinResetRage,
	exWinDonateCheck,
	exWinPKClear,
	exWinAccWarning,
	exWinAccMenu,
	exWinAccOption,
	exWinAccPC,
	exWinAccMessage,
	exWinAccNumber,
	exWinReferralMenu,
	exWinReferralSystem,
	exWinReferralSystem2,
	exWinQuest,
	exWinLottery,
	exWinItemMarket,
	exWinItemMarket2,
	exWinMenuV3,
	exWinStatsAdvance,
};


enum ObjectID
{
		eFlag01=1,
		eFlag02,
		eFlag03,
		eFlag04,
		eFlag05,
		eFlag06,
		eFlag07,
		eFlag08,
		eFlag09,
		eFlag10,
		eFlag11,
		eFlag12,
		eFlag13,
		eFlag14,
		eFlag15,
		eFlag16,
		eFlag17,
		eFlag18,
		eFlag19,
		eFlag20,
		eFlag21,
		eFlag22,
		eTIME,
		eRankPANEL_MAIN,
		eRanking,
		eSAMPLEBUTTON,
		eSAMPLEBUTTON2,
		eVip_MAIN,
		eVip_TITLE,
		eVip_FRAME,
		eVip_FOOTER,
		eVip_DIV,
		eVip_CLOSE,
		eVip_BRONZE,
		eVip_SILVER,
		eVip_GOLD,
		eVip_PLATINUM,
		eVip_STATUS,
		eRanking_MAIN,
		eRanking_CLOSE,
		eLogo,
		eEventTimePANEL_MAIN,
		eEventTime_MAIN,
		eEventTime_CLOSE,
		eMenu,
		eMenuBG,
		eMenu_MAIN,
		eMenu_TITLE,
		eMenu_FRAME,
		eMenu_FOOTER,
		eMenu_DIV,
		eMenu_CLOSE,
		eMenu_OPT1,
		eMenu_OPT2,
		eMenu_OPT3,
		eMenu_OPT4,
		eMenu_OPT20,
		eMenu_OPT21,
		eMenu_OPT22,
		eLuckymenu,
		eLuckySpin,
		eLuckySpinRoll,
		eLuckySpinClose,
		eLuckyWheelPanel,
		eBXH,
		eQuaMocRSMain,
		eQuaMocRSNhan,
		eQuaMocRSPanel,
		eQuaMocRSNhan_CLOSE,
		eICONQUAMOCRS,
		eRock,
		ePaper,
		eScissors,
		eCommand_MAIN,
		eCommand_TITLE,
		eCommand_FRAME,
		eCommand_FOOTER,
		eCommand_DIV,
		eCommand_CLOSE,

		eCONFIRM_MAIN,
		eCONFIRM_BTN_OK,
		eCONFIRM_BTN_CANCEL,
		eCONFIRM_TITLE,
		eCONFIRM_FRAME,
		eCONFIRM_FOOTER,
		eCONFIRM_DIV,

		eNextCommand,
		ePrevCommand,

		eNextEvent,
		ePrevEvent,
			eSMITHY_MAIN,
	eSMITHY_MAIN1,
	eSMITHY_TITLE,
	eSMITHY_FRAME,
	eSMITHY_FOOTER,
	eSMITHY_DIV,
	eSMITHY_DIV2,
	eSMITHY_INFOBG,
	eSMITHY_CLOSE, 
	eSMITHY_BACK,
	eSMITHY_TEXT,
	eSMITHY_TEXT2, 
	eSMITHY_TEXT3, 
	eSMITHY_TEXT4, 
	eSMITHY_TEXT5, 
	eSMITHY_TEXT6, 
	eSMITHY_TEXT7, 
	eSMITHY_TEXT8, 
	eSMITHY_TEXT9, 
	eSMITHY_TEXT10,
	eSMITHY_L,
	eSMITHY_R,
	eSMITHY_INFOBG2,
	eSMITHY_INFOBG3,
	eSMITHY_LINE,
	eSMITHY_POINT, 
	eSMITHY_CHECK0,
	eSMITHY_CHECK1,
	eSMITHY_CHECK2,
	eSMITHY_CHECK3,
	eSMITHY_CHECK4,
	eSMITHY_CHECK5,
	eSMITHY_CHECK6,
	eSMITHY_CHECK7,
	eSMITHY_PAGEUP,
	eSMITHY_PAGEDN,
	eSMITHY_BT1,
	eSMITHY_BT2,
	eSMITHY_PAGEUP2,
	eSMITHY_PAGEDN2,
	eSMITHY_PAGEUP3,
	eSMITHY_PAGEDN3,
	eSMITHY_PAGEUP4,
	eSMITHY_PAGEDN4,
	eSMITHY_CHECKWIN_MAIN,
	eSMITHY_CHECKWIN_TITLE, 
	eSMITHY_CHECKWIN_FRAME, 
	eSMITHY_CHECKWIN_FOOTER,
	eSMITHY_CHECKWIN_DIV,
	eSMITHY_CHECKWIN_OK,
	eSMITHY_CHECKWIN_CLOSE, 

	eCHANGINGCLASS_MAIN,
	eCHANGINGCLASS_TITLE,
	eCHANGINGCLASS_FRAME,
	eCHANGINGCLASS_FOOTER,
	eCHANGINGCLASS_DIV,
	eCHANGINGCLASS_INFOBG,
	eCHANGINGCLASS_MONEYBG,
	eCHANGINGCLASS_CLOSE,
	eCHANGINGCLASS_DW,
	eCHANGINGCLASS_DK,
	eCHANGINGCLASS_ELF,
	eCHANGINGCLASS_MG,
	eCHANGINGCLASS_DL,
	eCHANGINGCLASS_SUM,
	eCHANGINGCLASS_RF,
	eUSERSPANEL_CHANGINGCLASS,

	eMenu1,

	eImgID_ACHIEVEMENTS_MAIN,
	eImgID_ACHIEVEMENTS_PROGRESS_LINE,
	eACHIEVEMENTS_PROGRESS_BG,
	eImgID_ACHIEVEMENTS_MISSION_1,
	eImgID_ACHIEVEMENTS_MISSION_2,
	eImgID_ACHIEVEMENTS_MISSION_3,
	eImgID_ACHIEVEMENTS_MISSION_4,
	eImgID_ACHIEVEMENTS_MISSION_5,
	eImgID_ACHIEVEMENTS_MISSION_6,
	eImgID_ACHIEVEMENTS_MISSION_7,
	eImgID_ACHIEVEMENTS_MISSION_8,
	eImgID_ACHIEVEMENTS_MISSION_9,
	eImgID_ACHIEVEMENTS_MISSION_10,
	eImgID_ACHIEVEMENTS_MISSION_11,
	eImgID_ACHIEVEMENTS_MISSION_12,
	eImgID_ACHIEVEMENTS_MISSION_13,
	eImgID_ACHIEVEMENTS_MISSION_14,
	eImgID_ACHIEVEMENTS_MISSION_15,
	eImgID_ACHIEVEMENTS_MISSION_16,
	eImgID_ACHIEVEMENTS_MISSION_17,
	eImgID_ACHIEVEMENTS_MISSION_18,
	eImgID_ACHIEVEMENTS_MISSION_19,
	eImgID_ACHIEVEMENTS_MISSION_20,
	eImgID_ACHIEVEMENTS_MISSION_21,
	eImgID_ACHIEVEMENTS_MISSION_22,
	eImgID_ACHIEVEMENTS_MISSION_23,
	eImgID_ACHIEVEMENTS_MISSION_24,
	eImgID_ACHIEVEMENTS_MISSION_25,
	eImgID_ACHIEVEMENTS_MISSION_26,
	eImgID_ACHIEVEMENTS_MISSION_27,
	eImgID_ACHIEVEMENTS_MISSION_28,
	eImgID_ACHIEVEMENTS_MISSION_29,
	eImgID_ACHIEVEMENTS_MISSION_30,
	eImgID_ACHIEVEMENTS_MISSION_31,
	eImgID_ACHIEVEMENTS_MISSION_32,
	eImgID_ACHIEVEMENTS_MISSION_33,
	eImgID_ACHIEVEMENTS_MISSION_34,
	eImgID_ACHIEVEMENTS_MISSION_35,
	eImgID_ACHIEVEMENTS_MISSION_36,
	eImgID_ACHIEVEMENTS_MISSION_37,
	eImgID_ACHIEVEMENTS_MISSION_38,
	eImgID_ACHIEVEMENTS_MISSION_39,
	eImgID_ACHIEVEMENTS_MISSION_40,
	eImgID_ACHIEVEMENTS_MISSION_41,
	eImgID_ACHIEVEMENTS_MISSION_42,
	eImgID_ACHIEVEMENTS_MISSION_43,
	eImgID_ACHIEVEMENTS_MISSION_44,
	eImgID_ACHIEVEMENTS_MISSION_45,
	eImgID_ACHIEVEMENTS_MISSION_46,
	eImgID_ACHIEVEMENTS_MISSION_47,
	eImgID_ACHIEVEMENTS_MISSION_48,
	eImgID_ACHIEVEMENTS_MISSION_49,
	eImgID_ACHIEVEMENTS_MISSION_50,
	OBJECT_ACHIEVEMENTS_MAIN,
	OBJECT_ACHIEVEMENTS_PROGRESS_BG,
	OBJECT_ACHIEVEMENTS_CLOSE,
	OBJECT_ACHIEVEMENTS_MISSIONS,
	OBJECT_ACHIEVEMENTS_PANEL,
	eACHIEVEMENTS_TITLE,
	eACHIEVEMENTS_FRAME,
	OBJECT_ACHIEVEMENTS_DAMAGE,
	OBJECT_ACHIEVEMENTS_DEFENSE,
	OBJECT_ACHIEVEMENTS_LIFE,
	OBJECT_ACHIEVEMENTS_EXCELLENT,
	OBJECT_ACHIEVEMENTS_CRITICAL,
	eACHIEVEMENTS_FOOTER,
	eACHIEVEMENTS_DIV,
	eACHIEVEMENTS_CLOSE,


		eRageSystem,
		eRageTable,
		eRageClose,
		eRagePointTable,
		eRageIcon1,
		eRageIcon2,
		eRageIcon3,
		eRageIcon4,
		eRageIcon5,
		eRageIcon6,
		eRageIcon7,
		eRageIcon8,
		eRageIcon9,
		eRageIcon10,
		eRageIcon11,
		eRageIcon12,
		eRageIcon13,
		eRageIcon14,
		eRageIcon15,
		eRageIcon16,
		eRageIcon17,
		eRageIcon18,
		eRageIcon19,
		eRageIcon20,
		eRageIcon21,
		eRageIcon22,
		eRageIcon23,
		eRageIcon24,
		eRageIcon25,
		eRageIcon26,
		eRageIcon27,
		eRageIcon28,
		eRageIcon29,
		eRageIcon30,
		eRageIcon31,
		eRageIcon32,
		eRageIcon33,
		eRageIcon34,
		eRageIcon35,
		eRageTeleport,
		eRagePet,
		eRageReset,


		eRAGERESET_MAIN,
		eRAGERESET_TITLE,
		eRAGERESET_FRAME,
		eRAGERESET_FOOTER,
		eRAGERESET_DIV,
		eRAGERESET_INFOBG,
		eRAGERESET_CLOSE,
		eRAGERESET_OK,
		eRAGERESET_POINT1,
		eRAGERESET_CHECK1,
		eRAGERESET_LINE1,
		eRAGERESET_POINT2,
		eRAGERESET_CHECK2,
		eRAGERESET_LINE2,


	eMINIMENU_MAIN,
	eMINIMENU_TITLE,
	eMINIMENU_FRAME,
	eMINIMENU_FOOTER,
	eMINIMENU_LINE,
	eMINIMENU_ARROW_L,
	eMINIMENU_ARROW_R,
	eMINIMENU_BT1,
	eMINIMENU_BT2,
	eMINIMENU_BT3,
	eMINIMENU_BT4,
	eMINIMENU_BT5,
	eMINIMENU_BT6,
	eMINIMENU_BT7,
	eMINIMENU_BT8,
	eMINIMENU_BT9,

	eMINIMENU_BT10,
	eMINIMENU_BT11,
	eMINIMENU_BT12,
	eMINIMENU_BT13,
	eMINIMENU_BT14,
	eMINIMENU_BT15,
	eMINIMENU_BT16,
	eMINIMENU_BT17,
	eMINIMENU_BT18,
	eMINIMENU_BT19,
	eMINIMENU_BT20,
	eMINIMENU_BT21,
	eMINIMENU_BT22,
	eMINIMENU_BT23,

	eCAMERA,
	eCAMERA_RESET,





	eCRAFT_MAIN,

	// -------------
	// ExQuest
	// -------------
	OBJECT_WIN_QUEST_MAIN,
	OBJECT_WIN_QUEST_TITLE,
	OBJECT_WIN_QUEST_FRAME,
	OBJECT_WIN_QUEST_FOOTER,
	OBJECT_WIN_QUEST_DIV,
	OBJECT_WIN_QUEST_CLOSE,
	OBJECT_WIN_QUEST_TAB,
	OBJECT_WIN_QUEST_TAB1,
	OBJECT_WIN_QUEST_TAB2,
	OBJECT_WIN_QUEST_TAB3,
	OBJECT_WIN_QUEST_FINISH,
	OBJECT_WIN_QUEST_COUNT1,
	OBJECT_WIN_QUEST_COUNT2,
	OBJECT_WIN_QUEST_COUNT3,
	OBJECT_WIN_QUEST_INFOBG,
	OBJECT_WIN_QUEST_INFOBG2,
	OBJECT_WIN_QUEST_LINE1,
	OBJECT_WIN_QUEST_POINT1,
	OBJECT_WIN_QUEST_INFO,
	OBJECT_WIN_QUEST_INFOBG3,

		//antilag
	//option new menu
	eOpMenu_MAINKG,
	eOpMenu_TITLEKG,
	eOpMenu_FRAMEKG,
	eOpMenu_FOOTERKG,
	eOpMenu_DIVKG,
	eOpMenu_CLOSEKG,
	eCheck,
	eUnCheck,
	eUSERSPANEL_OPTION,
	eUSERSPANEL_STATICEFFECT,
	eUSERSPANEL_DISABLEOBJECT,
	eUSERSPANEL_DISABLEWINGS,
	eUSERSPANEL_DISABLESKILL,



		eJewelBank_MAIN,
		eJewelBank_TITLE,
		eJewelBank_FRAME,
		eJewelBank_FOOTER,
		eJewelBank_DIV,
		eJewelBank_CLOSE,
		eJewelBank_NEXT,
		eJewelBank_PREV,
		eJewelBank_WITHDRAW,
};





struct InterfaceObject
{
	DWORD	ModelID;
	float	Width;
	float	Height;
	float	X;
	float	Y;
	float	MaxX;
	float	MaxY;
	DWORD	EventTick;
	bool	OnClick;
	bool	OnShow;
	BYTE	Attribute;

		long	OpenedValue;
	BYTE	Speed;
	char	StatValue[20];
	bool	ByClose;
	bool	FirstLoad;
	//int		Type;

	void Open()
	{
		this->OnShow = true; pSetCursorFocus = true;
		this->ByClose = false;
	};

	void Open(int Value, int Speed)
	{
		this->OnShow = true; pSetCursorFocus = true;
		this->OpenedValue = Value;
		this->Speed = Speed;
		this->ByClose = false;
		this->FirstLoad = true;
	};

	void Close()
	{ 
		this->OnShow = false; 
		pSetCursorFocus = false; 
		this->ByClose = false;
	};

	void Close(int Value, int Speed)
	{
		this->OnShow = false; pSetCursorFocus = false; 
		this->OpenedValue = Value;
		this->Speed = Speed;
		this->ByClose = false;
	}

	void CloseAnimated(int Speed)
	{
		pSetCursorFocus = false;
		//this->OpenedValue = Value;
		this->Speed = Speed;
		this->ByClose = true;
	}

	bool Check()
	{
		return this->OnShow;
	}
};


//    Ʈ
struct INTERFACE_OBJECT_INFO
{
	short	ObjectID;
	DWORD	ModelID;
	float	Width;
	float	Height;
	float	X;
	float	Y;
	char	FileName[100];
	DWORD	EventTick;
	bool	OnClick;
	bool	OnShow;
	DWORD	Attribute;
	char	StatValue[20];
	bool	FirstLoad;

	void Open()
	{
		this->OnShow = true;
		this->FirstLoad = true;
	};
};
////

class Interface
{
public:
	//Interface();

	void ImageLoad(char* folder, int code, int arg3, int arg4, int arg5, int arg6);

	void		Load();
	static void	LoadImages();
	static void	Work();
	void Run();
	void		BindObject(short ObjectID, DWORD ModelID, float Width, float Height, float X, float Y);
	void		DrawGUI(short ObjectID, float PosX, float PosY);
	void	    DrawGUI1(short ObjectID);
	void		DrawTimeUI();
	int			DrawFormat(DWORD Color, int PosX, int PosY, int Width, int Align, int Bold, LPCSTR Text, ...);
	void		DrawFormatEx(DWORD Color, int PosX, int PosY, int Width, int Align, LPCSTR Text, ...); //    Ʈ
	void		DrawIMG(short ObjectID, float PosX, float PosY, float ScaleX, float ScaleY);

	bool		WindowEx[100];
	bool		IsWorkZone(float X, float Y, float MaxX, float MaxY);
	bool		IsWorkZone(short ObjectID);
	void		ResetDrawIMG(short ObjectID);
	int			DrawMessage(int Mode, LPCSTR Text, ...);

	void		DrawColorGUI(int MainID, int X, int Y, int Width, int Height, DWORD Color);

	static bool	AllowGUI();

	void		OpenWindowEx(int WindowID);
	void		CloseWindowEx(int WindowID);
	bool		CheckWindowEx(int WindowID);

	bool		CheckWindow(int WindowID);
	int			CloseWindow(int WindowID);
	int			OpenWindow(int WindowID);

	float		GetResizeX(short ObjectID);
	int			DrawToolTip(int X, int Y, LPCSTR Text, ...);
	float		DrawRepeatGUI(short MonsterID, float X, float Y, int Count);
	void		DrawColoredGUI(short ObjectID, float X, float Y, DWORD Color);
	void		DrawColoredGUI22(short ObjectID, DWORD Color);
	void		DrawButton(short ObjectID, float PosX, float PosY, float ScaleX, float ScaleY);
	void		PartUPandDNEx(int PointID, int UpID, int DownID, int LineID, float X, float Y, DWORD Color, int Value, char* Text);
	void		DrawAnimatedButton(short ObjectID, float PosX, float PosY, float ScaleX, float ScaleY);
	void		DrawAnimatedGUI(short ObjectID, float X, float Y);
	void		DrawBarForm(float PosX,float PosY,float Width,float Height,GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
	void		DrawCheckLineEx(bool isChecked, int PointID, int CheckID, int LineID, float X, float Y, DWORD Color, char* Text);
	void		TextDraw(int PosX, int PosY, int Width, int Arg5, int Color, int Arg7, int Align, HGDIOBJ Font, LPCTSTR Format, ...);
	void		MiniButtonDraw(int BtnID, float X, float Y, bool isHover, char* Text);
	bool		ButtonEx(DWORD Event, int ButtonID, bool Type);
	void		DrawButtonGUI(short ObjectID, float PosX, float PosY, float Width, float Height, float ScaleX, float ScaleY,bool ScaleSize, bool ScalePosition, bool ScaleAlpha);
	void		DrawItem(float PosX, float PosY, float Width, float Height, int ItemID, int Level, int Excl, int Anc, bool OnMouse);


	//Vip Window
	void		OpenVipWindow() { this->Data[eVip_MAIN].OnShow = true; pSetCursorFocus = true; };
	void		CloseVipWindow() { this->Data[eVip_MAIN].OnShow = false; pSetCursorFocus = false; };
	bool		CheckVipWindow() { return this->Data[eVip_MAIN].OnShow; };
	void		DrawVipWindow();
	bool		EventVipWindow_Main(DWORD Event);
	bool		EventVipWindow_Close(DWORD Event);
	bool		EventVipWindow_Bronze(DWORD Event);
	bool		EventVipWindow_Silver(DWORD Event);
	bool		EventVipWindow_Gold(DWORD Event);
	bool		EventVipWindow_Platinum(DWORD Event);
	bool		EventVipWindow_StatusVip(DWORD Event);

	static void		DisableName();

	//Menu
	void		DrawMenu();
	bool		EventDrawMenu_Open(DWORD Event);
	void		OpenMenuWindow() { this->Data[eMenu_MAIN].OnShow = true; pSetCursorFocus = true; };
	void		CloseMenuWindow() { this->Data[eMenu_MAIN].OnShow = false; pSetCursorFocus = false; };
	bool		CheckMenuWindow() { return this->Data[eMenu_MAIN].OnShow; };
	void		DrawMenuOpen();
	bool		EventDrawMenu_Close(DWORD Event);
	bool		EventDrawMenu_Op0(DWORD Event);
	bool		EventDrawMenu_Op1(DWORD Event);
	bool		EventDrawMenu_Op2(DWORD Event);
	bool		EventDrawMenu_Op3(DWORD Event);
	bool		EventDrawMenu_Op4(DWORD Event);
	bool		EventDrawMenu_Op20(DWORD Event);
	bool		EventDrawMenu_Op21(DWORD Event);
	bool		EventDrawMenu_Op22(DWORD Event);
	bool		EventDrawMenu_Op23(DWORD Event);
	bool		EventRagesystems(DWORD Event);

	void		DrawQuaMocRS();
	void		EventQuaMocRS_Main(DWORD Event);
	void		QuaMocRSState(){(Data[eQuaMocRSMain].OnShow == true)? Data[eQuaMocRSMain].Close():Data[eQuaMocRSMain].Open();};
	void		QuaMocRSStateclose() { Data[eQuaMocRSMain].OnShow = false; pSetCursorFocus = false; };

	void		DrawCameraButton();
	bool		EventDrawCamera(DWORD Event);
	void		DrawCameraResetButton();
	bool		EventDrawCameraReset(DWORD Event);

	void		DrawRPS();
	void		EventRPS_Main(DWORD Event);


	void		OpenChangingClassWindow() { this->Data[eCHANGINGCLASS_MAIN].OnShow = true; pSetCursorFocus = true; };
	void		CloseChangingClassWindow() { this->Data[eCHANGINGCLASS_MAIN].OnShow = false; pSetCursorFocus = false; };
	bool		CheckChangingClassWindow() { return this->Data[eCHANGINGCLASS_MAIN].OnShow; };

	//void SwitchJewelBank(){ (this->Data[eJEWELBANK_MAIN].OnShow == true) ? this->Data[eJEWELBANK_MAIN].Close() : this->Data[eJEWELBANK_MAIN].Open(); };

	static void DrawItem2(float PosX, float PosY, float Width, float Height, int ItemID, int Level, int Excl, int Anc, bool OnMouse);
	void DrawWindow(int ObjMain, int ObjTitle, int ObjFrame, int ObjFooter, int Repeat, float X, float Y, char* Text);

	void		CloseAllCustomWindow();
	void		DrawChangingClassWindow();
	bool		EventChangingClassWindow_Main(DWORD Event);
	bool		EventChangingClassWindow_Close(DWORD Event);	
	bool		EventChangingClassWindow_DW(DWORD Event);
	bool		EventChangingClassWindow_DK(DWORD Event);
	bool		EventChangingClassWindow_ELF(DWORD Event);
	bool		EventChangingClassWindow_MG(DWORD Event);
	bool		EventChangingClassWindow_DL(DWORD Event);
	bool		EventChangingClassWindow_SUM(DWORD Event);
	bool		EventChangingClassWindow_RF(DWORD Event);

	//AntilagSystem
	bool Antilagclose(DWORD Event);
	void DrawOpAntiLag();
	bool EventUsersPanelAntiLag_EFFECTSTATIC(DWORD Event);
	bool EventUsersPanelAntiLag_OBJECT(DWORD Event);
	bool EventUsersPanelAntiLag_WINGS(DWORD Event);
	bool EventUsersPanelAntiLag_SKILL(DWORD Event);
	int DisableEffectStatic; //effectstatic
	int DisableObject; //object
	int Disablewings; //wings
	int Disableskill;//skill
	DWORD       MenuAntlagDelayClick;	
	void		OpenOpMenuAntiLag() { this->Data[eOpMenu_MAINKG].OnShow = true; pSetCursorFocus = true; };
	void		CloseOpMenuAntiLag() { this->Data[eOpMenu_MAINKG].OnShow = false; pSetCursorFocus = false; };
	bool		CheckOpMenuAntiLag() { return this->Data[eOpMenu_MAINKG].OnShow; };
	//Draw Confirm window
	void		DrawConfirmOpen();
	bool		EventConfirm_OK(DWORD Event);
	bool		EventConfirm_CANCEL(DWORD Event);

			//----- FPS
	int			lastReport;
	int			frameCount;
	int			frameRate;
	char		FPS_REAL[30];
	void		UPDATE_FPS();
	void		guiMonitore();
//------------------------ ping RTT:
	int			iniciador;
	int			msPing;
	int			lastSend;
	int			validar;
	char		ServerPing[50];
	char		ultimoPing[50];
	int			ultimo_Ping;
	char		ServerRTT[50];
	char		ultimoRTT[50];
	int			ultimo_RTT;
	void		DrawPing();
	void		SendPingRecv();

	void		DrawAutoCtrl();
	void		DrawAutoCtrl1();
	void		DrawAutoCtrl2();
	void		DrawAutoCtrl3();
	void        DrawM();
	void		DrawAutoChange();
	void		DrawOffExp();
	void		DrawGuildAttack();
	void		DrawLogo(bool active);
	void		CloseCustomWindow();

	int timehpbar;
	int hpbarresult;

	int			ConfirmSlot;
	InterfaceObject Data[MAX_OBJECT];

	bool CheckInQueue(std::string name); //    Ʈ
	void AddToQueue(std::string name, void(Interface::* func)());
	void DelFromQueue(std::string name);
	//bool ButtonEx(DWORD Event, int ButtonID, bool Type);
	void DrawQuestSystemWindow(); //ExQuest
	
	bool ShowInfoUser;
	bool ShowEffects;
	void SwitchShowInfoUser();
	void SwitchShowEffects();
	DWORD AutoControlDelay;
	int varTestCntrl;
	void AutoPVP();
	void DrawText(DWORD Color, int PosX, int PosY, int Width, int Align, LPCSTR Text, ...);
	bool IsWorkZone2(float X, float Y, float MaxX, float MaxY);

	std::map<std::string, std::function<void()>> m_InterfaceQueue; //    Ʈ
private:
	std::map<int, struct INTERFACE_OBJECT_INFO> m_InterfaceInfo; //    Ʈ
	
};
extern Interface gInterface;

/////////////////////////////////////////////////////////////////////


///////////////////////// INTERFACE.CPP

#include "stdafx.h"
#include "CustomBuyVip.h"
#include "CustomCommandInfo.h"
#include "CustomEventTime.h"
#include "CustomMessage.h"
#include "CustomRanking.h"
#include "Defines.h"
#include "Interface.h"
#include "Import.h"
#include "Offset.h"
#include "PrintPlayer.h"
#include "Protect.h"
#include "Util.h"
#include "User.h"
#include "Reconnect.h"
#include "Smithy.h"
#include "ChangeClass.h"
#include "Common.h"
#include "Achievements.h"
#include "ServerInfo.h"
#include "LuckyWheel.h"
#include "Camera.h"
#include "Protocol.h"
#include "CustomJewelBank.h"
#include "RageSystem.h"
#include "CustomComboEffect.h"
#include "EmojiSystem.h"

Interface	gInterface;


void Interface::Load()
{
    // 초기화 플래그 설정
    this->ShowInfoUser = true;

    // BindObject 호출을 배열과 루프로 최적화
    struct FlagData {
        short id;
        DWORD model;
    };
    const FlagData flags[] = {
        {eFlag01, 0x17880}, {eFlag02, 0x17881}, {eFlag03, 0x17882},
        {eFlag04, 0x17883}, {eFlag05, 0x17884}, {eFlag06, 0x17885},
        {eFlag07, 0x17886}, {eFlag08, 0x17887}, {eFlag09, 0x17888},
        {eFlag10, 0x17889}
    };
    for (int i = 0; i < sizeof(flags) / sizeof(flags[0]); i++) {
        this->BindObject(flags[i].id, flags[i].model, 78, 78, -1, -1);
    }

    // 개별 UI 요소 바인딩
    this->BindObject(eCAMERA, 0x10036, 15, 15, -1, -1);
    this->BindObject(eCAMERA_RESET, 0x10037, 15, 15, -1, -1);
    this->BindObject(eRanking, 0x8322, 179, 27, -1, -1);
    this->BindObject(eSAMPLEBUTTON, 0x8323, 25, 40, -1, -1);
    this->BindObject(eSAMPLEBUTTON2, 0x8324, 25, 40, -1, -1);
    this->BindObject(eLogo, 0x8325, 150, 114, -1, -1);

    // VIP 시스템 UI 바인딩
    this->BindObject(eVip_MAIN, 0x7A5A, 222, 250, -1, -1);
    this->BindObject(eVip_TITLE, 0x7A63, 230, 67, -1, -1);
    this->BindObject(eVip_FRAME, 0x7A58, 230, 15, -1, -1);
    this->BindObject(eVip_FOOTER, 0x7A59, 230, 50, -1, -1);
    this->BindObject(eVip_DIV, 0x7A62, 223, 21, -1, -1);
    this->BindObject(eVip_CLOSE, 0x7FD2, 36, 29, -1, -1);
    this->BindObject(eVip_BRONZE, 0x7A5E, 108, 29, -1, -1);
    this->BindObject(eVip_SILVER, 0x7A5E, 108, 29, -1, -1);
    this->BindObject(eVip_GOLD, 0x7A5E, 108, 29, -1, -1);
    this->BindObject(eVip_PLATINUM, 0x7A5E, 108, 29, -1, -1);
    this->BindObject(eVip_STATUS, 0x7A5E, 108, 29, -1, -1);

    // JewelBank UI 바인딩
    this->BindObject(eJewelBank_MAIN, 0x7A5A, 222, 240, -1, -1);
    this->BindObject(eJewelBank_TITLE, 0x7A63, 230, 67, -1, -1);
    this->BindObject(eJewelBank_FRAME, 0x7A58, 230, 15, -1, -1);
    this->BindObject(eJewelBank_FOOTER, 0x7A59, 230, 50, -1, -1);
    this->BindObject(eJewelBank_DIV, 0x7A62, 223, 21, -1, -1);
    this->BindObject(eJewelBank_CLOSE, 0x7FD2, 36, 29, -1, -1);
    this->BindObject(eJewelBank_NEXT, 0x50002, 25, 40, -1, -1);
    this->BindObject(eJewelBank_PREV, 0x50003, 25, 40, -1, -1);
    for (int i = 0; i < 50; i++) {
        this->BindObject(eJewelBank_WITHDRAW + i, 0x7BFE, 16, 32, -1, -1);
    }

    // 메뉴 UI 바인딩
    this->BindObject(eMenu1, 60000, 118, 54, -1, -1);
    this->BindObject(eMenu_MAIN, 0x7A5A, 222, 300, -1, -1);
    this->BindObject(eMenu_TITLE, 0x7A63, 230, 67, -1, -1);
    this->BindObject(eMenu_FRAME, 0x7A58, 230, 15, -1, -1);
    this->BindObject(eMenu_FOOTER, 0x7A59, 230, 50, -1, -1);
    this->BindObject(eMenu_DIV, 0x7A62, 223, 21, -1, -1);
    this->BindObject(eMenu_CLOSE, 0x7FD2, 36, 29, -1, -1);
    this->BindObject(eMenu_OPT1, 0x7A5E, 106, 29, -1, -1);
    this->BindObject(eMenu_OPT2, 0x7A5E, 106, 29, -1, -1);
    this->BindObject(eMenu_OPT3, 0x7A5E, 106, 29, -1, -1);
    this->BindObject(eMenu_OPT4, 0x7A5E, 106, 29, -1, -1);
    this->BindObject(eMenu_OPT20, 0x7A5E, 106, 29, -1, -1);
    this->BindObject(eMenu_OPT21, 0x7A5E, 106, 29, -1, -1);
    this->BindObject(eMenu_OPT22, 0x7A5E, 106, 29, -1, -1);

    // 기타 UI 바인딩
    this->BindObject(eCHANGINGCLASS_MAIN, 0x7A5A, 222, 300, -1, -1);
    this->BindObject(eCHANGINGCLASS_TITLE, 0x7A63, 230, 67, -1, -1);
    this->BindObject(eCHANGINGCLASS_FRAME, 0x7A58, 230, 15, -1, -1);
    this->BindObject(eCHANGINGCLASS_FOOTER, 0x7A59, 230, 50, -1, -1);
    this->BindObject(eCHANGINGCLASS_DIV, 0x7A62, 223, 21, -1, -1);
    this->BindObject(eCHANGINGCLASS_CLOSE, 0x7FD2, 36, 29, -1, -1);
    this->BindObject(eCHANGINGCLASS_INFOBG, 0x7AA3, 170, 21, -1, -1);
    this->BindObject(eCHANGINGCLASS_MONEYBG, 0x7A89, 170, 26, -1, -1);
    const short classButtons[] = {
        eCHANGINGCLASS_DW, eCHANGINGCLASS_DK, eCHANGINGCLASS_ELF,
        eCHANGINGCLASS_MG, eCHANGINGCLASS_DL, eCHANGINGCLASS_SUM,
        eCHANGINGCLASS_RF, eUSERSPANEL_CHANGINGCLASS
    };
    for (int i = 0; i < sizeof(classButtons) / sizeof(classButtons[0]); i++) {
        this->BindObject(classButtons[i], 0x7A5E, 106, 29, -1, -1);
    }

    // 커맨드 및 기타 UI 바인딩
    this->BindObject(eCommand_MAIN, 0x7A5A, 222, 300, -1, -1);
    this->BindObject(eCommand_TITLE, 0x7A63, 230, 67, -1, -1);
    this->BindObject(eCommand_FRAME, 0x7A58, 230, 15, -1, -1);
    this->BindObject(eCommand_FOOTER, 0x7A59, 230, 50, -1, -1);
    this->BindObject(eCommand_DIV, 0x7A62, 223, 21, -1, -1);
    this->BindObject(eCommand_CLOSE, 0x7FD2, 36, 29, -1, -1);

    this->BindObject(eRanking_MAIN, 0x7A5A, 222, 300, -1, -1);
    this->BindObject(eRanking_CLOSE, 0x7FD2, 36, 29, -1, -1);

    this->BindObject(eEventTime_MAIN, 0x7A5A, 222, 225, -1, -1);
    this->BindObject(eEventTime_CLOSE, 0x7FD2, 36, 29, -1, -1);

    // 확인 창 UI 바인딩
    this->BindObject(eCONFIRM_MAIN, 0x7A5A, 222, 120, -1, -1);
    this->BindObject(eCONFIRM_TITLE, 0x7A63, 230, 67, -1, -1);
    this->BindObject(eCONFIRM_FRAME, 0x7A58, 230, 15, -1, -1);
    this->BindObject(eCONFIRM_FOOTER, 0x7A59, 230, 50, -1, -1);
    this->BindObject(eCONFIRM_DIV, 0x7A62, 223, 21, -1, -1);
    this->BindObject(eCONFIRM_BTN_OK, 0x7A5B, 54, 30, -1, -1);
    this->BindObject(eCONFIRM_BTN_CANCEL, 0x7A5C, 54, 30, -1, -1);

    this->BindObject(eNextCommand, 0x8323, 25, 40, -1, -1);
    this->BindObject(ePrevCommand, 0x8324, 25, 40, -1, -1);
    this->BindObject(eNextEvent, 0x8323, 25, 40, -1, -1);
    this->BindObject(ePrevEvent, 0x8324, 25, 40, -1, -1);

    // 추가 UI 요소
    this->BindObject(eMenu, 80000, 13, 15, -1, -1);
    this->BindObject(eLuckymenu, 0x7A5E, 106, 29, -1, -1);
    this->BindObject(eLuckySpinRoll, 0x50000, 108, 30, -1, -1);
    this->BindObject(eLuckySpinClose, 0x7FD2, 36, 29, -1, -1);
    this->BindObject(eQuaMocRSNhan, 0x50001, 108, 30, -1, -1);
    this->BindObject(eQuaMocRSMain, 0x9331, 222, 300, -1, -1);
    this->BindObject(eQuaMocRSPanel, 0x9332, 100, 100, -1, -1);
    this->BindObject(eQuaMocRSNhan_CLOSE, 0x7FD2, 36, 29, -1, -1);
    this->BindObject(eRock, 0x9323, 36, 28, -1, -1);
    this->BindObject(ePaper, 0x9324, 36, 28, -1, -1);
    this->BindObject(eScissors, 0x9325, 36, 28, -1, -1);

    // 옵션 메뉴 UI 바인딩
    this->BindObject(eOpMenu_MAINKG, 0x7A5A, 222, 333, -1, -1);
    this->BindObject(eOpMenu_TITLEKG, 0x7A63, 230, 67, -1, -1);
    this->BindObject(eOpMenu_CLOSEKG, 0x7EC5, 36, 29, -1, -1);
    this->BindObject(eOpMenu_FRAMEKG, 0x7A58, 230, 15, -1, -1);
    this->BindObject(eOpMenu_FOOTERKG, 0x7A59, 230, 50, -1, -1);
    this->BindObject(eOpMenu_DIVKG, 0x7A62, 223, 21, -1, -1);
    this->BindObject(eUSERSPANEL_OPTION, 0x7B68, 10, 10, -1, -1);
    this->BindObject(eCheck, 0x9991, 15, 15, -1, -1);
    this->BindObject(eUnCheck, 0x9992, 15, 15, -1, -1);
    const short optionButtons[] = {
        eUSERSPANEL_STATICEFFECT, eUSERSPANEL_DISABLEOBJECT,
        eUSERSPANEL_DISABLEWINGS, eUSERSPANEL_DISABLESKILL
    };
    for (int i = 0; i < sizeof(optionButtons) / sizeof(optionButtons[0]); i++) {
        this->BindObject(optionButtons[i], 0x9991, 15, 15, -1, -1);
    }

    // 후크 및 초기화
    SetCompleteHook(0xE8, oLoadSomeForm_Call, &this->LoadImages);
    SetCompleteHook(0xE8, oDrawInterface_Call, &this->Work);

    lastReport = GetTickCount();
    frameCount = 0;
    iniciador = 1;
}



void Interface::ImageLoad(char * Folder, int Code, int Arg3, int Arg4, int Arg5, int Arg6)
{
	char path[255];
	strcpy(path, ".\\Data\\");

	strcat(path, Folder);

	std::string Buffer = path;

	size_t pos = Buffer.find("jpg");

	if (pos != std::string::npos)
	{
		Buffer.replace(pos,3,"ozj");
	}
	else
	{
		pos = Buffer.find("tga");

		if (pos != std::string::npos)
		{
			Buffer.replace(pos,3,"ozt");
		}
		else
		{
			//ErrorMessageBox("[%s] Load error! Pos = %d", Buffer, pos);
		}
	}

	if (FileExist(Buffer.c_str()) == false)
	{
		//ErrorMessageBox("[%s] - NOT FOUND", Buffer.c_str());
	}

	pLoadImage(Folder,Code,Arg3,Arg4,Arg5,Arg6);
}

void Interface::LoadImages()
{

	//float MainWidth = 138.0;
    //float MainHeight = 265.0; 

	//MessageBox(NULL,"#7","Warning!",NULL);
	
	//pLoadImage("Custom\\Interface\\TimeBar.tga", 0x8200, 0x2601, 0x2901, 1, 0);

	/*pLoadImage("Custom\\Interface\\Rank01.tga", 0x8300, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank02.tga", 0x8299, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank03.tga", 0x8302, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank04.tga", 0x8303, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank05.tga", 0x8304, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank06.tga", 0x8305, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank07.tga", 0x8306, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank08.tga", 0x8307, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank09.tga", 0x8308, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank10.tga", 0x8309, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank11.tga", 0x8310, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank12.tga", 0x8311, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank13.tga", 0x8312, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank14.tga", 0x8313, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank15.tga", 0x8314, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank16.tga", 0x8315, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank17.tga", 0x8316, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank18.tga", 0x8317, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank19.tga", 0x8318, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank20.tga", 0x8319, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank21.tga", 0x8320, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank22.tga", 0x8321, 0x2601, 0x2901, 1, 0);*/


	gEmojis.LoadImages(); // Emoji System

	pLoadImage("Custom\\Interface\\Rank010.tga", 0x17880, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank020.tga", 0x17881, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank030.tga", 0x17882, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank040.tga", 0x17883, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank050.tga", 0x17884, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank060.tga", 0x17885, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank070.tga", 0x17886, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank080.tga", 0x17887, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank090.tga", 0x17888, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Rank100.tga", 0x17889, 0x2601, 0x2901, 1, 0);


	pLoadImage("Custom\\Interface\\camera.tga", 0x10036,  0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\camerareset.tga", 0x10037,  0x2601, 0x2901, 1, 0);

	//pLoadImage("Custom\\Interface\\main.tga", 90000, 0x2601, 0x2901, 1, 0);

	pLoadImage("Custom\\Interface\\Ranking.tga", 0x8322, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Next.tga", 0x8323, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Previous.tga", 0x8324, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\MU-logo.tga", 0x8325, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\Menu1.tga", 80000, 0x2601, 0x2901, 1, 0);
	pLoadImage("Custom\\Interface\\check.jpg", 0x9991, 0x2601, 0x2900, 1, 0);
	pLoadImage("Custom\\Interface\\uncheck.jpg", 0x9992, 0x2601, 0x2900, 1, 0);
 if (gInterface.ShowInfoUser)
 {
	pLoadImage("Custom\\Interface\\character_ex.tga",  60000, GL_LINEAR, 0x2901, 1, 0);
	//this->BindObject(eMenu1, 60000, 118, 54, -1, -1);
 	gInterface.ShowInfoUser = true;
 }
 else
 {
	gInterface.ShowInfoUser = false;	
 }


	pLoadImage("Custom\\Interface\\ui_dialog_d.tga", 0x9326, 0x2601, 0x2900, 1, 0);
	pLoadImage("Custom\\Interface\\itembackpanel.tga", 0x9327, GL_LINEAR, GL_CLAMP, 1, 0);
	pLoadImage("Custom\\interface\\topmenutabbt1.tga", 0x788E, 0x2601, 0x2900, 1, 0);

	pLoadImage("Custom\\interface\\ui_dialog_e.tga", 0x9331, 0x2601, 0x2900, 1, 0);
	pLoadImage("Custom\\interface\\QuaMoc.tga", 0x9332, 0x2601, 0x2900, 1, 0);

	pLoadImage("Custom\\Interface\\IconQua.tga", 0x9B62, 0x2601, 0x2900, 1, 0);

	pLoadImage("Custom\\Interface\\op2_b_all.tga", 0x50000, 0x2601, 0x2900, 1, 0);
	pLoadImage("Custom\\Interface\\op1_b_all.tga", 0x50001, 0x2601, 0x2900, 1, 0);

	pLoadImage("Custom\\interface\\RPSMode\\rock.tga", 0x9323, 0x2601, 0x2900, 1, 0);
	pLoadImage("Custom\\interface\\RPSMode\\paper.tga", 0x9324, 0x2601, 0x2900, 1, 0);
	pLoadImage("Custom\\interface\\RPSMode\\scissors.tga", 0x9325, 0x2601, 0x2900, 1, 0);


	pLoadImage("Custom\\interface\\Next.tga", 0x50002, 0x2601, 0x2900, 1, 0);
	pLoadImage("Custom\\interface\\Previous.tga", 0x50003, 0x2601, 0x2900, 1, 0);

	pLoadImage("Effect\\flare01.jpg", 52002, GL_LINEAR, GL_REPEAT, 1, 0); //32002
	pLoadImage("Effect\\JointLaser01.jpg", 52224, GL_LINEAR, GL_REPEAT, 1, 0); //32486
	pLoadImage("Effect\\hikorora.jpg", 52379, GL_LINEAR, GL_REPEAT, 1, 0); //32644
	pLoadImage("Effect\\flareBlue.jpg", 52229, GL_LINEAR, GL_REPEAT, 1, 0); //32492
	pLoadImage("Effect\\shiny06.jpg", 32587, GL_LINEAR, GL_REPEAT, 1, 0); //32838
	pLoadImage("Effect\\bostar3_R.jpg", 32614, GL_LINEAR, GL_REPEAT, 1, 0); //32831


	//gSmithy.LoadImg();
	gAchievements.LoadImages();
	gRageSystem.LoadImages();
	// ----
	pLoadSomeForm();

}

void Interface::Run()
{
	this->AutoPVP();
}

void Interface::BindObject(short MonsterID, DWORD ModelID, float Width, float Height, float X, float Y)
{
	this->Data[MonsterID].EventTick	= 0;
	this->Data[MonsterID].OnClick	= false;
	this->Data[MonsterID].OnShow	= false;
	this->Data[MonsterID].ModelID	= ModelID;
	this->Data[MonsterID].Width		= Width;
	this->Data[MonsterID].Height	= Height;
	this->Data[MonsterID].X			= X;
	this->Data[MonsterID].Y			= Y;
	this->Data[MonsterID].MaxX		= X + Width;
	this->Data[MonsterID].MaxY		= Y + Height;
	this->Data[MonsterID].Attribute	= 0;
}

void Interface::ResetDrawIMG(short ObjectID)
{
	if( this->Data[ObjectID].X != -1 || this->Data[ObjectID].Y != -1 )
	{
		this->Data[ObjectID].X		= -1;
		this->Data[ObjectID].Y		= -1;
		this->Data[ObjectID].MaxX	= -1;
		this->Data[ObjectID].MaxY	= -1;
	}
}

//퀘스트
bool Interface::CheckInQueue(std::string name)
{
	if (this->m_InterfaceQueue.find(name) != this->m_InterfaceQueue.end())
	{
		return true;
	}

	return false;
}

void Interface::DelFromQueue(std::string name)
{
	if (!this->CheckInQueue(name))
	{
		return;
	}

	this->m_InterfaceQueue.erase(name);
	
}

void Interface::AddToQueue(std::string name, void(Interface::*func)())
{
	if (this->CheckInQueue(name))
	{
		return;
	}

	this->m_InterfaceQueue[name] = std::bind(func, this);
}

//퀘스트

bool Interface::CheckWindowEx(int WindowID)
{
	return this->Data[WindowID].OnShow;
	//return pCheckWindow(pWindowThis(), WindowID);
}




void Interface::OpenWindowEx(int WindowID)
{
	//업적
	if(WindowID == eMenu_OPT21)
	{
		if(this->CheckWindowEx(ObjWindowsEx::exWinAchievements))
		{
			this->CloseWindowEx(ObjWindowsEx::exWinAchievements);
		}

		if(this->CheckWindowEx(ObjWindowsEx::exWinAchievementsPower))
		{
			this->CloseWindowEx(ObjWindowsEx::exWinAchievementsPower);
		}
	}

	this->WindowEx[WindowID] = 1;
	Data[WindowID].Open();
}

void Interface::CloseWindowEx(int WindowID)
{
	Data[WindowID].Close();
}


//룰렛
void testfunc()
{
	glMatrixMode(0x1700u);
	glPopMatrix();
	glMatrixMode(0x1701u);
	glPopMatrix();
}

void Interface::AutoPVP()
{
	if (showPVPon == 1)
	{
		return;
	}

	DrawInterfaceText("PVP MODE ON", MAX_WIN_WIDTH - 50, 2, eRed, 0, 0, 30.0f, 1);
}

void Interface::DrawItem2(float PosX, float PosY, float Width, float Height, int ItemID, int Level, int Excl, int Anc, bool OnMouse) // code hien thi item
{
 
    glMatrixMode(0x1701);
    glPushMatrix();
    glLoadIdentity();
 
    sub_62FB2C_Addr(0, 0, *(GLsizei*)MAIN_RESOLUTION_X, *(GLsizei*)MAIN_RESOLUTION_Y);
    float v2 = *(float*)MAIN_RESOLUTION_X / *(float*)MAIN_RESOLUTION_Y;
   // sub_62EF4E_Addr(1.0, v2, *(float*)0xE61E38, *(float*)0xE61E3C);
	sub_62EF4E_Addr(1.0, v2, *(float*)0x118EE18, *(float*)0x118EE1C);
 
    glMatrixMode(0x1700);
    glPushMatrix();
    glLoadIdentity();
 
	sub_62EEF1_Addr((LPVOID)0x8B15680); //S8 0x08B15680
	sub_62F5AF_Addr();
	sub_62F5F3_Addr();

	pDrawItemModel(PosX, PosY, Width, Height, ItemID, Level, Excl, Anc, OnMouse);
   
    testfunc();
 
    glColor3f(1,1,1);
	pSetBlend(false);
}
////

void Interface::DrawWindow(int ObjMain, int ObjTitle, int ObjFrame, int ObjFooter, int Repeat, float X, float Y, char* Text)
{
	float StartY = Y;
	float StartX = X;

	gInterface.DrawGUI(ObjMain, StartX, StartY + 2);
	gInterface.DrawGUI(ObjTitle, StartX, StartY);
	StartY = gInterface.DrawRepeatGUI(ObjFrame, StartX, StartY + 67.0, Repeat);
	gInterface.DrawGUI(ObjFooter, StartX, StartY);

	gInterface.DrawFormat(eGold, StartX + 10, Y + 10, 210, 3, 0, Text);
}


void Interface::DrawAnimatedGUI(short ObjectID, float PosX, float PosY)
{
	this->Data[ObjectID].X		= PosX;
	this->Data[ObjectID].Y		= PosY;
	this->Data[ObjectID].MaxX	= PosX + this->Data[ObjectID].Width;
	this->Data[ObjectID].MaxY	= PosY + this->Data[ObjectID].Height;
	// ----
	pDrawGUI(this->Data[ObjectID].ModelID, PosX, PosY, 
		this->Data[ObjectID].Width, this->Data[ObjectID].Height);
}

void Interface::DrawGUI(short ObjectID, float PosX, float PosY)
{
	if( this->Data[ObjectID].X == -1 || this->Data[ObjectID].Y == -1 )
	{
		this->Data[ObjectID].X		= PosX;
		this->Data[ObjectID].Y		= PosY;
		this->Data[ObjectID].MaxX	= PosX + this->Data[ObjectID].Width;
		this->Data[ObjectID].MaxY	= PosY + this->Data[ObjectID].Height;
	}

	pDrawGUI(this->Data[ObjectID].ModelID, PosX, PosY,this->Data[ObjectID].Width, this->Data[ObjectID].Height);
}

void Interface::DrawGUI1(short ObjectID)
{
	pDrawGUI(this->Data[ObjectID].ModelID, this->Data[ObjectID].X, this->Data[ObjectID].Y,
		this->Data[ObjectID].Width, this->Data[ObjectID].Height);
}

void Interface::DrawIMG(short ObjectID, float PosX, float PosY, float ScaleX, float ScaleY)
{
	if( this->Data[ObjectID].X == -1 || this->Data[ObjectID].Y == -1 )
	{
		this->Data[ObjectID].X		= PosX;
		this->Data[ObjectID].Y		= PosY;
		this->Data[ObjectID].MaxX	= PosX + this->Data[ObjectID].Width;
		this->Data[ObjectID].MaxY	= PosY + this->Data[ObjectID].Height;
	}

	pDrawImage(this->Data[ObjectID].ModelID, PosX, PosY,this->Data[ObjectID].Width, this->Data[ObjectID].Height,0,0,ScaleX,ScaleY,1,1,0);
}

void Interface::DrawAnimatedButton(short ObjectID, float PosX, float PosY, float ScaleX, float ScaleY)
{
	//if (this->Data[ObjectID].X == -1 || this->Data[ObjectID].Y == -1)
	//{
		this->Data[ObjectID].X = PosX;
		this->Data[ObjectID].Y = PosY;
		this->Data[ObjectID].MaxX = PosX + this->Data[ObjectID].Width;
		this->Data[ObjectID].MaxY = PosY + this->Data[ObjectID].Height;
	//}
	// ----
	pDrawButton(this->Data[ObjectID].ModelID, PosX, PosY,
	this->Data[ObjectID].Width, this->Data[ObjectID].Height, ScaleX, ScaleY);
}
// ----------------------------------------------------------------------------------------------

bool checkBtn(int obj)
{
	if (gObjUser.m_CursorX < gInterface.Data[obj].X || gObjUser.m_CursorX > gInterface.Data[obj].MaxX || 
		gObjUser.m_CursorY < gInterface.Data[obj].Y || gObjUser.m_CursorY > gInterface.Data[obj].MaxY)
	{
		//g_Console.AddMessage(5,"false!");
		return false;
	}
	return true;
}

void Interface::DrawButtonGUI(short ObjectID, float PosX, float PosY, float Width, float Height, float ScaleX, float ScaleY,bool ScaleSize, bool ScalePosition, bool ScaleAlpha)
{
	if( this->Data[ObjectID].X == -1 || this->Data[ObjectID].Y == -1 )
	{
		this->Data[ObjectID].X		= PosX;
		this->Data[ObjectID].Y		= PosY;
		this->Data[ObjectID].MaxX	= PosX + this->Data[ObjectID].Width;
		this->Data[ObjectID].MaxY	= PosY + this->Data[ObjectID].Height;
	}
	pDrawImage(this->Data[ObjectID].ModelID, PosX,PosY,Width,Height,0.0,0.0,ScaleX,ScaleY,1,1,0.0);
}
//퀘스트
void Interface::DrawFormatEx(DWORD Color, int PosX, int PosY, int Width, int Align, LPCSTR Text, ...)
{
	char Buff[2048];
	int BuffLen	= sizeof(Buff)-1;
	ZeroMemory(Buff, BuffLen);
	
	va_list args;
	va_start(args, Text);
	int Len	= vsprintf_s(Buff, BuffLen, Text, args);
	va_end(args);
	
	pDrawColorText(Buff, PosX, PosY, Width, 0, Color, 0, Align);
}
//퀘스트

void Interface::DrawBarForm(float PosX,float PosY,float Width,float Height,GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
	pSetBlend(1);
	glColor4f(red, green, blue, alpha);
	pDrawBarForm(PosX,PosY,Width,Height,0.0f, 0);
	pGLSwitchBlend();
	pGLSwitch();
	glColor3f(1.0, 1.0, 1.0);
}


void Interface::DrawCheckLineEx(bool isChecked, int PointID, int CheckID, int LineID, float X, float Y, DWORD Color, char* Text)
{
	this->DrawAnimatedGUI(PointID, X+20 , Y-4); // Point
	this->DrawFormat(eWhite, X+50, Y+1, 200, 1,0, Text);

	if (isChecked)
	{
		this->DrawAnimatedButton(CheckID, X+190, Y-6, 0, 0);
	}
	else
	{
		this->DrawAnimatedButton(CheckID, X+190, Y-6, 0, 15);
	}

	this->DrawAnimatedGUI(LineID, X+33, Y+10);
}


/*
bool Interface::AllowGUI()
{
	if( gInterface.Data[eCHANGINGCLASS_MAIN].Check())
	{
		return false;
	}
	// ----
	return pAllowGUI();
}*/


void Interface::TextDraw(int PosX, int PosY, int Width, int Arg5, int Color, int Arg7, int Align, HGDIOBJ Font, LPCTSTR Format, ...)
{
	char TextBuff[1024] = {0};
	va_list va;
	va_start(va, Format);
	vsprintf_s(TextBuff, Format, va);
	va_end(va);

	int v13; // ST1C_4@1
	int v15; // ST20_4@1
	pSetFont(pTextThis(), (int)Font);
	v13 = sub_41FFE0_Addr(pTextThis());
	v15 = sub_420010_Addr(pTextThis());
	SetTextColorByHDC(pTextThis(), Color);
	sub_4200F0_Addr(pTextThis(), Arg7);
	pSetBkColor(pTextThis(),255,255,255,0);
	pDrawText(pTextThis(), PosX, PosY, TextBuff, Width, Arg5, (int*)Align, 0);
	SetTextColorByHDC(pTextThis(), v13);
	sub_4200F0_Addr(pTextThis(), v15);
}

void Interface::MiniButtonDraw(int BtnID, float X, float Y, bool isHover, char* Text)
{
	//int x = GetPrivateProfileIntA("Custom", "X", -35, "./Settings.ini");
	//int y = GetPrivateProfileIntA("Custom", "Y", 60, "./Settings.ini");

	if (isHover)
	{
		this->DrawAnimatedButton(BtnID, X, Y, 0, 29);
	}
	else
	{
		this->DrawAnimatedButton(BtnID, X, Y, 0, 0);
	}
	this->DrawFormat(eWhite, X+7, Y+9, 50, 3,0, Text);
	//this->DrawGUI(LineID, X+33, Y+10);
}

bool Interface::ButtonEx(DWORD Event, int ButtonID, bool Type)
{
	//g_Console.AddMessage(5,"ENTER");
	//if( !this->IsWorkZone(ButtonID) )
	//g_Console.AddMessage(5,"%f - %f | %f - %f", this->Data[ButtonID].X, this->Data[ButtonID].MaxX,this->Data[ButtonID].Y, this->Data[ButtonID].MaxY );
	//if (!this->IsWorkZone(this->Data[ButtonID].X, this->Data[ButtonID].MaxX,this->Data[ButtonID].Y, this->Data[ButtonID].MaxY))
	if (!checkBtn(ButtonID))
	{
		//g_Console.AddMessage(3,"return because its shit");
		return false;
	}

	if( Type == true )
	{
		if( !this->Data[ButtonID].Attribute )
		{
			//g_Console.AddMessage(3,"return2");
			return false;
		}
	}

	// ----
	DWORD CurrentTick	= GetTickCount();
	DWORD Delay			= (CurrentTick - this->Data[ButtonID].EventTick);
	// ----

	if( Event == WM_LBUTTONDOWN  && this->Data[ButtonID].OnClick == false)
	{
		this->Data[ButtonID].OnClick = true;
		//return true;
	}
	if (Event != WM_LBUTTONUP)
	{
		return false;
	}
	/*if(Event == WM_LBUTTONUP && this->Data[ButtonID].OnClick == true)
	{
		this->Data[ButtonID].OnClick = false;
		return true;
	}*/
	// ----
	if( Delay < 500 )
	{
		//g_Console.AddMessage(3,"return3");
		return false;
	}
	// ----
	this->Data[ButtonID].OnClick = false;
	// ----
	this->Data[ButtonID].EventTick = GetTickCount();
	// ----
	//g_Console.AddMessage(3,"return successfully");
	return true;
}


void Interface::PartUPandDNEx(int PointID, int UpID, int DownID, int LineID, float X, float Y, DWORD Color, int Value, char* Text)
{
	this->DrawAnimatedGUI(PointID, X+20 , Y-4); // Point

	this->DrawFormat(eWhite, X+50, Y+1, 200, 1,0, Text);

	this->DrawAnimatedButton(DownID, X+150, Y-6, 0, 0); // 

	if(checkBtn(DownID) )
	{
		//g_Console.AddMessage(3," %d ", this->Data[DownID].OnClick);
		if( this->Data[DownID].OnClick )
		{
			//g_Console.AddMessage(3,"CLICK!");
			this->DrawAnimatedButton(DownID, X+150, Y-6, 0, 16);
		}
	}

	//this->DrawToolTip(X+x, Y+y, "%d", Value);
	pSetBlend(true);
	this->DrawBarForm(X+168, Y-5,19,13,0.0,0.0,0.0,1.0);//ReqItems
	glColor3f(1,1,1);
	pSetBlend(false);
	char szText[10];
	sprintf(szText,"%d",Value);
	this->TextDraw(X+128, Y-2, 100, 1, eWhite, 0, 3, 0 ,"%d",Value);
	//TestDrawText(szText, X+128, Y-2, 100, 1, eWhite, 0, 3,pFontNormal);
	//this->DrawBarForm(X+x, Y+y,w,h,0.04,0.34,0.0,1.0);//ReqItems

	this->DrawAnimatedButton(UpID, X+190, Y-6, 0, 0); // 

	if(checkBtn(UpID) )
	{
		//g_Console.AddMessage(3," %d ", this->Data[UpID].OnClick);
		if( this->Data[UpID].OnClick )
		{
			//g_Console.AddMessage(3,"CLICK!");
			this->DrawAnimatedButton(UpID, X+190, Y-6, 0, 16);
		}
	}



	this->DrawGUI(LineID, X+33, Y+10);
}

//int __thiscall sub_9150DF(void *this)





int ItemDevBack = 0;

//워크
void Interface::Work()
{
	/*if( GetForegroundWindow() == pGameWindow )
	{

		if (GetKeyState(VK_SNAPSHOT) < 0) 
		{
			gInterface.DrawLogo(1); 
		}
		if (GetKeyState(VK_END) & 0x4000) 
		{
			if((GetTickCount()-gInterface.Data[eVip_MAIN].EventTick) > 300)
			{
				if (gInterface.CheckVipWindow())
				{
					gInterface.Data[eVip_MAIN].EventTick = GetTickCount();
					gInterface.CloseVipWindow();
				}
				else
				{
					gInterface.Data[eVip_MAIN].EventTick = GetTickCount();
					gInterface.CloseCustomWindow();
					gInterface.OpenVipWindow();
				}
			}
		}
		//if (GetKeyState('H') & 0x4000) 
		//{
		//	gCustomEventTime.OpenWindow();
		//}
		if (GetKeyState(VK_F8) & 0x4000) 
		{
			gCustomRanking.OpenWindow();
		}
		if (GetKeyState(VK_ESCAPE) < 0) 
		{
			if (gInterface.Data[eCommand_MAIN].OnShow == true)
			{
				gInterface.Data[eCommand_MAIN].OnShow = false;
				pSetCursorFocus = false;
			}

			if (gInterface.Data[eRankPANEL_MAIN].OnShow == true)
			{
				gInterface.Data[eRankPANEL_MAIN].OnShow = false;
				pSetCursorFocus = false;
			}

			if (gInterface.Data[eEventTimePANEL_MAIN].OnShow == true)
			{
				gInterface.Data[eEventTimePANEL_MAIN].OnShow = false;
				pSetCursorFocus = false;
			}

			if (gInterface.CheckVipWindow())
			{
				gInterface.CloseVipWindow();
			}

			if (gInterface.CheckMenuWindow())
			{
				gInterface.CloseMenuWindow();
			}
		}
	} */

	//jewellsbank
	gCustomJewelBank.DrawJewelBankWindow();
	
	gObjUser.Refresh();
	gCustomRanking.DrawRankPanelWindow();
	gCustomEventTime.DrawEventTimePanelWindow();
	gInterface.DrawLogo(0);
	ReconnectMainProc();
	//gInterface.DrawTimeUI();
	gInterface.DrawVipWindow();
	gInterface.DrawMenu();
	gInterface.DrawMenuOpen();
	gInterface.DrawConfirmOpen();
	gCustomCommandInfo.DrawCommandWindow();
	//gSmithy.Draw();
	gInterface.DrawChangingClassWindow(); //변생

	gInterface.DrawOpAntiLag();

	//gInterface.guiMonitore();
	gInterface.SendPingRecv();
	gInterface.UPDATE_FPS();

	//gInterface.DrawAutoCtrl1();
	gInterface.DrawAutoCtrl2();
	//gInterface.DrawAutoCtrl3();

	gAchievements.Draw();
	//g_Achievements.Draw(); //업적k

	gAchievements.DrawPanel();

	gRageSystem.rDrawInterface();
	//gRageSystem.ResetRageDraw();


	gInterface.DrawQuaMocRS();

	gInterface.DrawRPS(); //가위바위

	gInterface.DrawCameraButton();
	gInterface.DrawCameraResetButton();

	//gInterface.DrawAutoChange();
	//gInterface.DrawOffExp();
	gLuckySpin.Draw();
	pDrawInterface();
	if( GetForegroundWindow() == pGameWindow )
	{
		if (GetKeyState(VK_INSERT) & 0x4000) 
		{
			gInterface.ShowInfoUser = true;
		}
		if (GetKeyState(VK_F6) & 0x4000 && GetTickCount() >= gInterface.MenuAntlagDelayClick + 250) 
		{
			if (pCheckWindowNew(WindowID(ObjWindowNew::_ChatWindow)))//if (!gInterface.CheckWindow(ObjWindow::ChatWindow))
			{
			    if (gInterface.CheckOpMenuAntiLag())
				{
		            gInterface.CloseOpMenuAntiLag();
	            }
				else
				{
		            gInterface.OpenOpMenuAntiLag();
				}
			}
			gInterface.MenuAntlagDelayClick = GetTickCount();
		}
		if (GetKeyState(VK_DELETE) & 0x4000) 
		{
			gInterface.ShowInfoUser = false;
		}
		if (GetKeyState(VK_F8) & 0x4000 && GetTickCount() >= gInterface.AutoControlDelay + 250) {
			if(gInterface.varTestCntrl == 0){
				SetByte(0x005A064D+2,0);
				SetByte(0x0059FE7F+2,0);
				//gInterface.DrawMessage(1, "Autro Control [ON]");
				gInterface.varTestCntrl = 1;
			}else{
				SetByte(0x005A064D+2,1);
				SetByte(0x0059FE7F+2,1);
				//gInterface.DrawMessage(1, "Autro Control [OFF]");
				gInterface.varTestCntrl = 0;
			}
			gInterface.AutoControlDelay = GetTickCount();
		}
	}

	

	
	return;
}


void Interface::DrawAutoCtrl()
{

	if(gServerInfo.m_AutoCtrl == false)
	{
		gServerInfo.m_AutoCtrl = true;

		USERBUTTON_REQ pRequest;
		pRequest.Head.set(0xFF,0x0C,sizeof(pRequest));
		DataSend((BYTE*)&pRequest,pRequest.Head.size);
		SetByte(0x005A064D+2,0);
		SetByte(0x0059FE7F+2,0);
		
	}
	else
	{
		gServerInfo.m_AutoCtrl = false;

		USERBUTTON_REQ pRequest;
		pRequest.Head.set(0xFF,0x0C,sizeof(pRequest));
		DataSend((BYTE*)&pRequest,pRequest.Head.size);
		keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0);
		SetByte(0x005A064D+2,1);
		SetByte(0x0059FE7F+2,1);
	}

}

void Interface::DrawAutoChange()
{

	if (gServerInfo.m_AutoChange == false) 
	{
		gServerInfo.m_AutoChange = true;
		USERBUTTON_REQ1 pRequest;
		pRequest.Head.set(0xFF,0x0E,sizeof(pRequest));
		DataSend((BYTE*)&pRequest,pRequest.Head.size);
	}
	else
	{
		gServerInfo.m_AutoChange = false;
		USERBUTTON_REQ1 pRequest;
		pRequest.Head.set(0xFF,0x0E,sizeof(pRequest));
		DataSend((BYTE*)&pRequest,pRequest.Head.size);

	}

}

//길드어택
void Interface::DrawGuildAttack()
{

	if (gServerInfo.m_AutoGuildAttack == false) 
	{
		gServerInfo.m_AutoGuildAttack = true;
		USERBUTTON_REQ2 pRequest;
		pRequest.Head.set(0xFF,0x0D,sizeof(pRequest));
		DataSend((BYTE*)&pRequest,pRequest.Head.size);
	}
	else
	{
		gServerInfo.m_AutoGuildAttack = false;
		USERBUTTON_REQ2 pRequest;
		pRequest.Head.set(0xFF,0x0D,sizeof(pRequest));
		DataSend((BYTE*)&pRequest,pRequest.Head.size);

	}


}
void Interface::DrawOffExp()
{

	if (gServerInfo.m_AutoExp == false) 
	{
		gServerInfo.m_AutoExp = true;
		USERBUTTON_REQ3 pRequest;
		pRequest.Head.set(0xFF,0x0F,sizeof(pRequest));
		DataSend((BYTE*)&pRequest,pRequest.Head.size);
	}
	else
	{
		gServerInfo.m_AutoExp = false;
		USERBUTTON_REQ3 pRequest;
		pRequest.Head.set(0xFF,0x0F,sizeof(pRequest));
		DataSend((BYTE*)&pRequest,pRequest.Head.size);

	}


}


void Interface::DrawAutoCtrl2()
{
 if (gInterface.ShowInfoUser)
 {
	//this->DrawGUI(eMenu1, 2, 140);

	//this->DrawFormat(eShinyGreen1, 43, 30, 100, 1,1, "포인트정보");

	this->DrawFormat(eWhite, 10, 148, 100, 1,1, "캐시:");
    this->DrawFormat(eGold, 30, 148, 100, 1,1, "%d", Coin1);

	this->DrawFormat(eWhite, 10, 163, 100, 1,1, "알씨:");
    this->DrawFormat(eGold, 30, 163, 100, 1,1, "%d", Coin2);

	this->DrawFormat(eWhite, 10, 177, 100, 1,1, "고포:");
    this->DrawFormat(eGold, 30, 177, 100, 1,1, "%d", Coin3);

	gInterface.ShowInfoUser = true;	
 }
 else
 {
	gInterface.ShowInfoUser = false;	
 }
	return;
}

void Interface::DrawAutoCtrl3()
{
	this->DrawFormat(eWhite, 250, 4, 400, 1,1, "[F5]메뉴 [F7]창고 [F8]상점 [F12]클라숨김");
	return;
}


void Interface::DrawTimeUI()
{

	//MessageBox(NULL,"#7","Warning!",NULL);
	if( !this->Data[eTIME].OnShow )
	{
		return;
	}
	// ----
	/*if( this->CheckWindow(ObjWindow::ChatWindow) || this->CheckWindow(ObjWindow::CashShop)
	|| this->CheckWindow(ObjWindow::FullMap) || this->CheckWindow(ObjWindow::SkillTree)
	|| this->CheckWindow(ObjWindow::MoveList) || gObjUser.m_MapNumber == 34 || gObjUser.m_MapNumber == 30 )*/
	//if(this->CheckWindow(ObjWindow::CashShop)|| this->CheckWindow(ObjWindow::FullMap) || this->CheckWindow(ObjWindow::ChatWindow) || this->CheckWindow(ObjWindow::SkillTree)
	//	|| this->CheckWindow(ObjWindow::MoveList) || pMapNumber == 34 || pMapNumber == 30 )
	//{
	//	return;
	//}
	// ----
	//this->DrawGUI(eTIME, 0, -3);

	this->DrawGUI(eTIME, this->Data[eTIME].X, this->Data[eTIME].Y);
	this->DrawGUI(eTIME, this->Data[eTIME].X, this->Data[eTIME].Y+22);
	// -----
	time_t TimeServer, TimeLocal;
	struct tm * ServerT, * LocalT;
	time(&TimeServer);
	time(&TimeLocal);
	// ----
	ServerT = gmtime(&TimeServer);
	// ----
	char ServerTimeName[25] = "Server:";
	char ServerTime[30];

	sprintf(ServerTime, "%2d:%02d:%02d", (ServerT->tm_hour)%24, ServerT->tm_min, ServerT->tm_sec);
	// -----
	LocalT = localtime(&TimeLocal); 
	// -----
	char LocalTimeName[25] = "Local:";
	char LocalTime[30];
	sprintf(LocalTime, "%2d:%02d:%02d", LocalT->tm_hour, LocalT->tm_min, LocalT->tm_sec);
	// -----
	this->DrawFormat(eGold, 5, 391, 50, 1, 0, ServerTimeName);
	this->DrawFormat(eWhite, 55, 391, 100, 1, 0, ServerTime);
	// ----
	this->DrawFormat(eGold, 5, 413, 50, 1, 0, LocalTimeName);
	this->DrawFormat(eWhite, 55, 413, 100, 1, 0, LocalTime);

	pDrawColorText("Teste", 5, 300, 50, 0, eGold, 0, 1);
}

int Interface::DrawFormat(DWORD Color, int PosX, int PosY, int Width, int Align, int Bold, LPCSTR Text, ...)
{
	char Buff[2048];
	int BuffLen	= sizeof(Buff)-1;
	ZeroMemory(Buff, BuffLen);
	
	va_list args;
	va_start(args, Text);
	int Len	= vsprintf_s(Buff, BuffLen, Text, args);
	va_end(args);
	
	int LineCount = 0;
	
	char * Line = strtok(Buff, "\n");
	
	while( Line != NULL )
	{
		pDrawColorText(Line, PosX, PosY, Color, 1, Align, Width, Bold);
		PosY += 10;
		Line = strtok(NULL, "\n");
	}
	
	return PosY;
}

bool Interface::CheckWindow(int WindowID)
{
	return pCheckWindow(pWindowThis(), WindowID);
}
int Interface::CloseWindow(int WindowID)
{
	return pCloseWindow(pWindowThis(), WindowID);
}
int Interface::OpenWindow(int WindowID)
{
	return pOpenWindow(pWindowThis(), WindowID);
}


bool Interface::IsWorkZone(float X, float Y, float MaxX, float MaxY)
{
	if( (pCursorX < X || pCursorX > MaxX) 
		|| (pCursorY < Y || pCursorY > MaxY) )
	{
		return false;
	}
	// ----
	return true;
}

bool Interface::IsWorkZone(short ObjectID)
{
	if( (gObjUser.m_CursorX < this->Data[ObjectID].X || gObjUser.m_CursorX > this->Data[ObjectID].MaxX) || (gObjUser.m_CursorY < this->Data[ObjectID].Y || gObjUser.m_CursorY > this->Data[ObjectID].MaxY) )
		return false;

	return true;
}

float Interface::GetResizeX(short ObjectID)
{
	//if( pWinWidth == 800 )
	//{
	//	return this->Data[ObjectID].X + 16.0;
	//}
	//else if( pWinWidth != 1024 )
	//{
	//	return this->Data[ObjectID].X - 16.0;
	//}
	//
	//return this->Data[ObjectID].X;

	return 0;
}

int Interface::DrawToolTip(int X, int Y, LPCSTR Text, ...)
{
	char Buff[2048];
	int BuffLen	= sizeof(Buff);
	ZeroMemory(Buff, BuffLen);
	
	va_list args;
	va_start(args, Text);
	int Len	= vsprintf_s(Buff, BuffLen, Text, args);
	va_end(args);
	
	return pDrawToolTip(X, Y, Buff);
}

int Interface::DrawMessage(int Mode, LPCSTR Text, ...)
{
	char Buff[2048];
	int BuffLen	= sizeof(Buff);
	ZeroMemory(Buff, BuffLen);
	// ----
	va_list args;
	va_start(args, Text);
	int Len	= vsprintf_s(Buff, BuffLen, Text, args);
	va_end(args);
	// ----
	//return pDrawMessage(Buff, Mode);
}


void Interface::DrawVipWindow()
{

	if( !this->Data[eVip_MAIN].OnShow )
	{
		return;
	}

	if( gProtect.m_MainInfo.EnableVipShop != 1 )
	{
		this->CloseVipWindow();
		return;
	}

	//SetCompleteHook(0xE8,0x62EB8D,&this->DisableName);

	// ----
	float MainWidth			= 230.0;
	float MainHeight		= 180.0;
	float StartBody			= 80.0;
	float StartY			= 80.0;
	float StartX			= (MAX_WIN_WIDTH / 2) - (MainWidth / 2) + 200;
	float MainCenter		= StartX + (MainWidth / 3);
	float ButtonX			= MainCenter - (float)(29.0 / 2);
	// ----
	this->DrawGUI(eVip_MAIN, StartX, StartY + (float)2.0);
	this->DrawGUI(eVip_TITLE, StartX, StartY);
	StartY = this->DrawRepeatGUI(eVip_FRAME, StartX, StartY + (float)15.0, 13);
	this->DrawGUI(eVip_FOOTER, StartX, StartY);
	this->DrawGUI(eVip_CLOSE, StartX + MainWidth - this->Data[eVip_CLOSE].Width, StartBody);
	// ----
	if (this->IsWorkZone(eVip_CLOSE))
	{
		DWORD Color = eGray100;
		// ----
		if (this->Data[eVip_CLOSE].OnClick)
		{
			Color = eGray150;
		}
		// ----
		this->DrawColoredGUI(eVip_CLOSE, this->Data[eVip_CLOSE].X, StartBody, Color);
		this->DrawToolTip((int)this->Data[eVip_CLOSE].X + 5, StartBody + 25, "닫기");
	}
	// ----
	this->DrawFormat(eGold, (int)StartX + 10, (int)StartBody + 10, 210, 3, 1, gCustomMessage.GetMessage(5));
	int LineY = this->DrawFormat(eWhite, (int)StartX + 30, (int)StartBody + 35, 210, 1, 0, gCustomMessage.GetMessage(6), gObjUser.lpPlayer->Name);
	LineY = this->DrawFormat(eGold, (int)StartX + 30, (int)LineY, 210, 1, 1, gCustomMessage.GetMessage(14));
	LineY = this->DrawFormat(eWhite, (int)StartX + 30, (int)LineY, 210, 1, 1, gCustomMessage.GetMessage(7));
	LineY = this->DrawFormat(eWhite, (int)StartX + 30, (int)LineY, 210, 1, 1, gCustomMessage.GetMessage(8));
	// ----
	this->DrawGUI(eVip_DIV, StartX, StartBody + 70);
	this->DrawFormat(eGold, (int)StartX + 30, (int)StartBody + 95 - 2, 210, 1, 1, "버프");
	this->DrawFormat(eGold, (int)StartX + 80, (int)StartBody + 95 - 2 , 210, 1, 1, "경험치");
	this->DrawFormat(eGold, (int)StartX + 130, (int)StartBody + 95 - 2, 210, 1, 1, "드랍율");
	this->DrawFormat(eGold, (int)StartX + 170, (int)StartBody + 95 - 2, 210, 1, 1, "시간");
	// ----
	if (gProtect.m_MainInfo.VipTypes < 1 || gProtect.m_MainInfo.VipTypes > 3)
	{
		gProtect.m_MainInfo.VipTypes = 3;
	}

	for( int i = 0; i < gProtect.m_MainInfo.VipTypes; i++ )
	{
		this->DrawFormat(eWhite, (int)StartX + 30, (int)StartBody + 110 + (12 * i) - 5, 210, 1, 1, gCustomBuyVip.m_CustomBuyVipInfo[i].VipName);
		// ----
		this->DrawFormat(eWhite, (int)StartX + 80, (int)StartBody + 110 + (12 * i) - 5, 210, 1, 1, "+%d%%", gCustomBuyVip.m_CustomBuyVipInfo[i].Exp);
		// ----
		this->DrawFormat(eWhite, (int)StartX + 130, (int)StartBody + 110 + (12 * i) - 5, 210, 1, 1, "+%d%%", gCustomBuyVip.m_CustomBuyVipInfo[i].Drop);
		// ----
		this->DrawFormat(eWhite, (int)StartX + 170, (int)StartBody + 110 + (12 * i) - 5, 210, 1, 1, "%d일", gCustomBuyVip.m_CustomBuyVipInfo[i].Days);

		pDrawGUI(0x7B5E, StartX + 30, StartBody + 110 + (12 * i) + 9 - 5, 82.0, 2.0);
		pDrawGUI(0x7B5E, StartX + 30 + 82, StartBody + 110 + (12 * i) + 9 - 5, 82.0, 2.0);
	}

	if (gProtect.m_MainInfo.VipTypes > 0)
	{
	// ---- bronze start 
	if (IsWorkZone(eVip_BRONZE))
	{
		if (this->Data[eVip_BRONZE].OnClick)
			this->DrawButton(eVip_BRONZE, StartX + 64, 230, 0, 58);
		else
			this->DrawButton(eVip_BRONZE, StartX + 64, 230, 0, 29);
		// ----
		this->DrawFormat(eGold, (int)StartX + 30, (int)StartBody + 142, 210, 1, 1, gCustomMessage.GetMessage(10));
		this->DrawFormat(eGold, (int)StartX + 70, (int)StartBody + 142, 210, 1, 1, gCustomMessage.GetMessage(11), gCustomBuyVip.m_CustomBuyVipInfo[0].Coin1);
		this->DrawFormat(eGold, (int)StartX + 120, (int)StartBody + 142, 210, 1, 1, gCustomMessage.GetMessage(12), gCustomBuyVip.m_CustomBuyVipInfo[0].Coin2);
		this->DrawFormat(eGold, (int)StartX + 160, (int)StartBody + 142, 210, 1, 1, gCustomMessage.GetMessage(13), gCustomBuyVip.m_CustomBuyVipInfo[0].Coin3);
	}
	else
		this->DrawButton(eVip_BRONZE, StartX + 64, 230, 0, 0);
	// ----
	this->DrawFormat(eWhite, (int)StartX + 90, 230 + 9, 160, 1, 1, gCustomMessage.GetMessage(9),gCustomBuyVip.m_CustomBuyVipInfo[0].VipName);
	// ---- bronze end ------------------------------------
	}

	if (gProtect.m_MainInfo.VipTypes > 1)
	{
	// ---- Silver start ------------------------------------
	if (IsWorkZone(eVip_SILVER))
	{
		if (this->Data[eVip_SILVER].OnClick)
			this->DrawButton(eVip_SILVER, StartX + 64, 260, 0, 58);
		else
			this->DrawButton(eVip_SILVER, StartX + 64, 260, 0, 29);
		// ----
		this->DrawFormat(eGold, (int)StartX + 30, (int)StartBody + 142, 210, 1, 1, gCustomMessage.GetMessage(10));
		this->DrawFormat(eGold, (int)StartX + 70, (int)StartBody + 142, 210, 1, 1, gCustomMessage.GetMessage(11), gCustomBuyVip.m_CustomBuyVipInfo[1].Coin1);
		this->DrawFormat(eGold, (int)StartX + 120, (int)StartBody + 142, 210, 1, 1, gCustomMessage.GetMessage(12), gCustomBuyVip.m_CustomBuyVipInfo[1].Coin2);
		this->DrawFormat(eGold, (int)StartX + 160, (int)StartBody + 142, 210, 1, 1, gCustomMessage.GetMessage(13), gCustomBuyVip.m_CustomBuyVipInfo[1].Coin3);
	}
	else
		this->DrawButton(eVip_SILVER, StartX + 64, 260, 0, 0);

	this->DrawFormat(eWhite, (int)StartX + 90, 260 + 9, 160, 1, 1, gCustomMessage.GetMessage(9),gCustomBuyVip.m_CustomBuyVipInfo[1].VipName);
	// ---- silver end ------------------------------------
	}

	if (gProtect.m_MainInfo.VipTypes > 2)
	{
	// ---- gold start ------------------------------------
	if (IsWorkZone(eVip_GOLD))
	{
		if (this->Data[eVip_GOLD].OnClick)
			this->DrawButton(eVip_GOLD, StartX + 64, 290, 0, 58);
		else
			this->DrawButton(eVip_GOLD, StartX + 64, 290, 0, 29);
		// ----
		this->DrawFormat(eGold, (int)StartX + 30, (int)StartBody + 142, 210, 1, 1, gCustomMessage.GetMessage(10));
		this->DrawFormat(eGold, (int)StartX + 70, (int)StartBody + 142, 210, 1, 1, gCustomMessage.GetMessage(11), gCustomBuyVip.m_CustomBuyVipInfo[2].Coin1);
		this->DrawFormat(eGold, (int)StartX + 120, (int)StartBody + 142, 210, 1, 1, gCustomMessage.GetMessage(12), gCustomBuyVip.m_CustomBuyVipInfo[2].Coin2);
		this->DrawFormat(eGold, (int)StartX + 160, (int)StartBody + 142, 210, 1, 1, gCustomMessage.GetMessage(13), gCustomBuyVip.m_CustomBuyVipInfo[2].Coin3);
	}
	else
		this->DrawButton(eVip_GOLD, StartX + 64, 290, 0, 0);

	this->DrawFormat(eWhite, (int)StartX + 90, 290 + 9, 160, 1, 1, gCustomMessage.GetMessage(9),gCustomBuyVip.m_CustomBuyVipInfo[2].VipName);
	// ---- gold end ------------------------------------
	}
}

bool Interface::EventVipWindow_Close(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eVip_CLOSE].EventTick);
	// ----
	if (!this->Data[eVip_MAIN].OnShow || !IsWorkZone(eVip_CLOSE))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		this->Data[eVip_CLOSE].OnClick = true;
		return true;
	}
	// ----
	this->Data[eVip_CLOSE].OnClick = false;
	// ----
	if (Delay < 500)
	{
		return false;
	}
	// ----
	this->Data[eVip_CLOSE].EventTick = GetTickCount();
	this->CloseVipWindow();
	// ----
	return false;
}
// ----------------------------------------------------------------------------------------------

bool Interface::EventVipWindow_Bronze(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eVip_BRONZE].EventTick);
	// ----
	if (!this->Data[eVip_MAIN].OnShow || !IsWorkZone(eVip_BRONZE))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		this->Data[eVip_BRONZE].OnClick = true;
		return true;
	}
	// ----
	this->Data[eVip_BRONZE].OnClick = false;;
	// ----
	if (Delay < 500)
	{
		return false;
	}
	// ----
	this->Data[eVip_BRONZE].EventTick = GetTickCount();
	gCustomBuyVip.BuyStatus(1);
	this->CloseVipWindow();
	// ----
	return false;
}
// ----------------------------------------------------------------------------------------------

bool Interface::EventVipWindow_Silver(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eVip_SILVER].EventTick);
	// ----
	if (!this->Data[eVip_MAIN].OnShow || !IsWorkZone(eVip_SILVER))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		this->Data[eVip_SILVER].OnClick = true;
		return true;
	}
	// ----
	this->Data[eVip_SILVER].OnClick = false;;
	// ----
	if (Delay < 500)
	{
		return false;
	}
	// ----
	this->Data[eVip_SILVER].EventTick = GetTickCount();
	gCustomBuyVip.BuyStatus(2);
	this->CloseVipWindow();
	// ----
	return false;
}

// ----------------------------------------------------------------------------------------------
bool Interface::EventVipWindow_Gold(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eVip_GOLD].EventTick);
	// ----
	if (!this->Data[eVip_MAIN].OnShow || !IsWorkZone(eVip_GOLD))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		this->Data[eVip_GOLD].OnClick = true;
		return true;
	}
	// ----
	this->Data[eVip_GOLD].OnClick = false;;
	// ----
	if (Delay < 500)
	{
		return false;
	}
	// ----
	this->Data[eVip_GOLD].EventTick = GetTickCount();
	gCustomBuyVip.BuyStatus(3);
	this->CloseVipWindow();
	// ----
	return false;
}
// ----------------------------------------------------------------------------------------------

bool Interface::EventVipWindow_Main(DWORD Event)
{
	this->EventVipWindow_Close(Event);
	this->EventVipWindow_Bronze(Event);
	this->EventVipWindow_Silver(Event);
	this->EventVipWindow_Gold(Event);
	// ----
	return true;
}

float Interface::DrawRepeatGUI(short MonsterID, float X, float Y, int Count)
{
	float StartY = Y;
	// ----
	for( int i = 0; i < Count; i++ )
	{
		pDrawGUI(this->Data[MonsterID].ModelID, X, StartY,
			this->Data[MonsterID].Width, this->Data[MonsterID].Height);
		// ----
		StartY += this->Data[MonsterID].Height;
	}
	// ----
	return StartY;
}

void Interface::DrawButton(short ObjectID, float PosX, float PosY, float ScaleX, float ScaleY)
{
	if (this->Data[ObjectID].X == -1 || this->Data[ObjectID].Y == -1)
	{
		this->Data[ObjectID].X = PosX;
		this->Data[ObjectID].Y = PosY;
		this->Data[ObjectID].MaxX = PosX + this->Data[ObjectID].Width;
		this->Data[ObjectID].MaxY = PosY + this->Data[ObjectID].Height;
	}
	// ----
	pDrawButton(this->Data[ObjectID].ModelID, PosX, PosY,
		this->Data[ObjectID].Width, this->Data[ObjectID].Height, ScaleX, ScaleY);
}

void Interface::DrawColorGUI(int MainID, int X, int Y, int Width, int Height, DWORD Color)
{
	pDrawColorButton(MainID, X, Y, Width, Height, 0, 0, Color);
}


void Interface::DrawColoredGUI(short ObjectID, float X, float Y, DWORD Color)
{
	if( this->Data[ObjectID].X == -1 || this->Data[ObjectID].Y == -1 )
	{
		this->Data[ObjectID].X		= X;
		this->Data[ObjectID].Y		= Y;
		this->Data[ObjectID].MaxX	= X + this->Data[ObjectID].Width;
		this->Data[ObjectID].MaxY	= Y + this->Data[ObjectID].Height;
	}
	// ----
	pDrawColorButton(this->Data[ObjectID].ModelID, X, Y, 
		this->Data[ObjectID].Width, this->Data[ObjectID].Height, 0, 0, Color);
}

void Interface::DrawColoredGUI22(short ObjectID, DWORD Color)
{
	pDrawColorButton(this->Data[ObjectID].ModelID, this->Data[ObjectID].X, this->Data[ObjectID].Y,
		this->Data[ObjectID].Width, this->Data[ObjectID].Height, 0, 0, Color);
}

void Interface::DisableName()
{
	static DWORD AAddress1 = 0x0062EB95;

	_asm
	{
		mov     eax, 0
		movzx   eax, byte ptr [eax+73h]
		leave
		Jmp [AAddress1]
	}
}

void Interface::DrawLogo(bool active)
{
	if (gProtect.m_MainInfo.PrintLogo != 0)
	{

		if (active == 1)
		{
			this->Data[eLogo].EventTick = GetTickCount()+1500;
		}
		if (gInterface.Data[eLogo].EventTick > GetTickCount())
		{
			if (gProtect.m_MainInfo.PrintLogo == 1)
			{
				this->DrawGUI(eLogo, 10, 10);
			}

			if (gProtect.m_MainInfo.PrintLogo == 2)
			{
				this->DrawGUI(eLogo, MAX_WIN_WIDTH - 160, 10);

			}

			if (gProtect.m_MainInfo.PrintLogo == 3)
			{
				this->DrawGUI(eLogo, 10, MAX_WIN_HEIGHT - 164);
			}

			if (gProtect.m_MainInfo.PrintLogo == 4)
			{
				this->DrawGUI(eLogo, MAX_WIN_WIDTH - 160, MAX_WIN_HEIGHT - 164);
			}

			if (gProtect.m_MainInfo.PrintLogo == 5)
			{
				this->DrawGUI(eLogo, (MAX_WIN_WIDTH/2)-(150/2), (MAX_WIN_HEIGHT/2)-(114/2));
			}
		}
	}
}

//메뉴
void Interface::DrawMenu()
{
	if (gProtect.m_MainInfo.CustomMenuSwitch != 1)
	{
		return;
	}

	if(pCheckWindowNew(WindowID(_MoveCommand))) //
	{
		return;
	}

	if (this->Data[eMenu].OnShow)
	{
		this->Data[eMenu].OnShow = false;
	}


	float StartX = 4;
	float StartY = 455;
	

	if (IsWorkZone(eMenu))
		{
			this->DrawToolTip(StartX+2, StartY-14, "커스텀 메뉴");

		if (this->Data[eMenu].OnClick)
		{
			this->Data[eMenu].OnShow = true;
			return;
		}
		pSetBlend(true);
		this->DrawButtonGUI(eMenu, StartX, StartY, 13.0,15.0,1.0, 1.0,1,1,0.0);
	}
	else
	{	
		pSetBlend(true);
		this->DrawButtonGUI(eMenu, StartX, StartY, 14.0,16.0,1.0, 1.0,1,1,0.0);
	}

	this->Data[eMenu].OnShow = true;
	
}

bool Interface::EventDrawMenu_Open(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eMenu].EventTick);
	// ----
	if (!this->Data[eMenu].OnShow || !IsWorkZone(eMenu))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		pSetCursorFocus = true;
		this->Data[eMenu].OnClick = true;
		return true;
	}
	// ----
	this->Data[eMenu].OnClick = false;
	// ----
	if (Delay < 200)
	{
		return false;
	}
	
	// ----
	this->Data[eMenu].EventTick = GetTickCount();
	
	if (CheckMenuWindow())
	{
		CloseMenuWindow();
	}
	else
	{
		CloseCustomWindow();
		OpenMenuWindow();
	}
	// ----
	return false;
}

void Interface::DrawMenuOpen()
{
	if (gProtect.m_MainInfo.CustomMenuSwitch != 1)
	{
		return;
	}

	if( !this->Data[eMenu_MAIN].OnShow )
	{
		return;
	}

	sub_62FBBB_Addr(0, 0, *(GLsizei*)MAIN_RESOLUTION_X+(GLsizei)1000, *(GLsizei*)MAIN_RESOLUTION_Y+(GLsizei)1000);

	sub_630E06_Addr();
	
	
	float MainWidth			= 230.0;
	float MainHeight		= 180.0;
	float StartBody			= 80.0;
	float StartY			= 80.0;
	float StartX			= (MAX_WIN_WIDTH / 2) - (MainWidth / 2) + 200;
	float MainCenter		= StartX + (MainWidth / 3);
	float ButtonX			= MainCenter - (float)(29.0 / 2);
	// ----
	this->DrawGUI(eMenu_MAIN, StartX, StartY + (float)2.0);
	this->DrawGUI(eMenu_TITLE, StartX, StartY);
	StartY = this->DrawRepeatGUI(eCHANGINGCLASS_FRAME, StartX, StartY + (float)15.0, 18);


	this->DrawGUI(eMenu_FOOTER, StartX, StartY);
	this->DrawGUI(eMenu_CLOSE, StartX + MainWidth - this->Data[eVip_CLOSE].Width, StartBody);
	// ----
	if (this->IsWorkZone(eMenu_CLOSE))
	{
		DWORD Color = eGray100;
		// ----
		if (this->Data[eMenu_CLOSE].OnClick)
		{
			Color = eGray150;
		}
		// ----
		this->DrawColoredGUI(eVip_CLOSE, this->Data[eMenu_CLOSE].X, StartBody, Color);
		this->DrawToolTip((int)this->Data[eMenu_CLOSE].X + 5, StartBody + 25, "닫기");
	} 

	this->DrawFormat(eGold, (int)StartX + 10, (int)StartBody + 20, 210, 3,1, "커스텀 메뉴");


/*	if(gProtect.m_MainInfo.EnableCoinStatus == 1)
	{
		this->DrawFormat(eGold, (int)StartX + 10, (int)StartBody + 35, 210, 3,1, gCustomMessage.GetMessage(50));

		this->DrawFormat(eWhite, (int)StartX + 25, (int)StartBody + 50, 40, 1,1, gCustomMessage.GetMessage(51));
		this->DrawFormat(eGold, (int)StartX + 50, (int)StartBody + 50, 40, 1,1, "%d",Coin1);

		this->DrawFormat(eWhite, (int)StartX + 90, (int)StartBody + 50, 40, 1,1, gCustomMessage.GetMessage(52));
		this->DrawFormat(eGold, (int)StartX + 115, (int)StartBody + 50, 40, 1,1, "%d",Coin2);

		this->DrawFormat(eWhite, (int)StartX + 153, (int)StartBody + 50, 40, 1,1, gCustomMessage.GetMessage(53));
		this->DrawFormat(eGold, (int)StartX + 176, (int)StartBody + 50, 40, 1,1, "%d",Coin3);
	}
	else
	{
		this->DrawFormat(eGold, (int)StartX + 10, (int)StartBody + 45, 210, 3,1, gCustomMessage.GetMessage(54));
	} */

	//this->DrawGUI(eVip_DIV, StartX, StartBody + 60);

	int BtCount		= 0;
	int BtStart		= StartBody + 56;
	int BtDistance	= 33;

	if (gProtect.m_MainInfo.EnableEventTimeButton == 1)
	{
		BtCount++;
	}
	else
	{	
		BtStart	-= 33;
	}
	if (gProtect.m_MainInfo.EnableVipShopButton == 1)
	{
		BtCount++;
	}
	if (gProtect.m_MainInfo.EnableRankingButton == 1)
	{
		BtCount++;
	}
	if (gProtect.m_MainInfo.EnableCommandButton == 1)
	{
		BtCount++;
	}
	if (gProtect.m_MainInfo.EnableOptionButton == 1)
	{
		BtCount++;
	}

	if (BtCount == 4)
	{
		BtStart		+= 15;
	}
	if (BtCount == 3)
	{
		BtStart		+= 30;
	}
	if (BtCount == 2)
	{
		BtStart		+= 45;
	}
	if (BtCount == 1)
	{
		BtStart		+= 60;
	}


	if (gProtect.m_MainInfo.EnableCommandButton == 1)
	{
	//Commandos

	if (IsWorkZone(eMenu_OPT4))
	{
		if (this->Data[eMenu_OPT4].OnClick)
			this->DrawButton(eMenu_OPT4, StartX +60, BtStart, 0, 58);
		else
			this->DrawButton(eMenu_OPT4, StartX + 60, BtStart, 0, 29);
		// ----
	}
	else
		this->DrawButton(eMenu_OPT4, StartX + 60, BtStart, 0, 0);

	this->DrawFormat(eWhite, (int)StartX + 60, BtStart + 9, 108, 3,0, "게임 명령어");
	}

	//Horario eventos
	if (gProtect.m_MainInfo.EnableEventTimeButton == 1)
	{
	BtStart += BtDistance;
	
	if (IsWorkZone(eMenu_OPT1))
	{
		if (this->Data[eMenu_OPT1].OnClick)
			this->DrawButton(eMenu_OPT1, StartX + 60, BtStart, 0, 58);
		else
			this->DrawButton(eMenu_OPT1, StartX + 60, BtStart, 0, 29);
		// ----
	}
	else
		this->DrawButton(eMenu_OPT1, StartX + 60, BtStart, 0, 0);

	this->DrawFormat(eWhite, (int)StartX + 60, BtStart + 9, 108, 3,0, "이벤트 시간");
	}

	//Comprar vip
	/*if (gProtect.m_MainInfo.EnableVipShopButton == 1)
	{
	
	BtStart += BtDistance;

	if (IsWorkZone(eMenu_OPT2))
	{
		if (this->Data[eMenu_OPT2].OnClick)
			this->DrawButton(eMenu_OPT2, StartX + 63, BtStart, 0, 58);
		else
			this->DrawButton(eMenu_OPT2, StartX + 63, BtStart, 0, 29);
		// ----
	}
	else
		this->DrawButton(eMenu_OPT2, StartX + 63, BtStart, 0, 0);

	this->DrawFormat(eWhite, (int)StartX + 63, BtStart + 9, 108, 3,1, gCustomMessage.GetMessage(26));
	}*/

	//Ranking
	if (gProtect.m_MainInfo.EnableRankingButton == 1)
	{
	BtStart += BtDistance;

	if (IsWorkZone(eMenu_OPT3))
	{
		if (this->Data[eMenu_OPT3].OnClick)
			this->DrawButton(eMenu_OPT3, StartX + 60, BtStart, 0, 58);
		else
			this->DrawButton(eMenu_OPT3, StartX + 60, BtStart, 0, 29);
		// ----
	}
	else
		this->DrawButton(eMenu_OPT3, StartX + 60, BtStart, 0, 0);

	this->DrawFormat(eWhite, (int)StartX + 60, BtStart + 9, 108, 3,0, "원피스 랭킹");
	}


/*
	if (gProtect.m_MainInfo.EnableCommandButton == 1)
	{
	//Commandos
	BtStart += BtDistance;

	if (IsWorkZone(eMenu_OPT4))
	{
		if (this->Data[eMenu_OPT4].OnClick)
			this->DrawButton(eMenu_OPT4, StartX + 64, BtStart, 0, 58);
		else
			this->DrawButton(eMenu_OPT4, StartX + 64, BtStart, 0, 29);
		// ----
	}
	else
		this->DrawButton(eMenu_OPT4, StartX + 64, BtStart, 0, 0);

	this->DrawFormat(eWhite, (int)StartX + 64, BtStart + 9, 108, 3,1, gCustomMessage.GetMessage(28));
	} */


	/*if (gProtect.m_MainInfo.EnableOptionButton == 1)
	{
	//Op寤es
	BtStart += BtDistance;

	if (IsWorkZone(eMenu_OPT20))
	{
		if (this->Data[eMenu_OPT20].OnClick)
			this->DrawButton(eMenu_OPT20, StartX + 64, BtStart, 0, 58);
		else
			this->DrawButton(eMenu_OPT20, StartX + 64, BtStart, 0, 29);
		// ----
	}
	else
		this->DrawButton(eMenu_OPT20, StartX + 64, BtStart, 0, 0);

	this->DrawFormat(eWhite, (int)StartX + 64, BtStart + 9, 108, 3,0, gCustomMessage.GetMessage(44));
	} */

	if (gProtect.m_MainInfo.EnableOptionButton == 1)
	{
	
	BtStart += BtDistance;

	if (IsWorkZone(eUSERSPANEL_CHANGINGCLASS))
	{
		if (this->Data[eUSERSPANEL_CHANGINGCLASS].OnClick)
			this->DrawButton(eUSERSPANEL_CHANGINGCLASS, StartX + 60, BtStart, 0, 58);
		else
			this->DrawButton(eUSERSPANEL_CHANGINGCLASS, StartX + 60, BtStart, 0, 29);
		// ----
	}
	else
		this->DrawButton(eUSERSPANEL_CHANGINGCLASS, StartX + 60, BtStart, 0, 0);
		this->DrawFormat(eWhite, (int)StartX + 60, BtStart + 9, 108, 3,0, "캐릭터 변생");

		
	}


	if (gProtect.m_MainInfo.EnableOptionButton == 1)
	{
	
	BtStart += BtDistance;

	if (IsWorkZone(eMenu_OPT22))
	{
		if (this->Data[eMenu_OPT22].OnClick)
			this->DrawButton(eMenu_OPT22, StartX + 60, BtStart, 0, 58);
		else
			this->DrawButton(eMenu_OPT22, StartX + 60, BtStart, 0, 29);
		// ----
	}
	else
		this->DrawButton(eMenu_OPT22, StartX + 60, BtStart, 0, 0);
		this->DrawFormat(eWhite, (int)StartX + 60, BtStart + 9, 108, 3,0, "레벨보상");
	
   }


	if (gProtect.m_MainInfo.EnableOptionButton == 1)
	{
	
	BtStart += BtDistance;

	if (IsWorkZone(eMenu_OPT21))
	{
		if (this->Data[eMenu_OPT21].OnClick)
			this->DrawButton(eMenu_OPT21, StartX +60, BtStart, 0, 58);
		else
			this->DrawButton(eMenu_OPT21, StartX + 60, BtStart, 0, 29);
		// ----
	}
	else
		this->DrawButton(eMenu_OPT21, StartX + 60, BtStart, 0, 0);
		this->DrawFormat(eWhite, (int)StartX + 60, BtStart + 9, 108, 3,1, "악마의능력");

		
	}

	//룰렛
	if (gProtect.m_MainInfo.EnableOptionButton == 1)
	{
	
	BtStart += BtDistance;

	if (IsWorkZone(eLuckymenu))
	{
		if (this->Data[eLuckymenu].OnClick)
			this->DrawButton(eLuckymenu, StartX +60, BtStart, 0, 58);
		else
			this->DrawButton(eLuckymenu, StartX + 60, BtStart, 0, 29);
		// ----
	}
	else
		this->DrawButton(eLuckymenu, StartX + 60, BtStart, 0, 0);
		this->DrawFormat(eWhite, (int)StartX + 60, BtStart + 9, 108, 3,1, "행운룰렛");

		
	} 

}

bool Interface::EventDrawMenu_Close(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eMenu_CLOSE].EventTick);
	// ----
	if (!this->Data[eMenu_MAIN].OnShow || !IsWorkZone(eMenu_CLOSE))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		this->Data[eMenu_CLOSE].OnClick = true;
		return true;
	}
	// ----
	this->Data[eMenu_CLOSE].OnClick = false;
	// ----
	if (Delay < 500)
	{
		return false;
	}
	// ----
	this->Data[eMenu_CLOSE].EventTick = GetTickCount();
	this->CloseMenuWindow();
	// ----
	return false;
}
// ----------------------------------------------------------------------------------------------


//몬스터업적
/*
void Interface::EventDrawMenu_Op21(DWORD Event)
{

	//if(!gInterface.CheckWindowEx(ObjWindowsEx::exWinMiniMenu))
	//{
	//	return;
	//}

	if(gInterface.ButtonEx(Event, eMenu_OPT21, false))
	{
		g_Achievements.CGWindowOpen();
		//gInterface.CloseWindowEx(exWinMiniMenu);
		this->CloseMenuWindow();
	}

	if(gInterface.ButtonEx(Event, eMenu_OPT22, false))
	{
		//gInterface.CloseWindowEx(exWinMiniMenu);	
		this->CloseMenuWindow();

		if(gInterface.CheckWindowEx(exWinAchievementsPower))
		{
			gInterface.CloseWindowEx(exWinAchievementsPower);
		}
		else
		{
			gInterface.OpenWindowEx(exWinAchievementsPower);
		}
	}

} */

//업적
bool Interface::EventDrawMenu_Op21(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eMenu_OPT21].EventTick);
	// ----
	if (!this->Data[eMenu_MAIN].OnShow || !IsWorkZone(eMenu_OPT21))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		this->Data[eMenu_OPT21].OnClick = true;
		return true;
	}
	// ----
	this->Data[eMenu_OPT21].OnClick = false;;
	// ----
	if (Delay < 500)
	{
		return false;
	}
	// ----
	this->Data[eMenu_OPT21].EventTick = GetTickCount();

	this->CloseMenuWindow();

	this->Data[OBJECT_ACHIEVEMENTS_PANEL].Open();
	// ----
	return false;
}

bool Interface::EventDrawMenu_Op0(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eSMITHY_MAIN1].EventTick);
	// ----
	if (!this->Data[eMenu_MAIN].OnShow || !IsWorkZone(eSMITHY_MAIN1))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		this->Data[eSMITHY_MAIN1].OnClick = true;
		return true;
	}
	// ----
	this->Data[eSMITHY_MAIN1].OnClick = false;;
	// ----
	if (Delay < 500)
	{
		return false;
	}
	// ----
	this->Data[eSMITHY_MAIN1].EventTick = GetTickCount();

	this->CloseMenuWindow();

	gSmithy.SwitchSmithyWindowState();
	// ----
	return false;
}

bool Interface::EventDrawMenu_Op1(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eMenu_OPT1].EventTick);
	// ----
	if (!this->Data[eMenu_MAIN].OnShow || !IsWorkZone(eMenu_OPT1))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		this->Data[eMenu_OPT1].OnClick = true;
		return true;
	}
	// ----
	this->Data[eMenu_OPT1].OnClick = false;;
	// ----
	if (Delay < 500)
	{
		return false;
	}
	// ----
	this->Data[eMenu_OPT1].EventTick = GetTickCount();

	this->CloseMenuWindow();

	gCustomEventTime.OpenWindow();
	// ----
	return false;
}

bool Interface::EventDrawMenu_Op2(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eMenu_OPT2].EventTick);
	// ----
	if (!this->Data[eMenu_MAIN].OnShow || !IsWorkZone(eMenu_OPT2))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		this->Data[eMenu_OPT2].OnClick = true;
		return true;
	}
	// ----
	this->Data[eMenu_OPT2].OnClick = false;;
	// ----
	if (Delay < 500)
	{
		return false;
	}
	// ----
	this->Data[eMenu_OPT2].EventTick = GetTickCount();

	this->CloseCustomWindow();

	this->OpenVipWindow();
	// ----
	return false;
}

bool Interface::EventDrawMenu_Op3(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eMenu_OPT3].EventTick);
	// ----
	if (!this->Data[eMenu_MAIN].OnShow || !IsWorkZone(eMenu_OPT3))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		this->Data[eMenu_OPT3].OnClick = true;
		return true;
	}
	// ----
	this->Data[eMenu_OPT3].OnClick = false;;
	// ----
	if (Delay < 500)
	{
		return false;
	}
	// ----
	this->Data[eMenu_OPT3].EventTick = GetTickCount();

	this->CloseMenuWindow();

	gCustomRanking.OpenWindow();
	// ----
	return false;
}

bool Interface::EventDrawMenu_Op4(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eMenu_OPT4].EventTick);
	// ----
	if (!this->Data[eMenu_MAIN].OnShow || !IsWorkZone(eMenu_OPT4))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		this->Data[eMenu_OPT4].OnClick = true;
		return true;
	}
	// ----
	this->Data[eMenu_OPT4].OnClick = false;;
	// ----
	if (Delay < 500)
	{
		return false;
	}
	// ----
	this->Data[eMenu_OPT4].EventTick = GetTickCount();

	this->CloseMenuWindow();

	gCustomCommandInfo.OpenCommandWindow();
	// ----
	return false;
}

//변생
bool Interface::EventDrawMenu_Op20(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eUSERSPANEL_CHANGINGCLASS].EventTick);
	// ----
	if (!this->Data[eMenu_MAIN].OnShow || !IsWorkZone(eUSERSPANEL_CHANGINGCLASS))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		this->Data[eUSERSPANEL_CHANGINGCLASS].OnClick = true;
		return true;
	}
	// ----
	this->Data[eUSERSPANEL_CHANGINGCLASS].OnClick = false;;
	// ----
	if (Delay < 500)
	{
		return false;
	}
	// ----
	this->Data[eUSERSPANEL_CHANGINGCLASS].EventTick = GetTickCount();

	this->Data[eMenu_MAIN].Close();

	this->Data[eCHANGINGCLASS_MAIN].Open();
	//변생
	// ----
	return false;
	//return true;
}

/*

bool Interface::EventDrawMenu_Op20(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eMenu_OPT20].EventTick);
	// ----
	if (!this->Data[eMenu_MAIN].OnShow || !IsWorkZone(eMenu_OPT20))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		this->Data[eMenu_OPT20].OnClick = true;
		return true;
	}
	// ----
	this->Data[eMenu_OPT20].OnClick = false;;
	// ----
	if (Delay < 500)
	{
		return false;
	}
	// ----
	this->Data[eMenu_OPT20].EventTick = GetTickCount();

	this->CloseMenuWindow();

	this->OpenWindow(ObjWindow::Options);
	// ----
	return false;
}*/


//레벨보상
bool Interface::EventDrawMenu_Op22(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eMenu_OPT22].EventTick);
	// ----
	if (!this->Data[eMenu_MAIN].OnShow || !IsWorkZone(eMenu_OPT22))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		this->Data[eMenu_OPT22].OnClick = true;
		return true;
	}
	// ----
	this->Data[eMenu_OPT22].OnClick = false;
	// ----
	if (Delay < 3000)
	{
		return false;
	}
	// ----
	this->Data[eMenu_OPT22].EventTick = GetTickCount();

	this->CloseMenuWindow();

	//this->Data[eMenu_MAIN].Close();

	//gInterface.Data[eQuaMocRSMain].Open();

	gInterface.QuaMocRSState();
	// ----
	return false;
} 


//행운룰렛
bool Interface::EventDrawMenu_Op23(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eLuckymenu].EventTick);
	// ----
	if (!this->Data[eMenu_MAIN].OnShow || !IsWorkZone(eLuckymenu))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		this->Data[eLuckymenu].OnClick = true;
		return true;
	}
	// ----
	this->Data[eLuckymenu].OnClick = false;

	// ----
	if (Delay < 500)
	{
		return false;
	}
	// ----
	this->Data[eLuckymenu].EventTick = GetTickCount();

	this->CloseMenuWindow();

	//if (GetForegroundWindow() == pGameWindow)
	//{
		gLuckySpin.SwitchLuckySpinWindowState();
		//gInterface.Data[eLuckySpin].Open();
	//}

	// ----
	return false;
} 


//종료
void Interface::CloseCustomWindow()
{
	this->CloseMenuWindow();
	this->CloseVipWindow();
	this->Data[eRankPANEL_MAIN].OnShow		= false;
	this->Data[eEventTimePANEL_MAIN].OnShow = false;
	this->Data[eCommand_MAIN].OnShow		= false;
	gInterface.Data[eCHANGINGCLASS_MAIN].OnShow = false;
	//gInterface.Data[eACHIEVEMENTS_PANEL].OnShow= false;
	gInterface.Data[OBJECT_ACHIEVEMENTS_PANEL].OnShow = false;
	gInterface.Data[OBJECT_ACHIEVEMENTS_MAIN].OnShow = false;
	gInterface.Data[eQuaMocRSMain].OnShow= false;
	this->Data[eCAMERA].OnShow		= false;
	this->Data[eCAMERA_RESET].OnShow		= false;
	this->Data[eLuckySpin].OnShow		= false;
	//this->Data[eImgID_ACHIEVEMENTS_MAIN].OnShow = false;

	pSetCursorFocus = false;
}

void Interface::DrawConfirmOpen()
{
	//if(!this->CheckWindow(Shop) && this->Data[eCONFIRM_MAIN].OnShow == true)
	//{
	//	this->Data[eCONFIRM_MAIN].OnShow = false;
	//	pSetCursorFocus = false;
	//}

	if ((GetTickCount() - this->Data[eCONFIRM_BTN_OK].EventTick) < 100)
	{
		this->Data[eCONFIRM_MAIN].OnShow = false;
		pSetCursorFocus = false;
	}

	if ((GetTickCount() - this->Data[eCONFIRM_BTN_CANCEL].EventTick) < 100)
	{
		this->Data[eCONFIRM_MAIN].OnShow = false;
		pSetCursorFocus = false;
	}

	if( !this->Data[eCONFIRM_MAIN].OnShow )
	{
		return;
	}

	//this->Data[eCONFIRM_MAIN].EventTick = GetTickCount();

	float MainWidth			= 230.0;
	float MainHeight		= 130.0;
	float StartBody			= 150.0;
	float StartY			= 150.0;
	float StartX			= (MAX_WIN_WIDTH / 2) - (MainWidth / 2);
	float MainCenter		= StartX + (MainWidth / 3);
	float ButtonX			= MainCenter - (float)(29.0 / 2);

	gInterface.DrawGUI(eCONFIRM_MAIN, StartX, StartY + (float)2.0);
	gInterface.DrawGUI(eVip_TITLE, StartX, StartY);
	StartY = gInterface.DrawRepeatGUI(eVip_FRAME, StartX, StartY + (float)5.0, 5);
	gInterface.DrawGUI(eVip_FOOTER, StartX, StartY);

		this->DrawFormat(eGold, (int)StartX + 10, (int)StartBody + 10, 210, 3, 0, gCustomMessage.GetMessage(66));

		this->DrawFormat(eGold, (int)StartX + 10, (int)StartBody + 40, 210, 3, 0, gCustomMessage.GetMessage(67));

		this->DrawButton(eCONFIRM_BTN_OK, (int)StartX+40, (int)StartBody + 70, 0, 0);

		if( this->IsWorkZone(eCONFIRM_BTN_OK) )
		{
			int ScaleY = 30;
			// ----
			if( this->Data[eCONFIRM_BTN_OK].OnClick )
			{
				ScaleY = 60;
			}
			// ----
			this->DrawButton(eCONFIRM_BTN_OK, (int)StartX+40, (int)StartBody + 70, 0, ScaleY);
		}

		this->DrawButton(eCONFIRM_BTN_CANCEL, (int)StartX+140, (int)StartBody + 70, 0, 0);

		if( this->IsWorkZone(eCONFIRM_BTN_CANCEL) )
		{
			int ScaleY = 30;
			// ----
			if( this->Data[eCONFIRM_BTN_CANCEL].OnClick )
			{
				ScaleY = 60;
			}
			// ----
			this->DrawButton(eCONFIRM_BTN_CANCEL, (int)StartX+140, (int)StartBody + 70, 0, ScaleY);
		}

}

bool Interface::EventConfirm_OK(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eCONFIRM_BTN_OK].EventTick);
	// ----
	if (!this->Data[eCONFIRM_MAIN].OnShow || !IsWorkZone(eCONFIRM_BTN_OK))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		this->Data[eCONFIRM_BTN_OK].OnClick = true;
		return true;
	}
	// ----
	this->Data[eCONFIRM_BTN_OK].OnClick = false;;
	// ----
	if (Delay < 500)
	{
		return false;
	}
	// ----
	this->Data[eCONFIRM_BTN_OK].EventTick = GetTickCount();

	PMSG_ITEM_BUY_RECV pMsg;

	pMsg.header.set(0xF3, 0xED,sizeof(pMsg));

	pMsg.slot = this->ConfirmSlot;

	DataSend((BYTE*)&pMsg,pMsg.header.size);

	this->Data[eCONFIRM_MAIN].OnShow = false;
	pSetCursorFocus = false;
	// ----
	return false;
}

bool Interface::EventConfirm_CANCEL(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eCONFIRM_BTN_CANCEL].EventTick);
	// ----
	if (!this->Data[eCONFIRM_MAIN].OnShow || !IsWorkZone(eCONFIRM_BTN_CANCEL))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		this->Data[eCONFIRM_BTN_CANCEL].OnClick = true;
		return true;
	}
	// ----
	this->Data[eCONFIRM_BTN_CANCEL].OnClick = false;;
	// ----
	if (Delay < 500)
	{
		return false;
	}
	// ----
	this->Data[eCONFIRM_BTN_CANCEL].EventTick = GetTickCount();

	this->Data[eCONFIRM_MAIN].OnShow = false;
	pSetCursorFocus = false;
	// ----
	return false;
}



//변생

void Interface::DrawChangingClassWindow()
{
	if( !this->Data[eCHANGINGCLASS_MAIN].OnShow )
	{
		return;
	}


	//DWORD ItemNameColor		= eWhite;
	float MainWidth			= 230.0;
	float MainHeight		= 180.0;
	float StartBody			= 80.0;
	float StartY			= 80.0;
	float StartX			= (MAX_WIN_WIDTH / 2) - (MainWidth / 2) + 200;
	float MainCenter		= StartX + (MainWidth / 3);
	float ButtonX			= MainCenter - (34.0 / 2);
	// ----
	this->DrawGUI(eCHANGINGCLASS_MAIN, StartX, StartY + (float)2.0);
	this->DrawGUI(eCHANGINGCLASS_TITLE, StartX, StartY);
	StartY = this->DrawRepeatGUI(eCHANGINGCLASS_FRAME, StartX, StartY + (float)15.0, 16);
	this->DrawGUI(eCHANGINGCLASS_FOOTER, StartX, StartY);
	this->DrawGUI(eCHANGINGCLASS_CLOSE, StartX + MainWidth - this->Data[eCHANGINGCLASS_CLOSE].Width, StartBody);
	// ----

	if( this->IsWorkZone(eCHANGINGCLASS_CLOSE) )
	{
		DWORD Color = eGray100;
		// ----
		if( this->Data[eCHANGINGCLASS_CLOSE].OnClick )
		{
			Color = eGray150;
		}
		// ----
		this->DrawColoredGUI(eCHANGINGCLASS_CLOSE, this->Data[eCHANGINGCLASS_CLOSE].X, StartBody, Color);
		this->DrawToolTip(this->Data[eCHANGINGCLASS_CLOSE].X + 5, StartBody + 25, "닫기");
	}
	// ----

	this->DrawFormat(eGold, StartX + 10, (int)StartBody + 20, 210, 3,0, "캐릭터 변생");

	// ----
	/*if (gChangeClass.m_PriceType == 0)
	{
		this->DrawFormat(eShinyGreen, StartX + 82, 343, 210, 1,0, "변생시 필요 금액: 30만 고포");
	}
	else if (gChangeClass.m_PriceType == 1)
	{
		this->DrawFormat(eShinyGreen, StartX + 82, 343, 210, 1,0, "변생시 필요 금액: 30만 캐시");
	}
	else if (gChangeClass.m_PriceType == 2)
	{
		this->DrawFormat(eShinyGreen, StartX + 82, 343, 210, 1,0, "변생시 필요 금액: 30만 루드");
	}
	else if (gChangeClass.m_PriceType == 3)
	{
		this->DrawFormat(eShinyGreen, StartX + 82, 343, 210, 1,0, "변생시 필요 금액: 30만 고포");
	}
	else if (gChangeClass.m_PriceType == 4)
	{
		this->DrawFormat(eShinyGreen, StartX + 82, 343, 210, 1,0, "변생시 필요 금액: 30만 크레딧");
	} */

	//this->DrawFormat(eGold, StartX + 70, 355, 210, 1,1, "%d",Coin1);

	/*this->DrawFormat(eRed, StartX + 10, 330, 210, 3, "Warning!", MoneyBuff, MoneyBuff2);
	this->DrawFormat(eBlue, StartX + 10, 338, 210, 3, "Before make changing class need remove all items from inventory", MoneyBuff, MoneyBuff2);*/
	// ----
	//this->DrawGUI(eCHANGINGCLASS_DW, ButtonX - 57, this->Data[eCHANGINGCLASS_MAIN].Y + 30);
	//this->DrawFormat(eWhite, StartX - 45, this->Data[eCHANGINGCLASS_MAIN].Y + 40, 210, 3, "%s class",pGetTextLine(pTextLineThis,20));
	this->DrawGUI(eCHANGINGCLASS_DW, ButtonX, this->Data[eCHANGINGCLASS_MAIN].Y + 45);
	this->DrawFormat(eWhite, StartX + 8, this->Data[eCHANGINGCLASS_MAIN].Y + 55, 210, 3,0, "%s",pGetTextLine(pTextLineThis,20));
	//pGetTextLine
	// ----
//	this->DrawGUI(eCHANGINGCLASS_DK, ButtonX + 52, this->Data[eCHANGINGCLASS_MAIN].Y + 30);
//	this->DrawFormat(eWhite, StartX + 62, this->Data[eCHANGINGCLASS_MAIN].Y + 40, 210, 3, "%s class",pGetTextLine(pTextLineThis,21));

	this->DrawGUI(eCHANGINGCLASS_DK, ButtonX, this->Data[eCHANGINGCLASS_MAIN].Y + 75);
	this->DrawFormat(eWhite, StartX + 8, this->Data[eCHANGINGCLASS_MAIN].Y + 85, 210, 3,0, "%s",pGetTextLine(pTextLineThis,21));
	// ----
//	this->DrawGUI(eCHANGINGCLASS_ELF, ButtonX - 57, this->Data[eCHANGINGCLASS_MAIN].Y + 60);
//	this->DrawFormat(eWhite, StartX - 45, this->Data[eCHANGINGCLASS_MAIN].Y + 70, 210, 3, "%s class",pGetTextLine(pTextLineThis,22));

	this->DrawGUI(eCHANGINGCLASS_ELF, ButtonX, this->Data[eCHANGINGCLASS_MAIN].Y + 105);
	this->DrawFormat(eWhite, StartX + 8, this->Data[eCHANGINGCLASS_MAIN].Y + 115, 210, 3,0, "%s",pGetTextLine(pTextLineThis,22));
	// ----
	//this->DrawGUI(eCHANGINGCLASS_MG, ButtonX + 52, this->Data[eCHANGINGCLASS_MAIN].Y + 60);
	//this->DrawFormat(eWhite, StartX + 62, this->Data[eCHANGINGCLASS_MAIN].Y + 70, 210, 3, "%s class",pGetTextLine(pTextLineThis,23));
	this->DrawGUI(eCHANGINGCLASS_MG, ButtonX, this->Data[eCHANGINGCLASS_MAIN].Y + 135);
	this->DrawFormat(eWhite, StartX + 8, this->Data[eCHANGINGCLASS_MAIN].Y + 145, 210, 3,0, "%s",pGetTextLine(pTextLineThis,23));

	// ----

	//this->DrawGUI(eCHANGINGCLASS_DL, ButtonX - 57, this->Data[eCHANGINGCLASS_MAIN].Y + 90);
	//this->DrawFormat(eWhite, StartX - 45, this->Data[eCHANGINGCLASS_MAIN].Y + 100, 210, 3, "%s class",pGetTextLine(pTextLineThis,24));

	this->DrawGUI(eCHANGINGCLASS_DL, ButtonX, this->Data[eCHANGINGCLASS_MAIN].Y + 165);
	this->DrawFormat(eWhite, StartX + 8, this->Data[eCHANGINGCLASS_MAIN].Y + 175, 210, 3,0, "%s",pGetTextLine(pTextLineThis,24));
	// ----
	if (7>=6)
	{
		//this->DrawGUI(eCHANGINGCLASS_SUM, ButtonX + 52, this->Data[eCHANGINGCLASS_MAIN].Y + 90);
		//this->DrawFormat(eWhite, StartX + 62, this->Data[eCHANGINGCLASS_MAIN].Y + 100, 210, 3, "%s class",pGetTextLine(pTextLineThis,1687));

		this->DrawGUI(eCHANGINGCLASS_SUM, ButtonX, this->Data[eCHANGINGCLASS_MAIN].Y + 195);
		this->DrawFormat(eWhite, StartX + 8, this->Data[eCHANGINGCLASS_MAIN].Y + 205, 210, 3,0, "%s",pGetTextLine(pTextLineThis,1687));
	}
	// ----
	if (7>=7)
	{
		this->DrawGUI(eCHANGINGCLASS_RF, ButtonX, this->Data[eCHANGINGCLASS_MAIN].Y + 225);
		this->DrawFormat(eWhite, StartX + 8, this->Data[eCHANGINGCLASS_MAIN].Y + 235, 210, 3,0, "%s",pGetTextLine(pTextLineThis,3150));
	}
	// ----
	//this->DrawGUI(eCHANGINGCLASS_DIV, StartX, this->Data[eCHANGINGCLASS_MAIN].Y + 212);
	// ----
	this->Data[eCHANGINGCLASS_DW].Attribute = true;
	this->Data[eCHANGINGCLASS_DK].Attribute = true;
	this->Data[eCHANGINGCLASS_ELF].Attribute = true;
	this->Data[eCHANGINGCLASS_MG].Attribute = true;
	this->Data[eCHANGINGCLASS_DL].Attribute = true;
	this->Data[eCHANGINGCLASS_SUM].Attribute = true;
	this->Data[eCHANGINGCLASS_RF].Attribute = true;
	// ----
	if( IsWorkZone(eCHANGINGCLASS_DW) )
	{

		if (this->Data[eCHANGINGCLASS_DW].OnClick)
			this->DrawButton(eCHANGINGCLASS_DW, this->Data[eCHANGINGCLASS_DW].X, this->Data[eCHANGINGCLASS_DW].Y, 0, 58);
		else
			this->DrawButton(eCHANGINGCLASS_DW,this->Data[eCHANGINGCLASS_DW].X, this->Data[eCHANGINGCLASS_DW].Y, 0, 29);

		gInterface.DrawFormat(eWhite, StartX + 8, this->Data[eCHANGINGCLASS_MAIN].Y + 55, 210, 3,0, "흑마법사");

	}
	if( IsWorkZone(eCHANGINGCLASS_DK) )
	{
		if (this->Data[eCHANGINGCLASS_DK].OnClick)
			this->DrawButton(eCHANGINGCLASS_DK, this->Data[eCHANGINGCLASS_DK].X, this->Data[eCHANGINGCLASS_DK].Y, 0, 58);
		else
			this->DrawButton(eCHANGINGCLASS_DK,this->Data[eCHANGINGCLASS_DK].X, this->Data[eCHANGINGCLASS_DK].Y, 0, 29);

		gInterface.DrawFormat(eWhite, StartX + 8, this->Data[eCHANGINGCLASS_MAIN].Y + 85, 210, 3,0, "흑기사");
	}
	if( IsWorkZone(eCHANGINGCLASS_ELF) )
	{
		if (this->Data[eCHANGINGCLASS_ELF].OnClick)
			this->DrawButton(eCHANGINGCLASS_ELF, this->Data[eCHANGINGCLASS_ELF].X, this->Data[eCHANGINGCLASS_ELF].Y, 0, 58);
		else
			this->DrawButton(eCHANGINGCLASS_ELF,this->Data[eCHANGINGCLASS_ELF].X, this->Data[eCHANGINGCLASS_ELF].Y, 0, 29);

		gInterface.DrawFormat(eWhite, StartX + 8, this->Data[eCHANGINGCLASS_MAIN].Y + 115, 210, 3,0, "요정");
	}
	if( IsWorkZone(eCHANGINGCLASS_MG) )
	{
		if (this->Data[eCHANGINGCLASS_MG].OnClick)
			this->DrawButton(eCHANGINGCLASS_MG, this->Data[eCHANGINGCLASS_MG].X, this->Data[eCHANGINGCLASS_MG].Y, 0, 58);
		else
			this->DrawButton(eCHANGINGCLASS_MG,this->Data[eCHANGINGCLASS_MG].X, this->Data[eCHANGINGCLASS_MG].Y, 0, 29);

		gInterface.DrawFormat(eWhite, StartX + 8, this->Data[eCHANGINGCLASS_MAIN].Y + 145, 210, 3,0, "마검사");
	}
	if( IsWorkZone(eCHANGINGCLASS_DL) )
	{
		if (this->Data[eCHANGINGCLASS_DL].OnClick)
			this->DrawButton(eCHANGINGCLASS_DL, this->Data[eCHANGINGCLASS_DL].X, this->Data[eCHANGINGCLASS_DL].Y, 0, 58);
		else
			this->DrawButton(eCHANGINGCLASS_DL,this->Data[eCHANGINGCLASS_DL].X, this->Data[eCHANGINGCLASS_DL].Y, 0, 29);

		gInterface.DrawFormat(eWhite, StartX + 8, this->Data[eCHANGINGCLASS_MAIN].Y + 175, 210, 3,0, "다크로드");
	}
	if( IsWorkZone(eCHANGINGCLASS_SUM) )
	{

		if (this->Data[eCHANGINGCLASS_SUM].OnClick)
			this->DrawButton(eCHANGINGCLASS_SUM, this->Data[eCHANGINGCLASS_SUM].X, this->Data[eCHANGINGCLASS_SUM].Y, 0, 58);
		else
			this->DrawButton(eCHANGINGCLASS_SUM,this->Data[eCHANGINGCLASS_SUM].X, this->Data[eCHANGINGCLASS_SUM].Y, 0, 29);

		gInterface.DrawFormat(eWhite, StartX + 8, this->Data[eCHANGINGCLASS_MAIN].Y + 205, 210, 3,0, "소환술사");
	}
	if( IsWorkZone(eCHANGINGCLASS_RF) )
	{
		if (this->Data[eCHANGINGCLASS_RF].OnClick)
			this->DrawButton(eCHANGINGCLASS_RF, this->Data[eCHANGINGCLASS_RF].X, this->Data[eCHANGINGCLASS_RF].Y, 0, 58);
		else
			this->DrawButton(eCHANGINGCLASS_RF,this->Data[eCHANGINGCLASS_RF].X, this->Data[eCHANGINGCLASS_RF].Y, 0, 29);

		gInterface.DrawFormat(eWhite, StartX + 8, this->Data[eCHANGINGCLASS_MAIN].Y + 235, 210, 3,0, "레이지파이터");
	}

}
// ----------------------------------------------------------------------------------------------

bool Interface::EventChangingClassWindow_Main(DWORD Event)
{
	this->EventChangingClassWindow_Close(Event);
	this->EventChangingClassWindow_DW(Event);
	this->EventChangingClassWindow_DK(Event);
	this->EventChangingClassWindow_ELF(Event);
	this->EventChangingClassWindow_MG(Event);
	this->EventChangingClassWindow_DL(Event);
	this->EventChangingClassWindow_SUM(Event);
	this->EventChangingClassWindow_RF(Event);
	return true;
	//return false;
}
// ----------------------------------------------------------------------------------------------

bool Interface::EventChangingClassWindow_Close(DWORD Event)
{
	DWORD CurrentTick	= GetTickCount();
	DWORD Delay			= (CurrentTick - this->Data[eCHANGINGCLASS_CLOSE].EventTick);
	// ----
	if( !this->Data[eCHANGINGCLASS_MAIN].OnShow || !IsWorkZone(eCHANGINGCLASS_CLOSE) )
	{
		return false;
	}
	// ----
	if( Event == WM_LBUTTONDOWN )
	{
		this->Data[eCHANGINGCLASS_CLOSE].OnClick = true;
		return true;
	}
	// ----
	this->Data[eCHANGINGCLASS_CLOSE].OnClick = false;
	// ----
	if( Delay < 500 )
	{
		return false;
	}
	// ----
	this->Data[eCHANGINGCLASS_CLOSE].EventTick = GetTickCount();
	this->Data[eCHANGINGCLASS_MAIN].Close();
	//pSetCursorFocus = false;
	//this->CloseChangingClassWindow();
	// ----
	return false;
}
// ----------------------------------------------------------------------------------------------

bool Interface::EventChangingClassWindow_DW(DWORD Event)
{
	DWORD CurrentTick	= GetTickCount();
	DWORD Delay			= (CurrentTick - this->Data[eCHANGINGCLASS_DW].EventTick);

	DWORD DelayUserPanel = (GetTickCount() - this->Data[eUSERSPANEL_CHANGINGCLASS].EventTick);
	if (DelayUserPanel < 500)
	{
		/////console.Log("", "return");
		return false;
	}
	// ----
	if( !this->Data[eCHANGINGCLASS_MAIN].OnShow || !IsWorkZone(eCHANGINGCLASS_DW) 
		|| !this->Data[eCHANGINGCLASS_DW].Attribute )
	{
		return false;
	}
	// ----
	if( Event == WM_LBUTTONDOWN )
	{
		this->Data[eCHANGINGCLASS_DW].OnClick = true;
		return true;
	}
	// ----
	this->Data[eCHANGINGCLASS_DW].OnClick = false;;
	// ----
	if( Delay < 500 )
	{
		return false;
	}
	// ----
	this->Data[eCHANGINGCLASS_DW].EventTick = GetTickCount();
	//gChangingClassSystem.ReqResetFinishDW();
	gChangeClass.SendChangeClass(0);
	// ----
	return false;
}
bool Interface::EventChangingClassWindow_DK(DWORD Event)
{
	DWORD CurrentTick	= GetTickCount();
	DWORD Delay			= (CurrentTick - this->Data[eCHANGINGCLASS_DK].EventTick);

	DWORD DelayUserPanel = (GetTickCount() - this->Data[eUSERSPANEL_CHANGINGCLASS].EventTick);
	if (DelayUserPanel < 500)
	{
		////console.Log("", "return");
		return false;
	}
	// ----
	if( !this->Data[eCHANGINGCLASS_MAIN].OnShow || !IsWorkZone(eCHANGINGCLASS_DK) 
		|| !this->Data[eCHANGINGCLASS_DK].Attribute )
	{
		return false;
	}
	// ----
	if( Event == WM_LBUTTONDOWN )
	{
		this->Data[eCHANGINGCLASS_DK].OnClick = true;
		return true;
	}
	// ----
	this->Data[eCHANGINGCLASS_DK].OnClick = false;;
	// ----
	if( Delay < 500 )
	{
		return false;
	}
	// ----
	this->Data[eCHANGINGCLASS_DK].EventTick = GetTickCount();
	//gChangingClassSystem.ReqResetFinishDK();
	gChangeClass.SendChangeClass(16);
	this->CloseChangingClassWindow();
	// ----
	return false;
}
bool Interface::EventChangingClassWindow_ELF(DWORD Event)
{
	DWORD CurrentTick	= GetTickCount();
	DWORD Delay			= (CurrentTick - this->Data[eCHANGINGCLASS_ELF].EventTick);

	DWORD DelayUserPanel = (GetTickCount() - this->Data[eUSERSPANEL_CHANGINGCLASS].EventTick);
	if (DelayUserPanel < 500)
	{
		////console.Log("", "return");
		return false;
	}
	// ----
	if( !this->Data[eCHANGINGCLASS_MAIN].OnShow || !IsWorkZone(eCHANGINGCLASS_ELF) 
		|| !this->Data[eCHANGINGCLASS_ELF].Attribute )
	{
		return false;
	}
	// ----
	if( Event == WM_LBUTTONDOWN )
	{
		this->Data[eCHANGINGCLASS_ELF].OnClick = true;
		return true;
	}
	// ----
	this->Data[eCHANGINGCLASS_ELF].OnClick = false;;
	// ----
	if( Delay < 500 )
	{
		return false;
	}
	// ----
	this->Data[eCHANGINGCLASS_ELF].EventTick = GetTickCount();
	//gChangingClassSystem.ReqResetFinishELF();
	gChangeClass.SendChangeClass(32);
	// ----
	return false;
}
bool Interface::EventChangingClassWindow_MG(DWORD Event)
{
	DWORD CurrentTick	= GetTickCount();
	DWORD Delay			= (CurrentTick - this->Data[eCHANGINGCLASS_MG].EventTick);


	DWORD DelayUserPanel = (GetTickCount() - this->Data[eUSERSPANEL_CHANGINGCLASS].EventTick);
	if (DelayUserPanel < 500)
	{
		////console.Log("", "return");
		return false;
	}

	// ----
	if( !this->Data[eCHANGINGCLASS_MAIN].OnShow || !IsWorkZone(eCHANGINGCLASS_MG) 
		|| !this->Data[eCHANGINGCLASS_MG].Attribute )
	{
		return false;
	}
	// ----
	if( Event == WM_LBUTTONDOWN )
	{
		this->Data[eCHANGINGCLASS_MG].OnClick = true;
		return true;
	}
	// ----
	this->Data[eCHANGINGCLASS_MG].OnClick = false;;
	// ----
	if( Delay < 500 )
	{
		return false;
	}
	// ----
	this->Data[eCHANGINGCLASS_MG].EventTick = GetTickCount();
	//gChangingClassSystem.ReqResetFinishMG();
	gChangeClass.SendChangeClass(48);
	// ----
	return false;
}
bool Interface::EventChangingClassWindow_DL(DWORD Event)
{
	DWORD CurrentTick	= GetTickCount();
	DWORD Delay			= (CurrentTick - this->Data[eCHANGINGCLASS_DL].EventTick);
	// ----

	DWORD DelayUserPanel = (GetTickCount() - this->Data[eUSERSPANEL_CHANGINGCLASS].EventTick);
	if (DelayUserPanel < 500)
	{
		////console.Log("", "return");
		return false;
	}

	if( !this->Data[eCHANGINGCLASS_MAIN].OnShow || !IsWorkZone(eCHANGINGCLASS_DL) 
		|| !this->Data[eCHANGINGCLASS_DL].Attribute )
	{
		return false;
	}
	// ----
	if( Event == WM_LBUTTONDOWN )
	{
		this->Data[eCHANGINGCLASS_DL].OnClick = true;
		return true;
	}
	// ----
	this->Data[eCHANGINGCLASS_DL].OnClick = false;;
	// ----
	if( Delay < 500 )
	{
		return false;
	}
	// ----
	this->Data[eCHANGINGCLASS_DL].EventTick = GetTickCount();
	//gChangingClassSystem.ReqResetFinishDL();
	gChangeClass.SendChangeClass(64);
	this->CloseChangingClassWindow();
	// ----
	return false;
}
bool Interface::EventChangingClassWindow_SUM(DWORD Event)
{
	DWORD CurrentTick	= GetTickCount();
	DWORD Delay			= (CurrentTick - this->Data[eCHANGINGCLASS_SUM].EventTick);


	// ----
	if (7<6)
	{
		return false;
	}
	// ----
	DWORD DelayUserPanel = (GetTickCount() - this->Data[eUSERSPANEL_CHANGINGCLASS].EventTick);
	if (DelayUserPanel < 500)
	{
		////console.Log("", "return");
		return false;
	}

	if( !this->Data[eCHANGINGCLASS_MAIN].OnShow || !IsWorkZone(eCHANGINGCLASS_SUM) 
		|| !this->Data[eCHANGINGCLASS_SUM].Attribute )
	{
		return false;
	}
	// ----
	if( Event == WM_LBUTTONDOWN )
	{
		this->Data[eCHANGINGCLASS_SUM].OnClick = true;
		return true;
	}
	// ----
	this->Data[eCHANGINGCLASS_SUM].OnClick = false;;
	// ----
	if( Delay < 500 )
	{
		return false;
	}
	// ----
	this->Data[eCHANGINGCLASS_SUM].EventTick = GetTickCount();
	//gChangingClassSystem.ReqResetFinishSUM();
	gChangeClass.SendChangeClass(80);
	// ----
	return false;
}
bool Interface::EventChangingClassWindow_RF(DWORD Event)
{
	DWORD CurrentTick	= GetTickCount();
	DWORD Delay			= (CurrentTick - this->Data[eCHANGINGCLASS_RF].EventTick);
	// ----
	if (7<7)
	{
		return false;
	}
	// ----

	DWORD DelayUserPanel = (GetTickCount() - this->Data[eUSERSPANEL_CHANGINGCLASS].EventTick);
	if (DelayUserPanel < 500)
	{
		////console.Log("", "return");
		return false;
	}

	if( !this->Data[eCHANGINGCLASS_MAIN].OnShow || !IsWorkZone(eCHANGINGCLASS_RF) 
		|| !this->Data[eCHANGINGCLASS_RF].Attribute )
	{
		return false;
	}
	// ----
	if( Event == WM_LBUTTONDOWN )
	{
		this->Data[eCHANGINGCLASS_RF].OnClick = true;
		return true;
	}
	// ----
	this->Data[eCHANGINGCLASS_RF].OnClick = false;;
	// ----
	if( Delay < 500 )
	{
		return false;
	}
	// ----
	this->Data[eCHANGINGCLASS_RF].EventTick = GetTickCount();
	//gChangingClassSystem.ReqResetFinishRF();
	gChangeClass.SendChangeClass(96);
	// ----
	return false;
}
// ---------------------------------------------------------------------------------------------

void Interface::CloseAllCustomWindow()
{
	//this->Data[eWAREHOUSE_MAIN].Close();
	//this->Data[eUSERSPANEL_MAIN].Close();
	this->Data[eCHANGINGCLASS_MAIN].Close();
	//this->Data[eRESET_MAIN].Close();
	//this->Data[eGRESET_MAIN].Close();
	//this->Data[eNEWS_MAIN].Close();
	//this->Data[eVIP_MAIN].Close();
	//this->Data[eOFFTRADE_MAIN].Close();
	//this->Data[eSETTINGS_MAIN].Close();
	//this->Data[eJEWEL_MAIN].Close();
	//this->Data[eDIABLO_MAIN].Close();
	//this->Data[ePARTYSETTINGS_MAIN].Close();
	//this->Data[ePARTYSEARCH_MAIN].Close();
	//this->Data[eTELEPORTPANEL_MAIN].Close();
	//this->Data[eOFFEXP_MAIN].Close();
}

void Interface::UPDATE_FPS() {
 if (gInterface.ShowInfoUser)
 {
	gInterface.frameCount++;
	if (GetTickCount() - gInterface.lastReport >= 1000)
	{
		gInterface.frameRate = gInterface.frameCount / ((GetTickCount() - gInterface.lastReport) / 1000);
		//sprintf(gInterface.FPS_REAL, "FPS: %d", gInterface.frameRate +40);
		gInterface.lastReport = GetTickCount();
		gInterface.frameCount = 0;
	}

	if ( this->CheckWindow(FullMap) || this->CheckWindow(FriendList) || this->CheckWindow(SkillTree) || this->CheckWindow(CashShop) )
	{
		return;
	}

	this->DrawFormat(eGold, 600, 15, 100, 1, 1, gInterface.FPS_REAL);
	gInterface.ShowInfoUser = true;
 }
 else
 {
	gInterface.ShowInfoUser = false;	
 }
}

/*void Interface::guiMonitore() {
 if (gInterface.ShowInfoUser)
 {
	if (this->CheckWindow(FullMap) || this->CheckWindow(FriendList) || this->CheckWindow(SkillTree) || this->CheckWindow(CashShop))
	{
		return;
	}
	pSetBlend(true);
	glColor4f((GLfloat)0.0, (GLfloat)0.0, (GLfloat)0.0, (float)0.8);
	//pDrawBarForm(460.0, 0.0, 180.0, 20.0, 0.0f, 0);
	//pDrawBarForm(220.0, 0.0, 450.0, 17.0, 0.0f, 0);
	pDrawBarForm(0.0, 0.0, 650.0, 16.0, 0.0f, 0);

	pGLSwitchBlend();
	pGLSwitch();
	glColor3f(1.0, 1.0, 1.0);
	pSetBlend(false);
	gInterface.ShowInfoUser = true;
 }
 else
 {
	gInterface.ShowInfoUser = false;	
 }
}*/

void Interface::DrawPing()
{
 if (gInterface.ShowInfoUser)
 {
	gInterface.msPing = GetTickCount() - gInterface.lastSend;
	gInterface.iniciador = 3;
	gInterface.ShowInfoUser = true;
 }
 else
 {
	gInterface.ShowInfoUser = false;	
 }
}

struct PMSG_PING
{
	PBMSG_HEAD h;
};

void Interface::SendPingRecv()
{
 if (gInterface.ShowInfoUser)
 {
	if(gInterface.iniciador == 1)
	{
		PMSG_PING pMsgPing;
		pMsgPing.h.set(0xFE,sizeof(pMsgPing));
		gInterface.lastSend = GetTickCount();
		DataSend((BYTE*)&pMsgPing,sizeof(pMsgPing));
		gInterface.iniciador=2;
	}
	else if(gInterface.iniciador == 3)
	{
		if (GetTickCount() >= gInterface.lastSend + 1000){
			PMSG_PING pMsgPing;
			pMsgPing.h.set(0xFE,sizeof(pMsgPing));
			gInterface.lastSend = GetTickCount();
			DataSend((BYTE*)&pMsgPing,sizeof(pMsgPing));
			gInterface.iniciador=2;
		}
	}

	if (this->CheckWindow(FullMap) || this->CheckWindow(FriendList) || this->CheckWindow(SkillTree) || this->CheckWindow(CashShop))
	{
		return;
	}
	//sprintf(gInterface.ServerRTT, "RTT: %d ms", gInterface.msPing);
	sprintf(gInterface.ServerPing, "%d ping", (gInterface.msPing/2));
	// ----
	gInterface.validar=0;

	if(gInterface.msPing > 0){
		//----
		//this->DrawFormat(eShinyGreen1, 540, 5, 120, 1, 1, gInterface.ServerRTT);
		this->DrawFormat(eShinyGreen1, 610, 5, 120, 1, 1, gInterface.ServerPing);
		//--
		sprintf(gInterface.ultimoRTT, gInterface.ServerRTT);
		sprintf(gInterface.ultimoPing, gInterface.ServerPing);
		//--
		gInterface.ultimo_RTT = gInterface.msPing;
		gInterface.validar=1;
	}

	if(gInterface.validar==0)
	{
		if(gInterface.ultimo_RTT > 0)
		{
			//this->DrawFormat(eShinyGreen1, 540, 5, 120, 1, 1,gInterface.ultimoRTT);
			this->DrawFormat(eShinyGreen1, 610, 5, 120, 1, 1,gInterface.ultimoPing);
		}
		else
		{
			//this->DrawFormat(eShinyGreen1, 540, 5, 120, 1, 0,gInterface.ServerRTT);
			this->DrawFormat(eShinyGreen1, 610, 5, 120, 1, 0,gInterface.ServerPing);
		}
	}
	
	//this->DrawFormat(eWhite, 140, 5, 300, 1, 0,"【F11】EXP",gServerInfo.Experience,gServerInfo.NextExperience);

	if (gServerInfo.m_AutoExp == false)
	
	{
		this->DrawFormat(eWhite, 260, 5, 120, 1, 0,"【F6】렉");
	}
	else
	{

	this->DrawFormat(eBlue, 260, 5, 120, 1, 0,"【F6】");

	}

	if (gServerInfo.m_AutoGuildAttack == false)
	{
		this->DrawFormat(eWhite, 330, 5, 120, 1, 0,"【F7】길드○");
	}
	else
	{
		this->DrawFormat(eShinyGreen1, 330, 5, 120, 1, 0,"【F7】길드●");
	}

	if (gInterface.varTestCntrl == 0)
	{
		this->DrawFormat(eWhite, 400, 5, 120, 1, 0,"【F8】피케이○");
	}
	else
	{
		this->DrawFormat(eShinyGreen1, 400, 5, 120, 1, 0,"【F8】피케이●");
	}

	if (gServerInfo.m_AutoChange == false)
	{
		this->DrawFormat(eWhite, 470, 5, 120, 1, 0, "【F9】환전○");
	}
	else
	{
		this->DrawFormat(eShinyGreen1, 470, 5, 120, 1, 0, "【F9】환전●");
	}

	if (gServerInfo.m_jbank == false)
	{
		this->DrawFormat(eWhite, 540, 5, 120, 1, 0,"【F10】보석");
	}
	else
	{

	this->DrawFormat(eBlue, 540, 5, 120, 1, 0,"【F10】");

	}


	gInterface.ShowInfoUser = true;
 }
 else
 {
	gInterface.ShowInfoUser = false;	
 }
	
}

//선물
void Interface::DrawQuaMocRS()
{
	if (!this->Data[eQuaMocRSMain].OnShow)
	{
		return;
	}


//	float MainWidth			= 237.0;
//	float MainHeight		= 313.0;
//	float StartY			= 100.0;
//	float StartX			= (MAX_WIN_WIDTH / 2) - (MainWidth / 2);
	//
	//pDrawGUI(0x9328, 165, 55, 312, 292); //1
	//
	//DrawGUI(eQuaMocRSPanel,273,105);

	float MainWidth			= 230.0;
	float MainHeight		= 180.0;
	float StartBody			= 80.0;
	float StartY			= 80.0;
	float StartX			= (MAX_WIN_WIDTH / 2) - (MainWidth / 2) + 200;
	float MainCenter		= StartX + (MainWidth / 3);
	float ButtonX			= MainCenter - (float)(29.0 / 2);
	// ----
	this->DrawGUI(eMenu_MAIN, StartX, StartY + (float)2.0);
	this->DrawGUI(eMenu_TITLE, StartX, StartY);
	StartY = gInterface.DrawRepeatGUI(eCHANGINGCLASS_FRAME, StartX, StartY + (float)15.0, 16);
	this->DrawGUI(eMenu_FOOTER, StartX, StartY);
	gInterface.DrawGUI(eQuaMocRSNhan_CLOSE, StartX + MainWidth - gInterface.Data[eQuaMocRSNhan_CLOSE].Width, StartBody);

	this->DrawFormat(eGold, (int)StartX + 10, (int)StartBody + 20, 210, 3, 0,"레벨 보상");

	//DrawGUI(eICONQUAMOCRS,275,250);

	gInterface.DrawFormat(eWhite, 413, 140, 210, 3,0, "레벨보상은 해당 레벨달성시 받으실수 있습니다");
	gInterface.DrawFormat(eWhite, 413, 155, 210, 3,0, "[1000레벨, 1500레벨, 2000레벨, 2500레벨, 3000레벨] 보상지급");
	gInterface.DrawFormat(eRed, 413, 170, 210, 3,0, "＃각 캐릭터당 1회만 보상 받을수 있습니다＃");
	gInterface.DrawFormat(eBlue250, 413, 185, 210, 3,0, "＃스텟은 캐릭터로 저장 됩니다＃");

	gInterface.DrawFormat(eYellow, 413, 225, 210, 3,0, "1000레벨 보상: 스텟 +1000, 팬더펫 3일");
	gInterface.DrawFormat(eYellow, 413, 240, 210, 3,0, "1500레벨 보상: 스텟 +1000, 팬더변반 3일");
	gInterface.DrawFormat(eYellow, 413, 255, 210, 3,0, "2000레벨 보상: 스텟 +1500, 스켈펫 3일");
	gInterface.DrawFormat(eYellow, 413, 270, 210, 3,0, "2500레벨 보상: 스텟 +2000, 스켈변반 3일");
	gInterface.DrawFormat(eYellow, 413, 285, 210, 3,0, "3000레벨 보상: 스텟 +2500, 핑크팬더변반 3일");

	//this->DrawToolTip(245, 220, "메세지",0);
	//this->DrawToolTip(245, 235, "메세지",0);
	//this->DrawToolTip(245, 250, "메세지",0);
	//this->DrawToolTip(245, 265, "메세지",0);

	// ----
	if( this->IsWorkZone(eQuaMocRSNhan_CLOSE) )
	{
		DWORD Color = eGray100;
		// ----
		if( this->Data[eQuaMocRSNhan_CLOSE].OnClick )
		{
			Color = eGray150;
		}
		// ----
		this->DrawColoredGUI(eQuaMocRSNhan_CLOSE, this->Data[eQuaMocRSNhan_CLOSE].X, this->Data[eQuaMocRSNhan_CLOSE].Y, Color);
		this->DrawToolTip(this->Data[eQuaMocRSNhan_CLOSE].X + 5, this->Data[eQuaMocRSNhan_CLOSE].Y + 25, "닫기");
	}
	// ----

	if (gInterface.IsWorkZone(eQuaMocRSNhan))
	{
		if (gInterface.Data[eQuaMocRSNhan].OnClick)
		{
			gInterface.DrawButton(eQuaMocRSNhan, 464 ,306, 0, 30);
		}
		else
			gInterface.DrawButton(eQuaMocRSNhan, 464 ,306, 0, 90);

	}
	else
		gInterface.DrawButton(eQuaMocRSNhan, 464 ,306, 0, 0);
		gInterface.DrawFormat(eYellow, 466, 318, 108, 3, 0,"▶ 레벨달성 선물 받기 ◀");

}


//가위바위
void Interface::EventQuaMocRS_Main(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();

	if (!this->Data[eQuaMocRSMain].OnShow)
	{
		return;
	}

	if (this->IsWorkZone(eQuaMocRSNhan))
	{
		DWORD Delay = (CurrentTick - this->Data[eQuaMocRSNhan].EventTick);
		// ----
		if (Event == WM_LBUTTONDOWN)
		{
			this->Data[eQuaMocRSNhan].OnClick = true;
			return;
		}
		// ----
		this->Data[eQuaMocRSNhan].OnClick = false;
		this->Data[eQuaMocRSNhan].EventTick = GetTickCount();

		//Func
		UP_TUCHAN_REQ pMsg;
		pMsg.h.set(0xFD, 0x18, sizeof(pMsg));
		DataSend((BYTE*)&pMsg, pMsg.h.size);
	}

	if (this->IsWorkZone(eQuaMocRSNhan_CLOSE))
	{
		DWORD Delay = (CurrentTick - this->Data[eQuaMocRSNhan_CLOSE].EventTick);
		// ----
		if (Event == WM_LBUTTONDOWN)
		{
			this->Data[eQuaMocRSNhan_CLOSE].OnClick = true;
			return;
		}
		// ----
		this->Data[eQuaMocRSNhan_CLOSE].OnClick = false;
		this->Data[eQuaMocRSNhan_CLOSE].EventTick = GetTickCount();
		//Func
		gInterface.QuaMocRSStateclose();
	}
}


//가위바위
void Interface::DrawRPS()
{
 	//if(pCheckWindowNew(WindowID(_WearInventory))) //
	//{
	//	return;
	//}

	float MainWidth = 230.0;
	float MainHeight = 313.0;
	float StartY = 100.0;
	float StartX = (MAX_WIN_WIDTH / 2) - (MainWidth / 2);

	if(pCheckWindowNew(WindowID(_Trade))) //

	{
		//this->DrawGUI(eRock, StartX + 80, StartY + 85);
		//this->DrawGUI(ePaper, StartX + 120, StartY + 85);
		//this->DrawGUI(eScissors, StartX + 160, StartY + 85);

		//this->DrawGUI(eRock, StartX + 23, StartY + 40);
		//this->DrawGUI(ePaper, StartX + 23, StartY + 70);
		//this->DrawGUI(eScissors, StartX + 23, StartY + 100);


		this->DrawGUI(eRock, StartX + 55, StartY + 300);
		this->DrawGUI(ePaper, StartX + 95, StartY + 300);
		this->DrawGUI(eScissors, StartX + 135, StartY + 300);

		//gInterface.Data[eRock].Attribute = 0;
		//gInterface.Data[ePaper].Attribute = 0;
		//gInterface.Data[eScissors].Attribute = 0;

		if (this->IsWorkZone(eRock))
		{
			DWORD Color = eGray100;
			// ----
			if (this->Data[eRock].OnClick)
			{
				Color = eGray150;
			}
			// ----
			this->DrawColoredGUI(eRock, this->Data[eRock].X, this->Data[eRock].Y, Color);
		}
		if (this->IsWorkZone(ePaper))
		{
			DWORD Color = eGray100;
			// ----
			if (this->Data[ePaper].OnClick)
			{
				Color = eGray150;
			}
			// ----
			this->DrawColoredGUI(ePaper, this->Data[ePaper].X, this->Data[ePaper].Y, Color);
		}
		if (this->IsWorkZone(eScissors))
		{
			DWORD Color = eGray100;
			// ----
			if (this->Data[eScissors].OnClick)
			{
				Color = eGray150;
			}
			// ----
			this->DrawColoredGUI(eScissors, this->Data[eScissors].X, this->Data[eScissors].Y, Color);
		}
		if (this->Data[eRock].Attribute == 1)
		{
			DWORD Color = eYellow;
			gInterface.DrawColoredGUI(eRock, gInterface.Data[eRock].X, gInterface.Data[eRock].Y, Color);
		}
		if (this->Data[ePaper].Attribute == 1)
		{
			DWORD Color = eYellow;
			gInterface.DrawColoredGUI(ePaper, gInterface.Data[ePaper].X, gInterface.Data[ePaper].Y, Color);
		}
		if (this->Data[eScissors].Attribute == 1)
		{
			DWORD Color = eYellow;
			gInterface.DrawColoredGUI(eScissors, gInterface.Data[eScissors].X, gInterface.Data[eScissors].Y, Color);
		}
	}
}

void Interface::EventRPS_Main(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();

	if(!pCheckWindowNew(WindowID(_Trade))) //
	{
		return;
	}

	if (this->IsWorkZone(eRock))
	{
		DWORD Delay = (CurrentTick - this->Data[eRock].EventTick);
		// ----
		if (Event == WM_LBUTTONDOWN)
		{
			this->Data[eRock].OnClick = true;
			pSetCursorFocus = true;
			return;
		}
		// ----
		this->Data[eRock].OnClick = false;
		pSetCursorFocus = false;
		// ----
		if (Delay < 500)
		{
			return;
		}
		// ----
		this->Data[eRock].EventTick = GetTickCount();
		//Func
		RPSMode(1);
		//pDrawMessage("Ban chon bua",1);
		this->Data[eRock].Attribute = 1;
		this->Data[ePaper].Attribute = 0;
		this->Data[eScissors].Attribute = 0;
	}
	//
	else if (this->IsWorkZone(ePaper))
	{
		DWORD Delay = (CurrentTick - this->Data[ePaper].EventTick);
		// ----
		if (Event == WM_LBUTTONDOWN)
		{
			this->Data[ePaper].OnClick = true;
			pSetCursorFocus = true;
			return;
		}
		// ----
		this->Data[ePaper].OnClick = false;
		pSetCursorFocus = false;
		// ----
		if (Delay < 500)
		{
			return;
		}
		// ----
		this->Data[ePaper].EventTick = GetTickCount();
		//Func
		RPSMode(2);
		//pDrawMessage("Ban chon bao",1);
		this->Data[eRock].Attribute = 0;
		this->Data[ePaper].Attribute = 1;
		this->Data[eScissors].Attribute = 0;
	}
	//
	else if (this->IsWorkZone(eScissors))
	{
		DWORD Delay = (CurrentTick - this->Data[eScissors].EventTick);
		// ----
		if (Event == WM_LBUTTONDOWN)
		{
			this->Data[eScissors].OnClick = true;
			pSetCursorFocus = true;
			return;
		}
		// ----
		this->Data[eScissors].OnClick = false;
		pSetCursorFocus = false;
		// ----
		if (Delay < 500)
		{
			return;
		}
		// ----
		this->Data[eScissors].EventTick = GetTickCount();
		//Func
		this->Data[eRock].Attribute = 0;
		this->Data[ePaper].Attribute = 0;
		this->Data[eScissors].Attribute = 1;
		RPSMode(3);
		//pDrawMessage("Ban chon keo",1);
	}
}


void Interface::DrawCameraButton()
{

	if(pCheckWindowNew(WindowID(_MoveCommand))) //
	{
		return;
	}

	if (this->Data[eCAMERA].OnShow)
	{
		this->Data[eCAMERA].OnShow = false;
	}


	float StartX = 24;
	float StartY = 455;

	if (IsWorkZone(eCAMERA))
	{
		this->DrawToolTip(StartX+2, StartY-14, "3D카메라 [ON/OFF]");

		if (this->Data[eCAMERA].OnClick)
		{
			this->Data[eCAMERA].OnShow = true;

			return;
		}
		pSetBlend(true);
		this->DrawButtonGUI(eCAMERA, StartX, StartY, 13.0,15.0,1.0, 1.0,1,1,0.0);
		//this->DrawToolTip(StartX+2, 102, "3D카메라 [켜짐]");

	}
	else
	{	
		pSetBlend(true);
		this->DrawButtonGUI(eCAMERA, StartX, StartY, 14.0,16.0,1.0, 1.0,1,1,0.0);
		//this->DrawToolTip(StartX+2, 102, "3D카메라 [꺼짐]");

	}

	this->Data[eCAMERA].OnShow = true;
}



bool Interface::EventDrawCamera(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eCAMERA].EventTick);
	// ----
	if (!this->Data[eCAMERA].OnShow || !IsWorkZone(eCAMERA))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		pSetCursorFocus = true;
		this->Data[eCAMERA].OnClick = true;
		return true;
	}
	// ----
		pSetCursorFocus = false;
	this->Data[eCAMERA].OnClick = false;
	// ----
	if (Delay < 500)
	{
		return false;
	}
	
	// ----
	this->Data[eCAMERA].EventTick = GetTickCount();
	
	gCamera.Toggle();
	// ----
	return false;
}


void Interface::DrawCameraResetButton()
{

	if(pCheckWindowNew(WindowID(_MoveCommand)))
	{
		return;
	}

	if (this->Data[eCAMERA_RESET].OnShow)
	{
		this->Data[eCAMERA_RESET].OnShow = false;
	}


	float StartX = 44;
	float StartY = 455;
	
	if (IsWorkZone(eCAMERA_RESET))
	{
		this->DrawToolTip(StartX+2, StartY-14, "3D카메라 [RESET]");

		if (this->Data[eCAMERA_RESET].OnClick)
		{
			this->Data[eCAMERA_RESET].OnShow = true;
			return;
		}
		pSetBlend(true);
		this->DrawButtonGUI(eCAMERA_RESET, StartX, StartY, 13.0,15.0,1.0, 1.0,1,1,0.0);
	}
	else
	{	
		pSetBlend(true);
		this->DrawButtonGUI(eCAMERA_RESET, StartX, StartY, 14.0,16.0,1.0, 1.0,1,1,0.0);
	}

	this->Data[eCAMERA_RESET].OnShow = true;
}


bool Interface::EventDrawCameraReset(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - this->Data[eCAMERA_RESET].EventTick);
	// ----
	if (!this->Data[eCAMERA_RESET].OnShow || !IsWorkZone(eCAMERA_RESET))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		pSetCursorFocus = true;
		this->Data[eCAMERA_RESET].OnClick = true;
		return true;
	}
	// ----
	pSetCursorFocus = false;
	this->Data[eCAMERA_RESET].OnClick = false;
	// ----
	if (Delay < 500)
	{
		return false;
	}
	
	// ----
	this->Data[eCAMERA_RESET].EventTick = GetTickCount();
	
	gCamera.Restore();

	// ----
	return false;
}

void Interface::SwitchShowInfoUser()
{
	if(gInterface.ShowInfoUser) 
	{
		gInterface.ShowInfoUser = false;
	}
    else
	{
		gInterface.ShowInfoUser = true;
	}
}


bool Interface::Antilagclose(DWORD Event)
{
	DWORD CurrentTick = GetTickCount();
	DWORD Delay = (CurrentTick - gInterface.Data[eJewelBank_CLOSE].EventTick);
	// ----
	if (!gInterface.Data[eOpMenu_MAINKG].OnShow || !gInterface.IsWorkZone(eMenu_CLOSE))
	{
		return false;
	}
	// ----
	if (Event == WM_LBUTTONDOWN)
	{
		gInterface.Data[eMenu_CLOSE].OnClick = true;
		return true;
	}
	// ----
	gInterface.Data[eMenu_CLOSE].OnClick = false;
	// ----
	if (Delay < 500)
	{
		return false;
	}
	// ----
	gInterface.Data[eMenu_CLOSE].EventTick = GetTickCount();
	gInterface.Data[eOpMenu_MAINKG].OnShow = false;
	pSetCursorFocus = false;
	// ----
	return false;
}


void Interface::DrawOpAntiLag()
{
    if (!this->Data[eOpMenu_MAINKG].OnShow)
    {
        return;
    }

    sub_62FBBB_Addr(0, 0, *(GLsizei*)MAIN_RESOLUTION_X + (GLsizei)1000, *(GLsizei*)MAIN_RESOLUTION_Y + (GLsizei)1000);
    sub_630E06_Addr();

    float MainWidth = 230.0;
    float MainHeight = 180.0;
    float StartBody = 80.0;
    float StartY = 80.0;
    float StartX = (MAX_WIN_WIDTH / 2) - (MainWidth / 2) + 200;
    float MainCenter = StartX + (MainWidth / 3);
    float ButtonX = MainCenter - (float)(29.0 / 2);

    this->DrawGUI(eOpMenu_MAINKG, StartX, StartY + (float)2.0);
    this->DrawGUI(eOpMenu_TITLEKG, StartX, StartY);
    StartY = this->DrawRepeatGUI(eCHANGINGCLASS_FRAME, StartX, StartY + (float)15.0, 18);

    this->DrawGUI(eMenu_FOOTER, StartX, StartY);
    this->DrawGUI(eMenu_CLOSE, StartX + MainWidth - this->Data[eVip_CLOSE].Width, StartBody);

    if (this->IsWorkZone(eMenu_CLOSE))
    {
        DWORD Color = eGray100;
        if (this->Data[eMenu_CLOSE].OnClick)
        {
            Color = eGray150;
        }
        this->DrawColoredGUI(eVip_CLOSE, this->Data[eMenu_CLOSE].X, StartBody, Color);
        this->DrawToolTip((int)this->Data[eMenu_CLOSE].X + 5, StartBody + 25, "창닫기 [F6]");
    }

    this->DrawFormat(eGold, (int)StartX + 10, (int)StartBody + 20, 210, 3, 1, "렉감소 시스템");

    float opLine, opStart, opSO, opTxt;
    opSO = ButtonX + 110;  // 체크박스 위치
    opStart = StartX + 35; // 옵션 시작점
    opLine = StartX + 35;  // 구분선 위치
    opTxt = StartX + 50;   // 텍스트 위치

    // ---- 이펙트 (EffectStatic)
    this->DrawGUI(eUSERSPANEL_STATICEFFECT, opSO, this->Data[eOpMenu_MAINKG].Y + 62);
    this->DrawGUI(eUSERSPANEL_OPTION, opStart, this->Data[eOpMenu_MAINKG].Y + 63);
    this->DrawFormat(eGold, opTxt, this->Data[eOpMenu_MAINKG].Y + 65, 125, 1, 0, "이펙트");
    if (DisableEffectStatic == 1)
    {
        this->DrawGUI(eCheck, opSO, this->Data[eOpMenu_MAINKG].Y + 62); // 체크된 상태
    }
    else
    {
        this->DrawGUI(eUnCheck, opSO, this->Data[eOpMenu_MAINKG].Y + 62); // 체크 안 된 상태
    }

    // ---- 맵 객체 (DisableObject)
    this->DrawGUI(eUSERSPANEL_DISABLEOBJECT, opSO, this->Data[eOpMenu_MAINKG].Y + 82);
    this->DrawGUI(eUSERSPANEL_OPTION, opStart, this->Data[eOpMenu_MAINKG].Y + 83);
    this->DrawFormat(eGold, opTxt, this->Data[eOpMenu_MAINKG].Y + 85, 145, 1, 0, "맵");
    if (DisableObject == 1)
    {
        this->DrawGUI(eCheck, opSO, this->Data[eOpMenu_MAINKG].Y + 82);
    }
    else
    {
        this->DrawGUI(eUnCheck, opSO, this->Data[eOpMenu_MAINKG].Y + 82);
    }

    // ---- 날개 (DisableWings)
    this->DrawGUI(eUSERSPANEL_DISABLEWINGS, opSO, this->Data[eOpMenu_MAINKG].Y + 102);
    this->DrawGUI(eUSERSPANEL_OPTION, opStart, this->Data[eOpMenu_MAINKG].Y + 103);
    this->DrawFormat(eGold, opTxt, this->Data[eOpMenu_MAINKG].Y + 105, 165, 1, 0, "날개");
    if (Disablewings == 1)
    {
        this->DrawGUI(eCheck, opSO, this->Data[eOpMenu_MAINKG].Y + 102);
    }
    else
    {
        this->DrawGUI(eUnCheck, opSO, this->Data[eOpMenu_MAINKG].Y + 102);
    }

    // ---- 스킬 (DisableSkill)
    this->DrawGUI(eUSERSPANEL_DISABLESKILL, opSO, this->Data[eOpMenu_MAINKG].Y + 122);
    this->DrawGUI(eUSERSPANEL_OPTION, opStart, this->Data[eOpMenu_MAINKG].Y + 123);
    this->DrawFormat(eGold, opTxt, this->Data[eOpMenu_MAINKG].Y + 125, 185, 1, 0, "스킬");
    if (Disableskill == 1)
    {
        this->DrawGUI(eCheck, opSO, this->Data[eOpMenu_MAINKG].Y + 122);
    }
    else
    {
        this->DrawGUI(eUnCheck, opSO, this->Data[eOpMenu_MAINKG].Y + 122);
    }
}



bool Interface::EventUsersPanelAntiLag_EFFECTSTATIC(DWORD Event)
{
	DWORD CurrentTick	= GetTickCount();
	DWORD Delay			= (CurrentTick - this->Data[eUSERSPANEL_STATICEFFECT].EventTick);
	// ----
	if( !this->Data[eOpMenu_MAINKG].OnShow || !IsWorkZone(eUSERSPANEL_STATICEFFECT) )
	{
		return false;
	}
	// ----
	if( Event == WM_LBUTTONDOWN )
	{
		this->Data[eUSERSPANEL_STATICEFFECT].OnClick = true;
		pSetCursorFocus = true;
		return true;
	}
	// ----
	this->Data[eUSERSPANEL_STATICEFFECT].OnClick = false;
	pSetCursorFocus = true;
	// ----
	if( Delay < 500 )
	{
		return false;
	}
	// ----
	this->Data[eUSERSPANEL_STATICEFFECT].EventTick = GetTickCount();
	if (DisableEffectStatic!=0)
	{
	    SetByte(0x00786D35,0x55); //Static
        SetByte(0x0075CCB9,0x55); //Dynamic
		DisableEffectStatic = 0;
	}
    else
	{
		SetByte(0x00786D35,0xC3); //Static
        SetByte(0x0075CCB9,0xC3); //Dynamic
	  
		DisableEffectStatic = 1;
	}
	return true;
}

bool Interface::EventUsersPanelAntiLag_OBJECT(DWORD Event)
{
	DWORD CurrentTick	= GetTickCount();
	DWORD Delay			= (CurrentTick - this->Data[eUSERSPANEL_DISABLEOBJECT].EventTick);
	// ----
	if( !this->Data[eOpMenu_MAINKG].OnShow || !IsWorkZone(eUSERSPANEL_DISABLEOBJECT) )
	{
		return false;
	}
	// ----
	if( Event == WM_LBUTTONDOWN )
	{
		this->Data[eUSERSPANEL_DISABLEOBJECT].OnClick = true;
		pSetCursorFocus = true;
		return true;
	}
	// ----
	this->Data[eUSERSPANEL_DISABLEOBJECT].OnClick = false;
	pSetCursorFocus = true;
	// ----
	if( Delay < 500 )
	{
		return false;
	}
	// ----
	this->Data[eUSERSPANEL_DISABLEOBJECT].EventTick = GetTickCount();
	if (DisableObject!=0)
	{
	   SetByte(0x005D2B21+6,0); //Objetos
		DisableObject = 0;
	}
    else
	{
	   SetByte(0x005D2B21+6,1); //Objetos
		DisableObject = 1;
	}
	return true;
}

bool Interface::EventUsersPanelAntiLag_WINGS(DWORD Event)
{
	DWORD CurrentTick	= GetTickCount();
	DWORD Delay			= (CurrentTick - this->Data[eUSERSPANEL_DISABLEWINGS].EventTick);
	// ----
	if( !this->Data[eOpMenu_MAINKG].OnShow || !IsWorkZone(eUSERSPANEL_DISABLEWINGS) )
	{
		return false;
	}
	// ----
	if( Event == WM_LBUTTONDOWN )
	{
		this->Data[eUSERSPANEL_DISABLEWINGS].OnClick = true;
		pSetCursorFocus = true;
		return true;
	}
	// ----
	this->Data[eUSERSPANEL_DISABLEWINGS].OnClick = false;
	pSetCursorFocus = true;
	// ----
	if( Delay < 500 )
	{
		return false;
	}
	// ----
	this->Data[eUSERSPANEL_DISABLEWINGS].EventTick = GetTickCount();
	if (Disablewings!=0)
	{
	    SetOp((LPVOID)0x005927EC,(LPVOID)0x0056B799,ASM::CALL); //Wings and Capes
        SetByte(0x00528D0D,0x55); //Wings and Capes
        SetByte(0x00528E44,0x55); //Wings and Capes
		Disablewings = 0;
	}
    else
	{
	   MemorySet(0x005927EC,0x90,0x5); //Wings and Capes
        SetByte(0x00528D0D,0xC3); //Wings and Capes
        SetByte(0x00528E44,0xC3); //Wings and Capes
		Disablewings = 1;
	}
	return true;
}

bool Interface::EventUsersPanelAntiLag_SKILL(DWORD Event)
{
	DWORD CurrentTick	= GetTickCount();
	DWORD Delay			= (CurrentTick - this->Data[eUSERSPANEL_DISABLESKILL].EventTick);
	// ----
	if( !this->Data[eOpMenu_MAINKG].OnShow || !IsWorkZone(eUSERSPANEL_DISABLESKILL) )
	{
		return false;
	}
	// ----
	if( Event == WM_LBUTTONDOWN )
	{
		this->Data[eUSERSPANEL_DISABLESKILL].OnClick = true;
		pSetCursorFocus = true;
		return true;
	}
	// ----
	this->Data[eUSERSPANEL_DISABLESKILL].OnClick = false;
	pSetCursorFocus = true;
	// ----
	if( Delay < 500 )
	{
		return false;
	}
	// ----
	this->Data[eUSERSPANEL_DISABLESKILL].EventTick = GetTickCount();
	if (Disableskill!=0)
	{
	    SetByte(0x0061DE55,0x55); //Skill
        SetByte(0x0073C1AE,0x55); //Skill
		Disableskill = 0;
	}
    else
	{
		SetByte(0x0061DE55,0xC3); //Skill
        SetByte(0x0073C1AE,0xC3); //Skill
		Disableskill = 1;
	}
	return true;
}






#define sub_6363D0_Addr ((void(__cdecl*)(GLint x, int a2, GLsizei width, GLsizei height)) 0x6363D0) //  62FB2C

#define sub_6358A0_Addr ((int(__cdecl*)(float a1, float a2, float a3, float a4)) 0x6358A0) // 62EF4E

#define sub_635830_Addr ((void(__cdecl*)(LPVOID a1)) 0x635830) // 62EEF1


#define sub_635DE0_Addr ((void(*)()) 0x635DE0) // 635DE0
#define sub_635E40_Addr ((void(*)()) 0x635E40)  // 62F5AF
#define sub_637770_Addr ((void(*)()) 0x637770) // 62F5F3

#define sub_6359B0_Addr ((int(__cdecl*)(int a1, int a2, int a3, char a4)) 0x006359B0)

#define sub_5CA0D0_Addr		((void(__cdecl*)(signed int a1, signed int a2, int a3, int a4, int a5, int a6, char a7)) 0x786D35) // funcion 9
#define sub_636720_Addr ((int(*)())0x636720) // 62FE3A



void Interface::DrawItem(float PosX, float PosY, float Width, float Height, int ItemID, int Level, int Excl, int Anc, bool OnMouse)
{

	/*
	if (this->CheckWindow(ObjWindow::MoveList) || this->CheckWindow(ObjWindow::CashShop) || this->CheckWindow(ObjWindow::SkillTree) || this->CheckWindow(ObjWindow::FullMap)
		|| (this->CheckWindow(Inventory)
			&& this->CheckWindow(ExpandInventory)
			&& this->CheckWindow(Store))
		|| (this->CheckWindow(Inventory)
			&& this->CheckWindow(Warehouse)
			&& this->CheckWindow(ExpandWarehouse)))
	{
		return;
	}

	pSetBlend(true);
	glMatrixMode(0x1701);
	glPushMatrix();
	glLoadIdentity();
	// 
	sub_6363D0_Addr(0, 0, *(GLsizei*)MAIN_RESOLUTION_X, *(GLsizei*)MAIN_RESOLUTION_Y);

	float v2 = *(float*)MAIN_RESOLUTION_X / *(float*)MAIN_RESOLUTION_Y;

	if (ItemID == 406)
	{
		sub_6358A0_Addr(0.4, v2, *(float*)0xE61E38, *(float*)0xE61E3C); //tamanho do bmd
	}
	else if (ItemID == 407)
	{
		sub_6358A0_Addr(0.5, v2, *(float*)0xE61E38, *(float*)0xE61E3C); //tamanho do bmd
	}
	else
	{
		sub_6358A0_Addr(0.7, v2, *(float*)0xE61E38, *(float*)0xE61E3C); //tamanho do bmd
	}

	glMatrixMode(0x1700);
	glPushMatrix();
	glLoadIdentity();

	sub_635830_Addr((LPVOID)0x87933A0);
	sub_635DE0_Addr();
	sub_635E40_Addr();

	//posX 
	//posY
	//Width
	//Height
	//unk
	// 1 - Excellent Effect
	// 1 - Aura +7
	// 1 - original size
	glClear(0x100);

	//pDrawItemModel(PosX, PosY, Width, Height, ItemID, Level, Excl, Anc, OnMouse);

	 // int v31 = pTest((double)PosY);
	  //int v32 = pTest((double)PosX);

	VAngle v45;

	unsigned __int8 v44 = 1; //0 = parado / 1 = girando
	*/
	//sub_6359B0_Addr(PosX, PosY, (int)&v45, 0); //posi豫o do bmd
	/*
	sub_636720_Addr();

	glMatrixMode(0x1700);
	glPopMatrix();
	glMatrixMode(0x1701);
	glPopMatrix();

	sub_637770_Addr();

	glColor3f(1, 1, 1);

	*/
	pSetBlend(false);
}

void Interface::DrawText(DWORD Color, int PosX, int PosY, int Width, int Align, LPCSTR Text, ...) // OK
{
	char Buff[2048];
	const int BuffLen = sizeof(Buff) - 1;
	ZeroMemory(Buff, BuffLen);

	va_list args;
	va_start(args, Text);
	vsprintf_s(Buff, BuffLen, Text, args);
	va_end(args);

	char * Line = strtok(Buff, "\n");

	while (Line != nullptr)
	{
		DrawInterfaceText(Line, PosX, PosY, Width, 0, Color, 0, Align);
		PosY += 10;
		Line = strtok(NULL, "\n");
	}
}

bool Interface::IsWorkZone2(float X, float Y, float MaxX, float MaxY)
{
	if ((gObjUser.m_CursorX < X || gObjUser.m_CursorX > MaxX)
		|| (gObjUser.m_CursorY < Y || gObjUser.m_CursorY > MaxY))
	{
		return false;
	}
	// ----
	return true;
}


////////////////////////////////////////////////////////////////


//////////////////////////////PROTOCOL.H
// Protect.h: interface for the CProtect class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "CustomBuyVip.h"
#include "CustomCommandInfo.h"
#include "CustomEventTime.h"
#include "CustomGloves.h"
#include "CustomFog.h"
#include "CustomItem.h"
#include "CustomItemDescription.h"
#include "CustomJewel.h"
#include "CustomMessage.h"
#include "CustomMonster.h"
#include "CustomNpcName.h"
#include "CustomWing.h"
#include "ItemSmoke.h"
#include "StaticEffect.h"
#include "DynamicEffect.h"
#include "ModelEffect.h"

struct MAIN_FILE_INFO
{
	BYTE LauncherType; 
	char LauncherName[32];
	char CustomerName[32];
	char IpAddress[32];
	WORD IpAddressPort;
	WORD gMaxGameInstances;
	char ClientVersion[8];
	char ClientSerial[17];
	char WindowName[32];
	char ScreenShotPath[50];
	char ClientName[32];
	char PluginName1[32];
	char PluginName2[32];
	char PluginName3[32];
	char PluginName4[32];
	char PluginName5[32];
	char CameraName[32];
	DWORD ClientCRC32;
	DWORD Plugin1CRC32;
	DWORD Plugin2CRC32;
	DWORD Plugin3CRC32;
	DWORD Plugin4CRC32;
	DWORD Plugin5CRC32;
	DWORD CameraCRC32;
	DWORD HelperActiveAlert;
	DWORD HelperActiveLevel;
	DWORD DWMaxAttackSpeed;
	DWORD DKMaxAttackSpeed;
	DWORD FEMaxAttackSpeed;
	DWORD MGMaxAttackSpeed;
	DWORD DLMaxAttackSpeed;
	DWORD SUMaxAttackSpeed;
	DWORD RFMaxAttackSpeed;
	DWORD ReconnectTime;
	DWORD FpsLimit;
	DWORD ItemLevel_15;
	DWORD Mainchek;
	DWORD ReduceMemory;
	DWORD RemoveClass;
	DWORD RankUserType;
	DWORD DisableTree; 
	DWORD CsSkill; 
	DWORD DisableReflectEffect;
	DWORD EnableVipShop;
	DWORD VipTypes;
	DWORD PrintLogo;
	DWORD CustomMenuSwitch;
	DWORD CustomMenuType;
	DWORD EnableEventTimeButton;
	DWORD EnableVipShopButton;
	DWORD EnableRankingButton;
	DWORD EnableCommandButton;
	DWORD EnableOptionButton;
	DWORD EnableCoinStatus;
	DWORD EnableShopValueSystem;
	DWORD CustomStoreEnableJoB;
	DWORD CustomStoreEnableJoS;
	DWORD CustomStoreEnableJoC;
	DWORD CustomStoreEnableCoin1;
	DWORD CustomStoreEnableCoin2;
	DWORD CustomStoreEnableCoin3;
	DWORD CustomOffStoreEnable;
	DWORD CustomMonsterEnable;
	DWORD DisablePartyHpBar;
	DWORD RankUserShowOverHead;
	DWORD RankUserOnlyOnSafeZone;
	DWORD RankUserShowReset;
	DWORD RankUserShowMasterReset;
	DWORD RankUserNeedAltKey;
	CUSTOM_MESSAGE_INFO EngCustomMessageInfo[MAX_CUSTOM_MESSAGE];
	CUSTOM_MESSAGE_INFO PorCustomMessageInfo[MAX_CUSTOM_MESSAGE];
	CUSTOM_MESSAGE_INFO SpnCustomMessageInfo[MAX_CUSTOM_MESSAGE];
	CUSTOM_JEWEL_INFO CustomJewelInfo[MAX_CUSTOM_JEWEL];
	CUSTOM_WING_INFO CustomWingInfo[MAX_CUSTOM_WING];
	CUSTOM_ITEM_INFO CustomItemInfo[MAX_CUSTOM_ITEM];
	CUSTOM_WING_EFFECT_INFO CustomWingEffectInfo[MAX_CUSTOM_WING_EFFECT];
	DYNAMIC_WING_EFFECT_INFO DynamicWingEffectInfo[MAX_DYNAMIC_WING_EFFECT];
	CUSTOM_BUYVIP_INFO CustomBuyVipInfo[MAX_CUSTOM_BUYVIP];
	CUSTOM_COMMAND_INFO CustomCommandInfo[MAX_CUSTOM_COMMAND];
	CUSTOM_EVENT_INFO CustomEventInfo[MAX_EVENTTIME];
	CUSTOM_DESCRIPTION_INFO CustomDescriptionInfo[MAX_CUSTOM_DESCRIPTION];
	CUSTOM_SMOKEEFFECT CustomSmokeEffect[MAX_SMOKE_ITEMS];
	CUSTOM_FOG CustomFog[MAX_FOG];
	CUSTOMMONSTER_DATA CustomMonsters[MAX_CUSTOMMONSTER];
	NPCNAME_DATA CustomNPCName[MAX_CUSTOM_NPCNAME];
	CUSTOM_RF_GLOVES CustomGloves[MAX_CUSTOM_GLOVES];
	//CUSTOM_MODEL_EFFECT_INFO ModelEffectInfo[MAX_MODEL_EFFECT]; //model effect
};

class CProtect
{
public:
	CProtect();
	virtual ~CProtect();
	bool ReadMainFile(char* name);
	void CheckLauncher();
	void CheckInstance();
	void CheckClientFile();
	void CheckPlugin1File();
	void CheckPlugin2File();
	void CheckPlugin3File();
	void CheckPlugin4File();
	void CheckPlugin5File();
	void CheckCameraFile();
	bool IsProcessRunning(const char *ProcessName, int maxProcess);
public:
	MAIN_FILE_INFO m_MainInfo;
	DWORD m_ClientFileCRC;
};

extern CProtect gProtect;


////////////////////////////// PROTOCOL.CPP
#include "stdafx.h"
#include "Protocol.h"
#include "Common.h"
#include "CustomEventTime.h"
#include "CustomRanking.h"
#include "CustomRankUser.h"
#include "Interface.h"
#include "Import.h"
#include "ItemShopValue.h"
#include "Offset.h"
#include "PacketManager.h"
#include "PrintPlayer.h"
#include "Protect.h"
#include "Reconnect.h"
#include "Util.h"
#include "HpBar.h"
#include "Smithy.h"
#include "ChangeClass.h"
#include "ServerInfo.h"
#include "Achievements.h"
#include "LuckyWheel.h"
#include "User.h"
#include "CustomJewelBank.h"
#include "RageSystem.h"
#include "CustomComboEffect.h"

BOOL ProtocolCoreEx(BYTE head,BYTE* lpMsg,int size,int key) // OK
{
	BYTE ProtocolType = lpMsg[0];

	switch(head)
	{
		case 0x11:
			GCDamageRecv((PMSG_DAMAGE_RECV*)lpMsg);
			break;
		case 0x16:
			GCMonsterDieRecv((PMSG_MONSTER_DIE_RECV*)lpMsg);
			break;
		case 0x17:
			GCUserDieRecv((PMSG_USER_DIE_RECV*)lpMsg);
			break;
		case 0x26:
			GCLifeRecv((PMSG_LIFE_RECV*)lpMsg);
			break;
		case 0x27:
			GCManaRecv((PMSG_MANA_RECV*)lpMsg);
			break;
		case 0x2C:
			GCFruitResultRecv((PMSG_FRUIT_RESULT_RECV*)lpMsg);
			break;
		case 0x9C:
			GCRewardExperienceRecv((PMSG_REWARD_EXPERIENCE_RECV*)lpMsg);
			break;
		case 0xA3:
			GCQuestRewardRecv((PMSG_QUEST_REWARD_RECV*)lpMsg);
			break;
		case 0xB1:
			switch(((lpMsg[0]==0xC1)?lpMsg[3]:lpMsg[4]))
			{
				case 0x00:
					GCMapServerMoveRecv((PMSG_MAP_SERVER_MOVE_RECV*)lpMsg);
					break;
				case 0x01:
					GCMapServerMoveAuthRecv((PMSG_MAP_SERVER_MOVE_AUTH_RECV*)lpMsg);
					break;
			}
			break;
		case 0xD8:
			GCElementalDamageRecv((PMSG_ELEMENTAL_DAMAGE_RECV*)lpMsg);
			break;
		case 0xEC:
			switch(((lpMsg[0]==0xC1)?lpMsg[3]:lpMsg[4]))
			{
				case 0x30:
					GCCharacterAttackSpeedRecv((PMSG_CHARACTER_ATTACK_SPEED_RECV*)lpMsg);
					break;
			}
			break;
		case 0xF1:
			switch(((lpMsg[0]==0xC1)?lpMsg[3]:lpMsg[4]))
			{
				case 0x00:
					GCConnectClientRecv((PMSG_CONNECT_CLIENT_RECV*)lpMsg);
					break;
				case 0x01:
					GCConnectAccountRecv((PMSG_CONNECT_ACCOUNT_RECV*)lpMsg);
					break;
				case 0x02:
					GCCloseClientRecv((PMSG_CLOSE_CLIENT_RECV*)lpMsg);
					break;
			}
			break;
		case 0xF3:
			switch(((lpMsg[0]==0xC1)?lpMsg[3]:lpMsg[4]))
			{
				case 0x00:
					GCCharacterListRecv((PMSG_CHARACTER_LIST_RECV*)lpMsg);
					break;
				case 0x03:
					GCCharacterInfoRecv((PMSG_CHARACTER_INFO_RECV*)lpMsg);
					break;
				case 0x04:
					GCCharacterRegenRecv((PMSG_CHARACTER_REGEN_RECV*)lpMsg);
					break;
				case 0x05:
					GCLevelUpRecv((PMSG_LEVEL_UP_RECV*)lpMsg);
					break;
				case 0x06:
					GCLevelUpPointRecv((PMSG_LEVEL_UP_POINT_RECV*)lpMsg);
					break;
				case 0x07:
					GCMonsterDamageRecv((PMSG_MONSTER_DAMAGE_RECV*)lpMsg);
					break;
				case 0x50:
					GCMasterInfoRecv((PMSG_MASTER_INFO_RECV*)lpMsg);
					break;
				case 0x51:
					GCMasterLevelUpRecv((PMSG_MASTER_LEVEL_UP_RECV*)lpMsg);
					break;
				case 0xE0:
					GCNewCharacterInfoRecv((PMSG_NEW_CHARACTER_INFO_RECV*)lpMsg);
					return 1;
				case 0xE1:
					GCNewCharacterCalcRecv((PMSG_NEW_CHARACTER_CALC_RECV*)lpMsg);
					return 1;
				case 0xE2:
					GCNewHealthBarRecv((PMSG_NEW_HEALTH_BAR_RECV*)lpMsg);
					return 1;
				case 0xE3:
					GCNewGensBattleInfoRecv((PMSG_NEW_GENS_BATTLE_INFO_RECV*)lpMsg);
					return 1;
				case 0xE4:
					GCNewMessageRecv((PMSG_NEW_MESSAGE_RECV*)lpMsg);
					return 1;
				case 0xE5:
					gCustomRankUser.GCReqRankLevelUser((PMSG_CUSTOM_RANKUSER*)lpMsg);
					return 1;
				case 0xE6:
					gCustomRanking.GCReqRanking((PMSG_CUSTOM_RANKING_RECV*)lpMsg);
					return 1;
				case 0xE7:
					gCustomRanking.GCReqRankingCount((PMSG_CUSTOM_RANKING_COUNT_RECV*)lpMsg);
					return 1;
				case 0xE8:
					gCustomEventTime.GCReqEventTime((PMSG_CUSTOM_EVENTTIME_RECV*)lpMsg);
					return 1;
				case 0xE9:
					gItemPrice.GCItemValueRecv((PMSG_ITEM_VALUE_RECV*)lpMsg);
					return 1;
				case 0xEA:
					GCRecvCoin((PMSG_COIN_RECV*)lpMsg);
					return 1;
				//case 0xEB:
				//	gOffTrade.RecvPShop((PMSG_OFFTRADE_RECV*)lpMsg);
				//	return 1;
				//case 0xEC:
				//	gOffTrade.PShopActiveRecv((PMSG_SHOPACTIVE_RECV*)lpMsg);
				//	return 1;
				case 0xED:
					GCBuyConfirmRecv((PMSG_ITEM_BUY_RECV*)lpMsg);
					break;
				case 0xF5:
					gCustomJewelBank.GCCustomJewelBankInfoRecv((PSBMSG_JEWELBANK_RECV*)lpMsg);
					return 1;
			}
			break;

			case 0xFB:
				switch(((lpMsg[0]==0xC1)?lpMsg[3]:lpMsg[4]))
				{

				case 0x00:
					gRageSystem.GCExpRecv(lpMsg);
					break;
				case 0x01:
					gRageSystem.GCSkillRecv(lpMsg);
					break;

	

					//case 0x06://뱅크
					//	GCBankExCreditsRecv((PMSG_BANKEX_UPDATE_RECV*)lpMsg);
					//break;

					/*case 0x00:
						gUserPanel.GetUserPanel((USERPANEL_REQ*)lpMsg);
						break;
					case 0x01:
						gDiablo.Recv((DIABLO_REQ*)lpMsg);
						break;
					case 0x02:
						gDiablo.RenaRecv((DIABLO_RENARECV*)lpMsg);
						break;
					case 0x03:
						GCDonateShopInfoRecv((PMSG_DONATESHOP_INFO*)lpMsg);
						break;
					case 0x04:
						GCDonateShopStateRecv((PMSG_DONATESHOP_STATE*)lpMsg);
						break;
					case 0x05:
						GCDonateShopPageRecv((PMSG_DONATESHOP_SETPAGE_RECV*)lpMsg);
						break;
					case 0x06:
						GCBankExCreditsRecv((PMSG_BANKEX_UPDATE_RECV*)lpMsg);
						break;
					case 0x07:
						gOffTrade.RecvCustomStoreNames((PMSG_CUSTOMSTORE_RECV*)lpMsg);
						break;*/
					case 0x08:
						gChangeClass.RecvData((PMSG_CHANGECLASS_DATA*)lpMsg);
						break;
					/*case 0x09:
						gBuyVip.RecvData((PMSG_BUYAL_DATA*)lpMsg);
						break;
					case 0x0A:
						gResetSystem.SetData((RESET_ANS_USERDATA*)lpMsg);
						break;
					case 0x0B:
						gResetSystem.GetResetResult();
						break;
					case 0x0C:
						gInterface.Data[eTELEPORTPANEL_MAIN].Open();
						break;
					case 0x0D:
						GCWarehouseInterfaceOpenRecv((PMSG_WAREHOUSEINTERFACE_RECV*)lpMsg);
						break;
					case 0x0E:
						gGRSystem.SetData((GR_ANS_USERDATA*)lpMsg);
						break;
					case 0x0F:
						gGRSystem.GetResetResult();
						break; */
					case 0x10:
						gServerInfo.RecvServerInfo((PMSG_SERVERINFO_RECV*)lpMsg);
						break;
					/*case 0x11:
						GCSetCharacterPage((PMSG_CHARACTERPAGE_RECV*)lpMsg);
						break;
					case 0x12:
						gPartySearchSettings.GCPartySettingsRecv((PMSG_PARTYSETTINGS_RECV*)lpMsg);
						break;
					case 0x13:
						g_BuffIcon.GC_BuffInfo((PMSG_SEND_BUFF_ICON_EX*)lpMsg);
						break; */
					//case 0x14:
					//	gSmithy.GCSettingsRecv((GC_SmithySettings*)lpMsg);
					//	break;
					//case 0x15:
					//	gSmithy.GCItemInit((GC_SmithyInit*)lpMsg);
					//	break;
					//case 0x16:
					//	gSmithy.GCItemSend((GC_SmithyDATA*)lpMsg);
					//	break;
					/*case 0x17:
						gPackSystem.SwitchPackSystemWindowState();
						break;
					case 0x18:
						gPackSystem.GC_ResultRecv((CG_MIX_RESULT_SEND*)lpMsg);
						break;*/
			case 0x0C:
				gAchievements.GCPlayerData((PMSG_GC_ACH_PLAYER_DATA*)lpMsg);
				return 1;
			case 0x0D:
				gAchievements.GCCalculatorPower((PMSG_GC_ACH_POWER*)lpMsg);
				return 1;
			case 0x0F:
				gAchievements.GCConfigData((PMSG_GC_ACH_SETTINGS_DATA*)lpMsg);
				return 1;
			case 0x22:
				UpdateRPSMode();
				break;
			case 0x25:
				gLuckySpin.LuckySpinData((GC_LuckySpinUpdateData*)lpMsg);
				break;
			case 0x26:
				LuckySpinRoll();
				break;
			case 0x33:
				gLuckySpin.GCItemSend((GC_LuckySpin_Data*)lpMsg);
				break;
			case 0x34:
				gLuckySpin.GCLuckySpinInit((GC_LuckySpinInit*)lpMsg);
				break;

				}
				break;

				case 0xFE:
					gInterface.DrawPing();
				break;

	}

/*
if (ProtocolType == 0xC2)
	{
		switch(head)
		{
			case 0x3F:
			{

				switch(((lpMsg[0]==0xC1)?lpMsg[3]:lpMsg[4]))
				{
					//case 0x01:
					//g_PersonalShopEx.GC_ResultPrice((PMSG_ANS_PSHOP_SETITEMPRICE*) lpMsg);
					//break;

						//case 0xF1:
						//	GCPetCharSetRecv((PMSG_NEW_PET_CHARSET_RECV*)lpMsg);
						//	break;
						//case 0xF2:
						//	GCPetCharSetSelectCharacterRecv((PMSG_NEW_SELECT_CHARACTER_CHARSET_RECV*)lpMsg);
						//	break;
				}

				//gOffTrade.RecvPShop((PMSG_PSHOP_ITEM_LIST_SEND*)lpMsg);

			}
			break;
			case 0xF3:
				switch(((lpMsg[0]==0xC1)?lpMsg[3]:lpMsg[4]))
				{
					//case 0xE2:
					//	GCNewHealthBarRecv((PMSG_NEW_HEALTH_BAR_RECV*)lpMsg);
					//	break;
					//case 0xF0:
					//	GCPartyListRecv((PMSG_RECV_PARTYLIST*)lpMsg);
					//	break;
					//case 0xF1:
					//	GCDonateItemsRecv((PMSG_RECV_DONATEITEMS*)lpMsg);
					//	break;
					//case 0xF2:
					//	gCharacterList.SetList((PMSG_CHARACTER_INFO_DATA*)lpMsg);
					//	break;
					case 0xF3:
						GCSmithyAncRecv((PMSG_SMITHY_ANCIENT_RECV*)lpMsg);
						break;
					case 0xF4:
						GCSmithySocketRecv((PMSG_SMITHY_SOCKET_RECV*)lpMsg);
						break;
					//case 0xF5:
					//	GCPackSystemDataRecv((PMSG_RECV_PACKSYSTEM*)lpMsg);
					//	break;
				}
				break;

		}
	}*/

	return ProtocolCore(head,lpMsg,size,key);
}

void GCDamageRecv(PMSG_DAMAGE_RECV* lpMsg) // OK
{
	int aIndex = MAKE_NUMBERW(lpMsg->index[0],lpMsg->index[1]) & 0x7FFF;

	if(ViewIndex == aIndex)
	{
		ViewCurHP = lpMsg->ViewCurHP;
		ViewCurSD = lpMsg->ViewCurSD;
	}

	ViewDamageHP = lpMsg->ViewDamageHP;
	ViewDamageSD = lpMsg->ViewDamageSD;

	if((MAKE_NUMBERW(lpMsg->type[0],lpMsg->type[1]) & 0x10) != 0)
	{
		if(ViewDamageCount < 3)
		{
			ViewDamageTable[ViewDamageCount++] = lpMsg->ViewDamageHP;
			ViewDamageValue = ViewDamageCount;
		}
	}

	if((MAKE_NUMBERW(lpMsg->type[0],lpMsg->type[1]) & 0x20) != 0)
	{
		if(ViewDamageCount < 4)
		{
			ViewDamageTable[ViewDamageCount++] = lpMsg->ViewDamageHP;
			ViewDamageValue = ViewDamageCount;
		}
	}
}

void GCMonsterDieRecv(PMSG_MONSTER_DIE_RECV* lpMsg) // OK
{
	ViewDamageHP = lpMsg->ViewDamageHP;
}

void GCUserDieRecv(PMSG_USER_DIE_RECV* lpMsg) // OK
{
	int aIndex = MAKE_NUMBERW(lpMsg->index[0],lpMsg->index[1]) & 0x7FFF;

	if(ViewIndex == aIndex)
	{
		ViewCurHP = 0;
	}
}

void GCLifeRecv(PMSG_LIFE_RECV* lpMsg) // OK
{
	if(lpMsg->type == 0xFE)
	{
		ViewMaxHP = lpMsg->ViewHP;
		ViewMaxSD = lpMsg->ViewSD;
	}

	if(lpMsg->type == 0xFF)
	{
		ViewCurHP = ((ViewCurHP==0)?ViewCurHP:lpMsg->ViewHP);
		ViewCurSD = lpMsg->ViewSD;
	}
}

void GCManaRecv(PMSG_MANA_RECV* lpMsg) // OK
{
	if(lpMsg->type == 0xFE)
	{
		ViewMaxMP = lpMsg->ViewMP;
		ViewMaxBP = lpMsg->ViewBP;
	}

	if(lpMsg->type == 0xFF)
	{
		ViewCurMP = lpMsg->ViewMP;
		ViewCurBP = lpMsg->ViewBP;
	}
}

void GCFruitResultRecv(PMSG_FRUIT_RESULT_RECV* lpMsg) // OK
{
	if(lpMsg->result == 0 || lpMsg->result == 3 || lpMsg->result == 6 || lpMsg->result == 17)
	{
		ViewValue = lpMsg->ViewValue;
		ViewPoint = lpMsg->ViewPoint;
		ViewStrength = lpMsg->ViewStrength;
		ViewDexterity = lpMsg->ViewDexterity;
		ViewVitality = lpMsg->ViewVitality;
		ViewEnergy = lpMsg->ViewEnergy;
		ViewLeadership = lpMsg->ViewLeadership;
	}
}

void GCRewardExperienceRecv(PMSG_REWARD_EXPERIENCE_RECV* lpMsg) // OK
{
	ViewDamageHP = lpMsg->ViewDamageHP;
}

void GCQuestRewardRecv(PMSG_QUEST_REWARD_RECV* lpMsg) // OK
{
	int aIndex = MAKE_NUMBERW(lpMsg->index[0],lpMsg->index[1]) & 0x7FFF;

	if(ViewIndex == aIndex)
	{
		ViewPoint = lpMsg->ViewPoint;
	}
}

void GCMapServerMoveRecv(PMSG_MAP_SERVER_MOVE_RECV* lpMsg) // OK
{
	ReconnectOnMapServerMove(lpMsg->IpAddress,lpMsg->ServerPort);
}

void GCMapServerMoveAuthRecv(PMSG_MAP_SERVER_MOVE_AUTH_RECV* lpMsg) // OK
{
	ReconnectOnMapServerMoveAuth(lpMsg->result);
}

void GCElementalDamageRecv(PMSG_ELEMENTAL_DAMAGE_RECV* lpMsg) // OK
{
	int aIndex = MAKE_NUMBERW(lpMsg->index[0],lpMsg->index[1]) & 0x7FFF;

	if(ViewIndex == aIndex)
	{
		ViewCurHP = lpMsg->ViewCurHP;
		ViewCurSD = lpMsg->ViewCurSD;
	}
}

// 스피드
void GCCharacterAttackSpeedRecv(PMSG_CHARACTER_ATTACK_SPEED_RECV* lpMsg) // OK
{
	lpMsg->PhysiSpeed = ((lpMsg->PhysiSpeed>((WORD)(&gProtect.m_MainInfo.DWMaxAttackSpeed)[(*(BYTE*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x0B) & 7)]))?((WORD)(&gProtect.m_MainInfo.DWMaxAttackSpeed)[(*(BYTE*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x0B) & 7)]):lpMsg->PhysiSpeed);

	lpMsg->MagicSpeed = ((lpMsg->MagicSpeed>((WORD)(&gProtect.m_MainInfo.DWMaxAttackSpeed)[(*(BYTE*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x0B) & 7)]))?((WORD)(&gProtect.m_MainInfo.DWMaxAttackSpeed)[(*(BYTE*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x0B) & 7)]):lpMsg->MagicSpeed);

}

void GCConnectClientRecv(PMSG_CONNECT_CLIENT_RECV* lpMsg) // OK
{
	//gHwid.SendHwid();
	ViewIndex = MAKE_NUMBERW(lpMsg->index[0],lpMsg->index[1]);
}

void GCConnectAccountRecv(PMSG_CONNECT_ACCOUNT_RECV* lpMsg) // OK
{
	ReconnectOnConnectAccount(lpMsg->result);
}

void GCCloseClientRecv(PMSG_CLOSE_CLIENT_RECV* lpMsg) // OK
{
	ReconnectOnCloseClient(lpMsg->result);
}

void GCCharacterListRecv(PMSG_CHARACTER_LIST_RECV* lpMsg) // OK
{
	ReconnectOnCharacterList();
}

void GCCharacterInfoRecv(PMSG_CHARACTER_INFO_RECV* lpMsg) // OK
{
	ReconnectOnCharacterInfo();
	
	ViewReset = lpMsg->ViewReset;
	ViewPoint = lpMsg->ViewPoint;
	ViewCurHP = lpMsg->ViewCurHP;
	ViewMaxHP = lpMsg->ViewMaxHP;
	ViewCurMP = lpMsg->ViewCurMP;
	ViewMaxMP = lpMsg->ViewMaxMP;
	ViewCurBP = lpMsg->ViewCurBP;
	ViewMaxBP = lpMsg->ViewMaxBP;
	ViewCurSD = lpMsg->ViewCurSD;
	ViewMaxSD = lpMsg->ViewMaxSD;
	ViewStrength = lpMsg->ViewStrength;
	ViewDexterity = lpMsg->ViewDexterity;
	ViewVitality = lpMsg->ViewVitality;
	ViewEnergy = lpMsg->ViewEnergy;
	ViewLeadership = lpMsg->ViewLeadership;

	*(WORD*)(*(DWORD*)(MAIN_VIEWPORT_STRUCT)+0x07E) = 0;

	*(BYTE*)(*(DWORD*)(MAIN_VIEWPORT_STRUCT)+0x328) = 0;

	switch(((*(BYTE*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x0B)) & 7))
	{
		case 0:
			SetByte(0x0055B6A2,((gProtect.m_MainInfo.DWMaxAttackSpeed>=0xFFFF)?0x02:0x0F));
			break;
		case 1:
			SetByte(0x0055B6A2,((gProtect.m_MainInfo.DKMaxAttackSpeed>=0xFFFF)?0x0F:0x0F));
			break;
		case 2:
			SetByte(0x0055B6A2,((gProtect.m_MainInfo.FEMaxAttackSpeed>=0xFFFF)?0x02:0x0F));
			break;
		case 3:
			SetByte(0x0055B6A2,((gProtect.m_MainInfo.MGMaxAttackSpeed>=0xFFFF)?0x02:0x0F));
			break;
		case 4:
			SetByte(0x0055B6A2,((gProtect.m_MainInfo.DLMaxAttackSpeed>=0xFFFF)?0x02:0x0F));
			break;
		case 5:
			SetByte(0x0055B6A2,((gProtect.m_MainInfo.SUMaxAttackSpeed>=0xFFFF)?0x02:0x0F));
			break;
		case 6:
			SetByte(0x0055B6A2,((gProtect.m_MainInfo.RFMaxAttackSpeed>=0xFFFF)?0x0F:0x0F));
			break; 
	}
}

void GCCharacterRegenRecv(PMSG_CHARACTER_REGEN_RECV* lpMsg) // OK
{
	ViewCurHP = lpMsg->ViewCurHP;
	ViewCurMP = lpMsg->ViewCurMP;
	ViewCurBP = lpMsg->ViewCurBP;
	ViewCurSD = lpMsg->ViewCurSD;
}

void GCLevelUpRecv(PMSG_LEVEL_UP_RECV* lpMsg) // OK
{
	ViewPoint = lpMsg->ViewPoint;
	ViewMaxHP = lpMsg->ViewMaxHP;
	ViewMaxMP = lpMsg->ViewMaxMP;
	ViewMaxBP = lpMsg->ViewMaxBP;
	ViewMaxSD = lpMsg->ViewMaxSD;
	ViewExperience = lpMsg->ViewExperience;
	ViewNextExperience = lpMsg->ViewNextExperience;
}

void GCLevelUpPointRecv(PMSG_LEVEL_UP_POINT_RECV* lpMsg) // OK
{
	if(lpMsg->result >= 16 && lpMsg->result <= 20)
	{
		ViewPoint = lpMsg->ViewPoint;
		ViewMaxHP = lpMsg->ViewMaxHP;
		ViewMaxMP = lpMsg->ViewMaxMP;
		ViewMaxBP = lpMsg->ViewMaxBP;
		ViewMaxSD = lpMsg->ViewMaxSD;
		ViewStrength = lpMsg->ViewStrength;
		ViewDexterity = lpMsg->ViewDexterity;
		ViewVitality = lpMsg->ViewVitality;
		ViewEnergy = lpMsg->ViewEnergy;
		ViewLeadership = lpMsg->ViewLeadership;
	}
}

void GCMonsterDamageRecv(PMSG_MONSTER_DAMAGE_RECV* lpMsg) // OK
{
	ViewCurHP = lpMsg->ViewCurHP;
	ViewCurSD = lpMsg->ViewCurSD;
	ViewDamageHP = lpMsg->ViewDamageHP;
	ViewDamageSD = lpMsg->ViewDamageSD;
}

void GCMasterInfoRecv(PMSG_MASTER_INFO_RECV* lpMsg) // OK
{
	ViewMaxHP = lpMsg->ViewMaxHP;
	ViewMaxMP = lpMsg->ViewMaxMP;
	ViewMaxBP = lpMsg->ViewMaxBP;
	ViewMaxSD = lpMsg->ViewMaxSD;
}

void GCMasterLevelUpRecv(PMSG_MASTER_LEVEL_UP_RECV* lpMsg) // OK
{
	ViewMaxHP = lpMsg->ViewMaxHP;
	ViewMaxMP = lpMsg->ViewMaxMP;
	ViewMaxBP = lpMsg->ViewMaxBP;
	ViewMaxSD = lpMsg->ViewMaxSD;
	ViewMasterExperience = lpMsg->ViewMasterExperience;
	ViewMasterNextExperience = lpMsg->ViewMasterNextExperience;
}

void GCNewCharacterInfoRecv(PMSG_NEW_CHARACTER_INFO_RECV* lpMsg) // OK
{

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x0E) = lpMsg->Level;

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x74) = lpMsg->LevelUpPoint;

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x18) = lpMsg->Strength;

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x1A) = lpMsg->Dexterity;

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x1C) = lpMsg->Vitality;

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x1E) = lpMsg->Energy;

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x20) = lpMsg->Leadership;

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x22) = lpMsg->Life;

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x26) = lpMsg->MaxLife;

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x24) = lpMsg->Mana;

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x28) = lpMsg->MaxMana;

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x40) = lpMsg->BP;

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x42) = lpMsg->MaxBP;

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x2A) = lpMsg->Shield;

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x2C) = lpMsg->MaxShield;

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x4C) = lpMsg->FruitAddPoint;

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x4E) = lpMsg->MaxFruitAddPoint;

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x50) = lpMsg->FruitSubPoint;

	*(WORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x52) = lpMsg->MaxFruitSubPoint;
	//경험치
	*(DWORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x10) = lpMsg->Experience;
	*(DWORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x14) = lpMsg->NextExperience;

	*(DWORD*)(*(DWORD*)(MAIN_CHARACTER_STRUCT)+0x14) = lpMsg->NextExperience;

	//*(QWORD*)(*(QWORD*)(MAIN_CHARACTER_STRUCT)+0x10) = lpMsg->Experience;
	//*(QWORD*)(*(QWORD*)(MAIN_CHARACTER_STRUCT)+0x14) = lpMsg->NextExperience;


	//EXTRA
	ViewReset = lpMsg->ViewReset;
	ViewPoint = lpMsg->ViewPoint;
	ViewCurHP = lpMsg->ViewCurHP;
	ViewMaxHP = lpMsg->ViewMaxHP;
	ViewCurMP = lpMsg->ViewCurMP;
	ViewMaxMP = lpMsg->ViewMaxMP;
	ViewCurBP = lpMsg->ViewCurBP;
	ViewMaxBP = lpMsg->ViewMaxBP;
	ViewCurSD = lpMsg->ViewCurSD;
	ViewMaxSD = lpMsg->ViewMaxSD;
	ViewStrength = lpMsg->ViewStrength;
	ViewDexterity = lpMsg->ViewDexterity;
	ViewVitality = lpMsg->ViewVitality;
	ViewEnergy = lpMsg->ViewEnergy;
	ViewLeadership = lpMsg->ViewLeadership;
}

// sub_59DC73

void GCNewCharacterCalcRecv(PMSG_NEW_CHARACTER_CALC_RECV* lpMsg) // OK
{
	ViewCurHP = lpMsg->ViewCurHP;
	ViewMaxHP = lpMsg->ViewMaxHP;
	ViewCurMP = lpMsg->ViewCurMP;
	ViewMaxMP = lpMsg->ViewMaxMP;
	ViewCurBP = lpMsg->ViewCurBP;
	ViewMaxBP = lpMsg->ViewMaxBP;
	ViewCurSD = lpMsg->ViewCurSD;
	ViewMaxSD = lpMsg->ViewMaxSD;
	ViewAddStrength = lpMsg->ViewAddStrength;
	ViewAddDexterity = lpMsg->ViewAddDexterity;
	ViewAddVitality = lpMsg->ViewAddVitality;
	ViewAddEnergy = lpMsg->ViewAddEnergy;
	ViewAddLeadership = lpMsg->ViewAddLeadership;
	ViewPhysiDamageMin = lpMsg->ViewPhysiDamageMin;
	ViewPhysiDamageMax = lpMsg->ViewPhysiDamageMax;
	ViewMagicDamageMin = lpMsg->ViewMagicDamageMin;
	ViewMagicDamageMax = lpMsg->ViewMagicDamageMax;
	ViewCurseDamageMin = lpMsg->ViewCurseDamageMin;
	ViewCurseDamageMax = lpMsg->ViewCurseDamageMax;
	ViewMulPhysiDamage = lpMsg->ViewMulPhysiDamage;
	ViewDivPhysiDamage = lpMsg->ViewDivPhysiDamage;
	ViewMulMagicDamage = lpMsg->ViewMulMagicDamage;
	ViewDivMagicDamage = lpMsg->ViewDivMagicDamage;
	ViewMulCurseDamage = lpMsg->ViewMulCurseDamage;
	ViewDivCurseDamage = lpMsg->ViewDivCurseDamage;
	ViewMagicDamageRate = lpMsg->ViewMagicDamageRate;
	ViewCurseDamageRate = lpMsg->ViewCurseDamageRate;
	ViewPhysiSpeed = lpMsg->ViewPhysiSpeed;
	ViewMagicSpeed = lpMsg->ViewMagicSpeed;
	ViewAttackSuccessRate = lpMsg->ViewAttackSuccessRate;
	ViewAttackSuccessRatePvP = lpMsg->ViewAttackSuccessRatePvP;
	ViewDefense = lpMsg->ViewDefense;
	ViewDefenseSuccessRate = lpMsg->ViewDefenseSuccessRate;
	ViewDefenseSuccessRatePvP = lpMsg->ViewDefenseSuccessRatePvP;
	ViewDamageMultiplier = lpMsg->ViewDamageMultiplier;
	ViewRFDamageMultiplierA = lpMsg->ViewRFDamageMultiplierA;
	ViewRFDamageMultiplierB = lpMsg->ViewRFDamageMultiplierB;
	ViewRFDamageMultiplierC = lpMsg->ViewRFDamageMultiplierC;
	ViewDarkSpiritAttackDamageMin = lpMsg->ViewDarkSpiritAttackDamageMin;
	ViewDarkSpiritAttackDamageMax = lpMsg->ViewDarkSpiritAttackDamageMax;
	ViewDarkSpiritAttackSpeed = lpMsg->ViewDarkSpiritAttackSpeed;
	ViewDarkSpiritAttackSuccessRate = lpMsg->ViewDarkSpiritAttackSuccessRate;
}

void GCNewHealthBarRecv(PMSG_NEW_HEALTH_BAR_RECV* lpMsg) // OK
{
	ClearNewHealthBar();

	for(int n=0;n < lpMsg->count;n++)
	{
		PMSG_NEW_HEALTH_RECV* lpInfo = (PMSG_NEW_HEALTH_RECV*)(((BYTE*)lpMsg)+sizeof(PMSG_NEW_HEALTH_BAR_RECV)+(sizeof(PMSG_NEW_HEALTH_RECV)*n));

		InsertNewHealthBar(lpInfo->index,lpInfo->type,lpInfo->rate,lpInfo->rate2);
	}
}

void GCNewGensBattleInfoRecv(PMSG_NEW_GENS_BATTLE_INFO_RECV* lpMsg) // OK
{
	GensBattleMapCount = lpMsg->GensBattleMapCount;

	GensMoveIndexCount = lpMsg->GensMoveIndexCount;

	memcpy(GensBattleMap,lpMsg->GensBattleMap,sizeof(GensBattleMap));

	memcpy(GensMoveIndex,lpMsg->GensMoveIndex,sizeof(GensMoveIndex));
}

void GCNewMessageRecv(PMSG_NEW_MESSAGE_RECV* lpMsg) // OK
{
	wchar_t buffW[128];

	if(MultiByteToWideChar(CP_ACP,0,lpMsg->message,sizeof(lpMsg->message),buffW,_countof(buffW)) != 0)
	{
		char buffA[256];

		if(WideCharToMultiByte(CP_UTF8,0,buffW,_countof(buffW),buffA,sizeof(buffA),0,0) != 0)
		{
			DWORD value = ((DWORD(*)())0x00936AAC)();

			((void(*)(DWORD,char*,char*,char*,int))0x00927D4B)((*(DWORD*)(value+0x124)),"SetChatLogText","%s %d",buffA,2);
		}
	}
}

void DataSend(BYTE* lpMsg,DWORD size) // OK
{
	BYTE EncBuff[2048];

	if(gPacketManager.AddData(lpMsg,size) != 0 && gPacketManager.ExtractPacket(EncBuff) != 0)
	{
		BYTE send[2048];

		memcpy(send,EncBuff,size);

		if(EncBuff[0] == 0xC3 || EncBuff[0] == 0xC4)
		{
			if(EncBuff[0] == 0xC3)
			{
				BYTE save = EncBuff[1];

				EncBuff[1] = (*(BYTE*)(MAIN_PACKET_SERIAL))++;

				size = gPacketManager.Encrypt(&send[2],&EncBuff[1],(size-1))+2;

				EncBuff[1] = save;

				send[0] = 0xC3;
				send[1] = LOBYTE(size);
			}
			else
			{
				BYTE save = EncBuff[2];

				EncBuff[2] = (*(BYTE*)(MAIN_PACKET_SERIAL))++;

				size = gPacketManager.Encrypt(&send[3],&EncBuff[2],(size-2))+3;

				EncBuff[2] = save;

				send[0] = 0xC4;
				send[1] = HIBYTE(size);
				send[2] = LOBYTE(size);
			}
		}

		((void(__thiscall*)(void*,BYTE*,DWORD))0x00439764)((void*)0x08B15A70,send,size);
	}
}

void GCRecvCoin(PMSG_COIN_RECV* lpMsg) // OK
{
	Coin1 = lpMsg->Coin1;
	Coin2 = lpMsg->Coin2;
	Coin3 = lpMsg->Coin3;
}

void GCBuyConfirmRecv(PMSG_ITEM_BUY_RECV* lpMsg) // OK
{
	gInterface.Data[eCONFIRM_MAIN].OnShow = true;
	pSetCursorFocus = true;
	gInterface.ConfirmSlot = lpMsg->slot;
}

void GCSmithyAncRecv(PMSG_SMITHY_ANCIENT_RECV* lpMsg)
{
	//g_Console.AddMessage(5,"RecvAnc");
	gSmithy.ClearAncientList();

	for (int n=0;n<lpMsg->count;n++)
	{
		PMSG_SMITHY_ANCIENT* lpInfo = (PMSG_SMITHY_ANCIENT*)(((BYTE*)lpMsg)+sizeof(PMSG_SMITHY_ANCIENT_RECV)+(sizeof(PMSG_SMITHY_ANCIENT)*n));

		gSmithy.GCAncientRecv(lpInfo->index,lpInfo->options);
	}
}

void GCSmithySocketRecv(PMSG_SMITHY_SOCKET_RECV* lpMsg)
{
	gSmithy.ClearSocketList();

	for (int n=0;n<lpMsg->count;n++)
	{
		PMSG_SMITHY_SOCKET* lpInfo = (PMSG_SMITHY_SOCKET*)(((BYTE*)lpMsg)+sizeof(PMSG_SMITHY_SOCKET_RECV)+(sizeof(PMSG_SMITHY_SOCKET)*n));

		gSmithy.GCSocketRecv(lpInfo->index);
	}
}


void CGSendWarehouseOpen(int Number)
{
	PMSG_WAREHOUSEINTERFACE_SEND pMsg;
	pMsg.header.set(0xFF,0x0B,sizeof(pMsg));
	pMsg.Number = Number;
	DataSend((BYTE*)&pMsg,pMsg.header.size);
}

void CGShopOpen(int type)
{
	PMSG_SHOPINTERFACE_SEND pMsg;
	pMsg.header.set(0xFF,0x06,sizeof(pMsg));
	pMsg.Type = type;
	DataSend((BYTE*)&pMsg,pMsg.header.size);
}

void RPSMode(int Number)
{
	RPSMODE_REQ pMsg;
	pMsg.h.set(0xFD, 0x27, sizeof(pMsg));
	pMsg.Number = Number;
	DataSend((BYTE*)&pMsg, pMsg.h.size);
}

void UpdateRPSMode()
{
	gInterface.Data[eRock].Attribute = 0;
	gInterface.Data[ePaper].Attribute = 0;
	gInterface.Data[eScissors].Attribute = 0;
}

void LuckySpinRoll()
{
	gLuckySpin.StartRoll = 1;
}

void GCBankExCreditsRecv(PMSG_BANKEX_UPDATE_RECV* lpMsg)
{
	gObjUser.BankEx.Money = lpMsg->Money;
	gObjUser.BankEx.Bless = lpMsg->Bless;
	gObjUser.BankEx.Soul = lpMsg->Soul;
	gObjUser.BankEx.Chaos = lpMsg->Chaos;
	gObjUser.BankEx.Creation = lpMsg->Creation;
	gObjUser.BankEx.Life = lpMsg->Life;
	gObjUser.BankEx.Harmony = lpMsg->Harmony;
	gObjUser.m_MaxWarehouse = lpMsg->MaxWarehouse;
}





/////////////////////////////////////////////// (SERVER) PROTOCOL.H
// Protect.h: interface for the CProtect class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#define PROTECT_START _asm _emit 0xEB _asm _emit 0x0E _asm _emit 0x14 _asm _emit 0x28 _asm _emit 0xCD _asm _emit 0xDB _asm _emit 0x50 _asm _emit 0x63 _asm _emit 0xAF _asm _emit 0x22 _asm _emit 0x75 _asm _emit 0xEE _asm _emit 0xB5 _asm _emit 0xD8 _asm _emit 0x43 _asm _emit 0x72
#define PROTECT_FINAL _asm _emit 0xEB _asm _emit 0x0E _asm _emit 0x37 _asm _emit 0xF2 _asm _emit 0xCD _asm _emit 0xDB _asm _emit 0x50 _asm _emit 0x63 _asm _emit 0xAF _asm _emit 0x22 _asm _emit 0x75 _asm _emit 0xEE _asm _emit 0xB5 _asm _emit 0xD8 _asm _emit 0x85 _asm _emit 0x61
#define CRASH_APPLICATION_MACRO _asm _emit 0xFF _asm _emit 0x25 _asm _emit 0x00 _asm _emit 0x00 _asm _emit 0x00 _asm _emit 0x00

enum eAuthServerType
{
	AUTH_SERVER_TYPE_NONE = 0,
	AUTH_SERVER_TYPE_S6_CONNECT_SERVER = 1,
	AUTH_SERVER_TYPE_S6_JOIN_SERVER = 2,
	AUTH_SERVER_TYPE_S6_DATA_SERVER = 3,
	AUTH_SERVER_TYPE_S6_GAME_SERVER = 4,
	AUTH_SERVER_TYPE_S8_CONNECT_SERVER = 5,
	AUTH_SERVER_TYPE_S8_JOIN_SERVER = 6,
	AUTH_SERVER_TYPE_S8_DATA_SERVER = 7,
	AUTH_SERVER_TYPE_S8_GAME_SERVER = 8,
	AUTH_SERVER_TYPE_S4_CONNECT_SERVER = 9,
	AUTH_SERVER_TYPE_S4_JOIN_SERVER = 10,
	AUTH_SERVER_TYPE_S4_DATA_SERVER = 11,
	AUTH_SERVER_TYPE_S4_GAME_SERVER = 12,
	AUTH_SERVER_TYPE_S2_CONNECT_SERVER = 13,
	AUTH_SERVER_TYPE_S2_JOIN_SERVER = 14,
	AUTH_SERVER_TYPE_S2_DATA_SERVER = 15,
	AUTH_SERVER_TYPE_S2_GAME_SERVER = 16,
};

enum eAuthServerStatus
{
	AUTH_SERVER_STATUS_NONE = 0,
	AUTH_SERVER_STATUS_SUCCESS = 1,
};

struct SDHP_AUTH_SERVER_DATA_RECV
{
	BYTE type; // C1:00
	BYTE size;
	BYTE head;
	BYTE EncKey;
	BYTE ServerType;
	BYTE Status;
	BYTE PackageType;
	BYTE PlanType;
	char CustomerName[32];
	char CustomerHardwareId[36];
};

struct SDHP_AUTH_SERVER_DATA_SEND
{
	BYTE type; // C1:00
	BYTE size;
	BYTE head;
	BYTE EncKey;
	BYTE ServerType;
	char CustomerName[32];
	char CustomerHardwareId[36];
};

class CProtect
{
public:
	CProtect();
	virtual ~CProtect();
	bool GetComputerHardwareId();
	bool ConnectToAuthServer(char* IpAddress,WORD port);
	bool AuthServerDataSend(eAuthServerType ServerType);
	void StartAuth(eAuthServerType ServerType);
	inline void ErrorMessageBox(int Erro);
	inline void SafeExitProcess();
	void ProtectBlock(DWORD size);
	void ReleaseBlock(DWORD size);
	void DecryptBlock(BYTE* data,int size);
	void EncryptBlock(BYTE* data,int size);
	inline void InsertMemoryMacro(BYTE* data,BYTE* info,int size);
	inline void RemoveMemoryMacro(BYTE* data,BYTE* info,int size);
	inline bool VerifyMemoryMacro(BYTE* data,BYTE* info,int size);
	bool GetInsertStartBlock(DWORD start_offset,DWORD final_offset,DWORD* start_block);
	bool GetInsertFinalBlock(DWORD start_offset,DWORD final_offset,DWORD* final_block);
	bool GetRemoveStartBlock(DWORD start_offset,DWORD final_offset,DWORD* start_block);
	bool GetRemoveFinalBlock(DWORD start_offset,DWORD final_offset,DWORD* final_block);
	char* GetEncryptedString(BYTE* string,int size);
public:
	SOCKET m_socket;
	char m_ComputerHardwareId[36];
	BYTE m_EncKey;
	BYTE m_EncKeyNew;
	SDHP_AUTH_SERVER_DATA_RECV m_AuthInfo;
};

extern CProtect gProtect;

static const BYTE gProtectTable[16] = {0xC8,0x9D,0x24,0xC2,0x10,0xDD,0xE1,0x66,0xF3,0x5D,0x35,0xD2,0xA8,0x96,0xC5,0x48};
static const BYTE gProtectInsertStart[16] = {0x74,0x91,0x8B,0xB7,0x52,0x44,0xCF,0xFC,0x30,0xBD,0xEA,0x71,0x2A,0x47,0xDC,0xED}; //{0xEB,0x0E,0x14,0x28,0xCD,0xDB,0x50,0x63,0xAF,0x22,0x75,0xEE,0xB5,0xD8,0x43,0x72}
static const BYTE gProtectInsertFinal[16] = {0x74,0x91,0xA8,0x6D,0x52,0x44,0xCF,0xFC,0x30,0xBD,0xEA,0x71,0x2A,0x47,0x1A,0xFE}; //{0xEB,0x0E,0x37,0xF2,0xCD,0xDB,0x50,0x63,0xAF,0x22,0x75,0xEE,0xB5,0xD8,0x85,0x61}
static const BYTE gProtectRemoveStart[16] = {0x5C,0x74,0x92,0xB7,0x52,0x44,0xCF,0xFC,0x30,0xBD,0xEA,0x71,0x2A,0x47,0xDC,0xED}; //{0xC3,0xEB,0x0D,0x28,0xCD,0xDB,0x50,0x63,0xAF,0x22,0x75,0xEE,0xB5,0xD8,0x43,0x72}
static const BYTE gProtectRemoveFinal[16] = {0x5C,0x74,0x92,0x6D,0x52,0x44,0xCF,0xFC,0x30,0xBD,0xEA,0x71,0x2A,0x47,0x1A,0xFE}; //{0xC3,0xEB,0x0D,0xF2,0xCD,0xDB,0x50,0x63,0xAF,0x22,0x75,0xEE,0xB5,0xD8,0x85,0x61}
static BYTE gProtectString1[04] = {0xF3,0x8A,0xEC,0xB0}; //"C:\\"
static BYTE gProtectString2[20] = {0x95,0x80,0x88,0xE8,0x9D,0x95,0x80,0x88,0xE8,0x9D,0x95,0x80,0x88,0xE8,0x9D,0x95,0x80,0x88,0xE8,0xB0}; //"%08X-%08X-%08X-%08X"
static BYTE gProtectString3[12] = {0x81,0x82,0x87,0x9E,0x80,0x9E,0x80,0x9E,0x80,0x81,0xB0}; //"127.0.0.1"
static BYTE gProtectString4[35] = {0xF3,0xDF,0xC5,0xDC,0xD4,0x90,0xDE,0xDF,0xC4,0x90,0xD1,0xC5,0xC4,0xD8,0xD5,0xDE,0xC4,0xD9,0xD3,0xD1,0xC4,0xD5,0x90,0xC4,0xD8,0xD5,0x90,0xDD,0xD1,0xD3,0xD8,0xD9,0xDE,0xD5,0xB0}; //"Could not authenticate the machine"
static BYTE gProtectString5[06] = {0xF5,0xC2,0xC2,0xDF,0xC2,0xB0}; //"Error"


////////////////////////////////// (SERVER) PROTOCOL.CPP
#include "stdafx.h"
#include "Protocol.h"
#include "ArcaBattle.h"
#include "Attack.h"
#include "BloodCastle.h"
#include "CashShop.h"
#include "CastleSiege.h"
#include "CastleSiegeSync.h"
#include "CastleSiegeWeapon.h"
#include "ChaosBox.h"
#include "ChaosCastle.h"
#include "CommandManager.h"
#include "CustomBuyVip.h"
#include "CustomCommandDescription.h"
#include "CustomEventTime.h"
#include "CustomMove.h"
#include "CustomStore.h"
#include "CustomRanking.h"
#include "Crywolf.h"
#include "CSProtocol.h"
#include "DarkSpirit.h"
#include "DefaultClassInfo.h"
#include "DevilSquare.h"
#include "DoubleGoer.h"
#include "DSProtocol.h"
#include "Duel.h"
#include "EffectManager.h"
#include "ESProtocol.h"
#include "EventInventory.h"
#include "Filter.h"
#include "Fruit.h"
#include "GensSystem.h"
#include "Guild.h"
#include "GuildClass.h"
#include "GuildMatching.h"
#include "HackPacketCheck.h"
#include "Helper.h"
#include "IllusionTemple.h"
#include "ImperialGuardian.h"
#include "InventoryEquipment.h"
#include "ItemManager.h"
#include "JewelMix.h"
#include "JSProtocol.h"
#include "KanturuEntranceNPC.h"
#include "Log.h"
#include "LuckyCoin.h"
#include "Map.h"
#include "MapServerManager.h"
#include "MasterSkillTree.h"
#include "Message.h"
#include "MiniMap.h"
#include "MiningSystem.h"
#include "Move.h"
#include "MuRummy.h"
#include "MuunSystem.h"
#include "Notice.h"
#include "NpcTalk.h"
#include "ObjectManager.h"
#include "Party.h"
#include "PartyMatching.h"
#include "PcPoint.h"
#include "PentagramSystem.h"
#include "PersonalShop.h"
#include "Protect.h"
#include "Quest.h"
#include "QuestWorld.h"
#include "ServerInfo.h"
#include "SkillManager.h"
#include "Trade.h"
#include "Util.h"
#include "Viewport.h"
#include "Warehouse.h"
#include "MapServerManager.h"
#include "DSProtocol.h"
#include "JSProtocol.h"
#include "GameMain.h"
#include "Smithy.h"
#include "ChangeClass.h"
#include "ShopManager.h"
#include "ProhibitedSymbols.h"
#include "LuckyWheel.h"
#include "QuaMocReset.h"
#include "FakeOnline.h"
#include "OfflineMode.h"
#include "CustomJewelBank.h"
#include "RageSystem.h"

void ProtocolCore(BYTE head,BYTE* lpMsg,int size,int aIndex,int encrypt,int serial) // OK PROTOCOL CORE
{
	PROTECT_START

	if (gObj[aIndex].Type == OBJECT_USER &&lpMsg[0] == 0xC1 && head == 0xFB)
	{
		switch (lpMsg[3])
		{
		case 0x00:
			gSystemOfRage.SkillLvlUp(lpMsg, aIndex);
			break;

		case 0x3D:
		{
			g_OfflineMode.Start((CG_OFFMODE_RESULT*)lpMsg, aIndex);
		}
		break;
		}

	}

	if(gObj[aIndex].Type == OBJECT_USER && gHackPacketCheck.CheckPacketHack(aIndex,head,((lpMsg[0]==0xC1)?lpMsg[3]:lpMsg[4]),encrypt,serial) == 0)
	{
		return;
	}

	LPOBJ lpObj = &gObj[aIndex];

	//LogAdd(LOG_BLACK,"PROTO head: %x, 1: %x, 2: %x, 3: %x, 4: %x, 5: %x",head,lpMsg[1],lpMsg[2],lpMsg[3],lpMsg[4],lpMsg[5]);

	switch(head)
	{
		case 0x00:
			CGChatRecv((PMSG_CHAT_RECV*)lpMsg,aIndex);
			break;
		case 0x02:
			CGChatWhisperRecv((PMSG_CHAT_WHISPER_RECV*)lpMsg,aIndex);
			break;
		case 0x03:
			CGMainCheckRecv((PMSG_MAIN_CHECK_RECV*)lpMsg,aIndex);
			break;
		case 0x0E:
			CGLiveClientRecv((PMSG_LIVE_CLIENT_RECV*)lpMsg,aIndex);
			break;
		case PROTOCOL_CODE2:
			gAttack.CGAttackRecv((PMSG_ATTACK_RECV*)lpMsg,aIndex);
			break;
		case PROTOCOL_CODE3:
			CGPositionRecv((PMSG_POSITION_RECV*)lpMsg,aIndex);
			break;
		case 0x18:
			CGActionRecv((PMSG_ACTION_RECV*)lpMsg,aIndex);
			break;
		case 0x19:
			gSkillManager.CGSkillAttackRecv((PMSG_SKILL_ATTACK_RECV*)lpMsg,aIndex);
			break;
		case 0x1B:
			gSkillManager.CGSkillCancelRecv((PMSG_SKILL_CANCEL_RECV*)lpMsg,aIndex);
			break;
		case 0x1C:
			gMove.CGTeleportRecv((PMSG_TELEPORT_RECV*)lpMsg,aIndex);
			break;
		case 0x1E:
			gSkillManager.CGDurationSkillAttackRecv((PMSG_DURATION_SKILL_ATTACK_RECV*)lpMsg,aIndex);
			break;
		case 0x22:
			gItemManager.CGItemGetRecv((PMSG_ITEM_GET_RECV*)lpMsg,aIndex);
			break;
		case 0x23:
			gItemManager.CGItemDropRecv((PMSG_ITEM_DROP_RECV*)lpMsg,aIndex);
			break;
		case 0x24:
			gItemManager.CGItemMoveRecv((PMSG_ITEM_MOVE_RECV*)lpMsg,aIndex);
			break;
		case 0x26:
			gItemManager.CGItemUseRecv((PMSG_ITEM_USE_RECV*)lpMsg,aIndex);
			break;
		case 0x30:
			gNpcTalk.CGNpcTalkRecv((PMSG_NPC_TALK_RECV*)lpMsg,aIndex);
			break;
		case 0x31:
			gNpcTalk.CGNpcTalkCloseRecv(aIndex);
			break;
		case 0x32:
			gItemManager.CGItemBuyRecv((PMSG_ITEM_BUY_RECV*)lpMsg,aIndex,0);
			break;
		case 0x33:
			gItemManager.CGItemSellRecv((PMSG_ITEM_SELL_RECV*)lpMsg,aIndex);
			break;
		case 0x34:
			gItemManager.CGItemRepairRecv((PMSG_ITEM_REPAIR_RECV*)lpMsg,aIndex);
			break;
		case 0x36:
			gTrade.CGTradeRequestRecv((PMSG_TRADE_REQUEST_RECV*)lpMsg,aIndex);
			break;
		case 0x37:
			gTrade.CGTradeResponseRecv((PMSG_TRADE_RESPONSE_RECV*)lpMsg,aIndex);
			break;
		case 0x3A:
			gTrade.CGTradeMoneyRecv((PMSG_TRADE_MONEY_RECV*)lpMsg,aIndex);
			break;
		case 0x3C:
			gTrade.CGTradeOkButtonRecv((PMSG_TRADE_OK_BUTTON_RECV*)lpMsg,aIndex);
			break;
		case 0x3D:
			gTrade.CGTradeCancelButtonRecv(aIndex);
			break;
		case 0x3F:
			switch(lpMsg[3])
			{
				case 0x01:
					gPersonalShop.CGPShopSetItemPriceRecv((PMSG_PSHOP_SET_ITEM_PRICE_RECV*)lpMsg,aIndex);
					break;
				case 0x02:
					gPersonalShop.CGPShopOpenRecv((PMSG_PSHOP_OPEN_RECV*)lpMsg,aIndex);
					break;
				case 0x03:
					gPersonalShop.CGPShopCloseRecv(aIndex);
					break;
				case 0x05:
					gPersonalShop.CGPShopItemListRecv((PMSG_PSHOP_ITEM_LIST_RECV*)lpMsg,aIndex);
					break;
				case 0x06:
					gPersonalShop.CGPShopBuyItemRecv((PMSG_PSHOP_BUY_ITEM_RECV*)lpMsg,aIndex);
					break;
				case 0x07:
					gPersonalShop.CGPShopLeaveRecv((PMSG_PSHOP_LEAVE_RECV*)lpMsg,aIndex);
					break;
			}
			break;
		case 0x40:
			gParty.CGPartyRequestRecv((PMSG_PARTY_REQUEST_RECV*)lpMsg,aIndex);
			break;
		case 0x41:
			gParty.CGPartyRequestResultRecv((PMSG_PARTY_REQUEST_RESULT_RECV*)lpMsg,aIndex);
			break;
		case 0x42:
			gParty.CGPartyListRecv(aIndex);
			break;
		case 0x43:
			gParty.CGPartyDelMemberRecv((PMSG_PARTY_DEL_MEMBER_RECV*)lpMsg,aIndex);
			break;
		case 0x4A:
			#if(GAMESERVER_UPDATE>=601)
			gSkillManager.CGRageFighterSkillAttackRecv((PMSG_RAGE_FIGHTER_SKILL_ATTACK_RECV*)lpMsg,aIndex);
			#endif
			break;
		case 0x4B:
			#if(GAMESERVER_UPDATE>=601)
			gSkillManager.CGSkillDarkSideRecv((PMSG_SKILL_DARK_SIDE_RECV*)lpMsg,aIndex);
			#endif
			break;
		case 0x4C:
			switch(lpMsg[3])
			{
				case 0x00:
					#if(GAMESERVER_UPDATE>=801)
					gMiningSystem.CGMiningStartRecv((PMSG_MINING_START_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x01:
					#if(GAMESERVER_UPDATE>=801)
					gMiningSystem.CGMiningSuccessRecv((PMSG_MINING_SUCCESS_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x03:
					#if(GAMESERVER_UPDATE>=801)
					gMiningSystem.CGMiningFailureRecv((PMSG_MINING_FAILURE_RECV*)lpMsg,aIndex);
					#endif
					break;
			}
			break;
		case 0x4D:
			switch(lpMsg[3])
			{
				case 0x00:
					#if(GAMESERVER_UPDATE>=802)
					gEventInventory.CGEventItemGetRecv((PMSG_EVENT_ITEM_GET_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x01:
					#if(GAMESERVER_UPDATE>=802)
					gEventInventory.CGEventItemDropRecv((PMSG_EVENT_ITEM_DROP_RECV*)lpMsg,aIndex);
					#endif
					break;

					//알이벤트
				case 0x0F:
					#if(GAMESERVER_UPDATE>=802)
					gEventInventory.CGEventInventoryOpenRecv((PMSG_EVENT_INVENTORY_OPEN_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x10:
					#if(GAMESERVER_UPDATE>=802)
					gMuRummy.CGReqMuRummyStart((_tagPMSG_REQ_MURUMMY_INFO*)lpMsg,aIndex);
					#endif
					break;
				case 0x11:
					#if(GAMESERVER_UPDATE>=802)
					gMuRummy.CGReqCardReveal((_tagPMSG_REQ_REVEAL_CARD*)lpMsg,aIndex);
					#endif
					break;
				case 0x12:
					#if(GAMESERVER_UPDATE>=802)
					gMuRummy.CGReqCardMove((_tagPMSG_REQ_CARD_MOVE*)lpMsg,aIndex);
					#endif
					break;
				case 0x13:
					#if(GAMESERVER_UPDATE>=802)
					gMuRummy.CGReqCardReMove((_tagPMSG_REQ_CARD_REMOVE*)lpMsg,aIndex);
					#endif
					break;
				case 0x14:
					#if(GAMESERVER_UPDATE>=802)
					gMuRummy.CGReqCardMatch((_tagPMSG_REQ_CARD_MATCH*)lpMsg,aIndex);
					#endif
					break;
				case 0x15:
					#if(GAMESERVER_UPDATE>=802)
					gMuRummy.CGReqMuRummyEnd((_tagPMSG_REQ_MURUMMY_END*)lpMsg,aIndex);
					#endif
					break;
			}
			break;
		case 0x4E:
			switch(lpMsg[3])
			{
				case 0x00:
					#if(GAMESERVER_UPDATE>=803)
					gMuunSystem.CGMuunItemGetRecv((PMSG_MUUN_ITEM_GET_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x01:
					break;
				case 0x08:
					#if(GAMESERVER_UPDATE>=803)
					gMuunSystem.CGMuunItemUseRecv((PMSG_MUUN_ITEM_USE_RECV*)lpMsg,aIndex);
					#endif
				case 0x09:
					#if(GAMESERVER_UPDATE>=803)
					gMuunSystem.CGMuunItemSellRecv((PMSG_MUUN_ITEM_SELL_RECV*)lpMsg,aIndex);
					#endif
					break;
			}
			break;
		case 0x50:
			gGuild.CGGuildRequestRecv((PMSG_GUILD_REQUEST_RECV*)lpMsg,aIndex);
			break;
		case 0x51:
			gGuild.CGGuildResultRecv((PMSG_GUILD_RESULT_RECV*)lpMsg,aIndex);
			break;
		case 0x52:
			gGuild.CGGuildListRecv(aIndex);
			break;
		case 0x53:
			gGuild.CGGuildDeleteRecv((PMSG_GUILD_DELETE_RECV*)lpMsg,aIndex);
			break;
		case 0x54:
			CGGuildMasterAnswerRecv((PMSG_GUILDMASTERANSWER*)lpMsg,aIndex);
			break;
		case 0x55:
			CGGuildMasterInfoSave(aIndex,(PMSG_GUILDINFOSAVE*)lpMsg);
			break;
		case 0x57:
			CGGuildMasterCreateCancel(aIndex);
			break;
		case 0x61:
			GCGuildWarRequestSendRecv((PMSG_GUILDWARSEND_RESULT*)lpMsg,aIndex);
			break;
		case 0x66:
			GCGuildViewportInfo((PMSG_REQ_GUILDVIEWPORT*)lpMsg,aIndex);
			break;
		case 0x79:
			switch (lpMsg[3])
			{
			case 0x01:
				gItemManager.CGMoveItemProc((PMSG_MOVEITEM*)lpMsg, aIndex);
				break;
			}
			break;
		case 0x81:
			gWarehouse.CGWarehouseMoneyRecv((PMSG_WAREHOUSE_MONEY_RECV*)lpMsg,aIndex);
			break;
		case 0x82:
			gWarehouse.CGWarehouseClose(aIndex);
			break;
		case 0x83:
			gWarehouse.CGWarehousePasswordRecv((PMSG_WAREHOUSE_PASSWORD_RECV*)lpMsg,aIndex);
			break;
		case 0x86:
			gChaosBox.CGChaosMixRecv((PMSG_CHAOS_MIX_RECV*)lpMsg,aIndex);
			break;
		case 0x87:
			gChaosBox.CGChaosMixCloseRecv(aIndex);
			break;
		case 0x8A:
			break;
		case 0x8E:
			#if(GAMESERVER_UPDATE>=501)
			gMove.CGTeleportMoveRecv((PMSG_TELEPORT_MOVE_RECV*)lpMsg,aIndex);
			#endif
			break;
		case 0x90:
			gDevilSquare.CGDevilSquareEnterRecv((PMSG_DEVIL_SQUARE_ENTER_RECV*)lpMsg,aIndex);
			break;
		case 0x91:
			CGEventRemainTimeRecv((PMSG_EVENT_REMAIN_TIME_RECV*)lpMsg,aIndex);
			break;


		case 0x9A:
			gBloodCastle.CGBloodCastleEnterRecv((PMSG_BLOOD_CASTLE_ENTER_RECV*)lpMsg,aIndex);
			break;
		case 0xA0:
			gQuest.CGQuestInfoRecv(aIndex);
			break;
		case 0xA2:
			gQuest.CGQuestStateRecv((PMSG_QUEST_STATE_RECV*)lpMsg,aIndex);
			break;
		case 0xA7:
			CGPetItemCommandRecv((PMSG_PET_ITEM_COMMAND_RECV*)lpMsg,aIndex);
			break;
		case 0xA9:
			CGPetItemInfoRecv((PMSG_PET_ITEM_INFO_RECV*)lpMsg,aIndex);
			break;
		case 0xAA:
			#if(GAMESERVER_UPDATE>=402)
			switch(lpMsg[3])
			{
				case 0x01:
					gDuel.CGDuelStartRecv((PMSG_DUEL_START_RECV*)lpMsg,aIndex);
					break;
				case 0x02:
					gDuel.CGDuelOkRecv((PMSG_DUEL_OK_RECV*)lpMsg,aIndex);
					break;
				case 0x03:
					//gDuel.CGDuelEndRecv(aIndex);
					break;
				case 0x07:
					gDuel.CGDuelWatchRecv((PMSG_DUEL_WATCH_RECV*)lpMsg,aIndex);
					break;
				case 0x09:
					gDuel.CGDuelButtonRecv((PMSG_DUEL_BUTTON_RECV*)lpMsg,aIndex);
					break;
			}
			#else
			gDuel.CGDuelStartRecv((PMSG_DUEL_START_RECV*)lpMsg,aIndex);
			#endif
			break;
		case 0xAB:
			#if(GAMESERVER_UPDATE<=401)
			gDuel.CGDuelEndRecv(aIndex);
			#endif
			break;
		case 0xAC:
			#if(GAMESERVER_UPDATE<=401)
			gDuel.CGDuelOkRecv((PMSG_DUEL_OK_RECV*)lpMsg,aIndex);
			#endif
			break;
		case 0xAE:
			#if(GAMESERVER_UPDATE>=603)
			gHelper.CGHelperDataRecv((PMSG_HELPER_DATA_RECV*)lpMsg,aIndex);
			#endif
			break;
		case 0xAF:
			switch(lpMsg[3])
			{
				case 0x01:
					gChaosCastle.CGChaosCastleEnterRecv((PMSG_CHAOS_CASTLE_ENTER_RECV*)lpMsg,aIndex);
					break;
				case 0x02:
					gChaosCastle.CGChaosCastlePositionRecv((PMSG_CHAOS_CASTLE_POSITION_RECV*)lpMsg,aIndex);
					break;
			}
			break;
		case 0xB0:
			gSkillManager.CGSkillTeleportAllyRecv((PMSG_SKILL_TELEPORT_ALLY_RECV*)lpMsg,aIndex);
			break;
		case 0xB1:
			switch(lpMsg[3])
			{
				case 0x01:
					CGMapServerMoveAuthRecv((PMSG_MAP_SERVER_MOVE_AUTH_RECV*)lpMsg,aIndex);
					break;
			}
			break;
		case 0xB2:
			switch(lpMsg[3])
			{
				case 0x00:
					CGReqCastleSiegeState((PMSG_REQ_CASTLESIEGESTATE*)lpMsg,aIndex);
					break;
				case 0x01:
					CGReqRegCastleSiege((PMSG_REQ_REGCASTLESIEGE*)lpMsg,aIndex);
					break;
				case 0x02:
					CGReqGiveUpCastleSiege((PMSG_REQ_GIVEUPCASTLESIEGE*)lpMsg,aIndex);
					break;
				case 0x03:
					CGReqGuildRegInfo((PMSG_REQ_GUILDREGINFO*)lpMsg,aIndex);
					break;
				case 0x04:
					CGReqRegGuildMark((PMSG_REQ_REGGUILDMARK*)lpMsg,aIndex);
					break;
				case 0x05:
					CGReqNpcBuy((PMSG_REQ_NPCBUY*)lpMsg,aIndex);
					break;
				case 0x06:
					CGReqNpcRepair((PMSG_REQ_NPCREPAIR*)lpMsg,aIndex);
					break;
				case 0x07:
					CGReqNpcUpgrade((PMSG_REQ_NPCUPGRADE*)lpMsg,aIndex);
					break;
				case 0x08:
					CGReqTaxMoneyInfo((PMSG_REQ_TAXMONEYINFO*)lpMsg,aIndex);
					break;
				case 0x09:
					CGReqTaxRateChange((PMSG_REQ_TAXRATECHANGE*)lpMsg,aIndex);
					break;
				case 0x10:
					CGReqMoneyDrawOut((PMSG_REQ_MONEYDRAWOUT*)lpMsg,aIndex);
					break;
				case 0x12:
					CGReqCsGateOperate((PMSG_REQ_CSGATEOPERATE*)lpMsg,aIndex);
					break;
				case 0x1B:
					CGReqCsMiniMapData((PMSG_REQ_MINIMAPDATA*)lpMsg,aIndex);
					break;
				case 0x1C:
					CGReqStopCsMiniMapData((PMSG_REQ_STOPMINIMAPDATA*)lpMsg,aIndex);
					break;
				case 0x1D:
					CGReqCsSendCommand((PMSG_REQ_CSCOMMAND*)lpMsg,aIndex);
					break;
				case 0x1F:
					CGReqCsSetEnterHuntZone((PMSG_REQ_CSHUNTZONEENTER*)lpMsg,aIndex);
					break;
			}
			break;
		case 0xB3:
			CGReqNpcDbList((PMSG_REQ_NPCDBLIST*)lpMsg,aIndex);
			break;
		case 0xB4:
			CGReqCsRegGuildList((PMSG_REQ_CSREGGUILDLIST*)lpMsg,aIndex);
			break;
		case 0xB5:
			CGReqCsAttkGuildList((PMSG_REQ_CSATTKGUILDLIST*)lpMsg,aIndex);
			break;
		case 0xB7:
			switch(lpMsg[3])
			{
				case 0x01:
					gCastleSiegeWeapon.CGCastleSiegeWeaponUseRecv((PMSG_CASTLE_SIEGE_WEAPON_USE_RECV*)lpMsg,aIndex);
					break;
				case 0x04:
					gCastleSiegeWeapon.CGCastleSiegeWeaponDamageRecv((PMSG_CASTLE_SIEGE_WEAPON_DAMAGE_RECV*)lpMsg,aIndex);
					break;
			}
			break;
		case 0xB9:
			switch(lpMsg[3])
			{
				case 0x02:
					CGReqGuildMarkOfCastleOwner((PMSG_REQ_GUILDMARK_OF_CASTLEOWNER*)lpMsg,aIndex);
					break;
				case 0x05:
					CGReqCastleHuntZoneEntrance((PMSG_REQ_MOVE_TO_CASTLE_HUNTZONE*)lpMsg,aIndex);
					break;
			}
			break;
		case 0xBC:
			switch(lpMsg[3])
			{
				case 0x00:
					gJewelMix.CGJewelMixRecv((PMSG_JEWEL_MIX_RECV*)lpMsg,aIndex);
					break;
				case 0x01:
					gJewelMix.CGJewelUnMixRecv((PMSG_JEWEL_UNMIX_RECV*)lpMsg,aIndex);
					break;
			}
			break;
		case 0xBD:
			switch(lpMsg[3])
			{
				case 0x00:
					gCrywolf.CGCrywolfInfoRecv(aIndex);
					break;
				case 0x03:
					gCrywolf.CGCrywolfAltarContractRecv((PMSG_CRYWOLF_ALTAR_CONTRACT_RECV*)lpMsg,aIndex);
					break;
				case 0x09:
					gCrywolf.CGCrywolfChaosRateRecv(aIndex);
					break;
			}
			break;
		case 0xBF:
			switch(lpMsg[3])
			{
				case 0x00:
					gIllusionTemple.CGIllusionTempleEnterRecv((PMSG_ILLUSION_TEMPLE_ENTER_RECV*)lpMsg,aIndex);
					break;
				case 0x02:
					gIllusionTemple.CGIllusionTempleSkillRecv((PMSG_ILLUSION_TEMPLE_SKILL_RECV*)lpMsg,aIndex);
					break;
				case 0x05:
					gIllusionTemple.CGIllusionTempleButtonClickRecv(aIndex);
					break;
				case 0x0B:
					#if(GAMESERVER_UPDATE>=402)
					gLuckyCoin.CGLuckyCoinCountRecv((PMSG_LUCKY_COIN_COUNT_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x0C:
					#if(GAMESERVER_UPDATE>=402)
					gLuckyCoin.CGLuckyCoinRegisterRecv((PMSG_LUCKY_COIN_REGISTER_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x0D:
					#if(GAMESERVER_UPDATE>=402)
					gLuckyCoin.CGLuckyCoinExchangeRecv((PMSG_LUCKY_COIN_EXCHANGE_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x0E:
					#if(GAMESERVER_UPDATE>=501)
					gDoubleGoer.CGDoubleGoerEnterRecv((PMSG_DOUBLE_GOER_ENTER_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x17:
					#if(GAMESERVER_UPDATE>=501)
					gNpcTalk.CGNpcJuliaRecv(aIndex);
					#endif
					break;
				case 0x20:
					#if(GAMESERVER_UPDATE>=501)
					gInventoryEquipment.CGInventoryEquipmentRecv((PMSG_INVENTORY_EQUIPMENT_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x51:
					#if(GAMESERVER_UPDATE>=603)
					gHelper.CGHelperStartRecv((PMSG_HELPER_START_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x70:
					#if(GAMESERVER_UPDATE >= 803) //esse
					gIllusionTemple.CGIllusionTempleEnterRecv((PMSG_ILLUSION_TEMPLE_ENTER_RECV*)lpMsg,aIndex); //Original
					#endif
					break;
				default:
					LogAdd(LOG_RED, "[0xBF] Unknown packet BF:%d",lpMsg[3]);
					break;
			}
			break;
		case 0xC0:
			FriendListRequest(aIndex);
			break;
		case 0xC1:
			FriendAddRequest((PMSG_FRIEND_ADD_REQ*)lpMsg,aIndex);
			break;
		case 0xC2:
			WaitFriendAddRequest((PMSG_FRIEND_ADD_SIN_RESULT*)lpMsg,aIndex);
			break;
		case 0xC3:
			FriendDelRequest((PMSG_FRIEND_DEL_REQ*)lpMsg,aIndex);
			break;
		case 0xC4:
			FriendStateClientRecv((PMSG_FRIEND_STATE_C*)lpMsg,aIndex);
			break;
		case 0xC5:
			FriendMemoSend((PMSG_FRIEND_MEMO*)lpMsg,aIndex);
			break;
		case 0xC7:
			FriendMemoReadReq((PMSG_FRIEND_READ_MEMO_REQ*)lpMsg,aIndex);
			break;
		case 0xC8:
			FriendMemoDelReq((PMSG_FRIEND_MEMO_DEL_REQ*)lpMsg,aIndex);
			break;
		case 0xC9:
			FriendMemoListReq(aIndex);
			break;
		case 0xCA:
			FriendChatRoomCreateReq((PMSG_FRIEND_ROOMCREATE_REQ*)lpMsg,aIndex);
			break;
		case 0xCB:
			FriendRoomInvitationReq((PMSG_ROOM_INVITATION*)lpMsg,aIndex);
			break;
		case 0xD0:
			switch(lpMsg[3])
			{
				case 0x05:
					#if(GAMESERVER_UPDATE<=402)
					gPcPoint.CGPcPointItemBuyRecv((PMSG_PC_POINT_ITEM_BUY_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x06:
					#if(GAMESERVER_UPDATE<=402)
					gPcPoint.CGPcPointOpenRecv((PMSG_PC_POINT_OPEN_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x07:
					#if(GAMESERVER_UPDATE>=301)
					gQuest.CGQuestNpcWarewolfRecv(aIndex);
					#endif
					break;
				case 0x08:
					#if(GAMESERVER_UPDATE>=301)
					gQuest.CGQuestNpcKeeperRecv(aIndex);
					#endif
					break;
				case 0x09:
					#if(GAMESERVER_UPDATE>=202)
					gNpcTalk.CGNpcLeoTheHelperRecv(aIndex);
					#endif
					break;
				case 0x0A:
					#if(GAMESERVER_UPDATE>=401)
					gNpcTalk.CGNpcSnowmanRecv(aIndex);
					#endif
					break;
				case 0x10:
					#if(GAMESERVER_UPDATE>=401)
					gNpcTalk.CGNpcSantaClausRecv(aIndex);
					#endif
					break;
			}
			break;
		case 0xD1:
			switch(lpMsg[3])
			{
				case 0x00:
					gKanturuEntranceNPC.CGKanturuEnterInfoRecv(aIndex);
					break;
				case 0x01:
					gKanturuEntranceNPC.CGKanturuEnterRecv(aIndex);
					break;
			}
			break;
		case 0xD2:
			switch(lpMsg[3])
			{
				case 0x01:
					#if(GAMESERVER_UPDATE>=501)
					gCashShop.CGCashShopPointRecv(aIndex);
					#endif
					break;
				case 0x02:
					#if(GAMESERVER_UPDATE>=501)
					gCashShop.CGCashShopOpenRecv((PMSG_CASH_SHOP_OPEN_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x03:
					#if(GAMESERVER_UPDATE>=501)
					gCashShop.CGCashShopItemBuyRecv((PMSG_CASH_SHOP_ITEM_BUY_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x04:
					#if(GAMESERVER_UPDATE>=501)
					gCashShop.CGCashShopItemGifRecv((PMSG_CASH_SHOP_ITEM_GIF_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x05:
					#if(GAMESERVER_UPDATE>=501)
					gCashShop.CGCashShopItemNumRecv((PMSG_CASH_SHOP_ITEM_NUM_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x0B:
					#if(GAMESERVER_UPDATE>=501)
					gCashShop.CGCashShopItemUseRecv((PMSG_CASH_SHOP_ITEM_USE_RECV*)lpMsg,aIndex);
					#endif
					break;
			}
			break;
		case PROTOCOL_CODE1:
			CGMoveRecv((PMSG_MOVE_RECV*)lpMsg,aIndex);
			break;
		case PROTOCOL_CODE4:
			gSkillManager.CGMultiSkillAttackRecv((PMSG_MULTI_SKILL_ATTACK_RECV*)lpMsg,aIndex,0);
			break;
		case 0xE1:
			gGuild.CGGuildAssignStatusRecv((PMSG_GUILD_ASSIGN_STATUS_RECV*)lpMsg,aIndex);
			break;
		case 0xE2:
			CGGuildAssignType((PMSG_GUILD_ASSIGN_TYPE_REQ*)lpMsg,aIndex);
			break;
		case 0xE5:
			CGRelationShipReqJoinBreakOff((PMSG_RELATIONSHIP_JOIN_BREAKOFF_REQ*)lpMsg,aIndex);
			break;
		case 0xE6:
			CGRelationShipAnsJoinBreakOff((PMSG_RELATIONSHIP_JOIN_BREAKOFF_ANS*)lpMsg,aIndex);
			break;
		case 0xE7:
			switch(lpMsg[3])
			{
				case 0x01:
					#if(GAMESERVER_UPDATE>=802)
					gMiniMap.CGMiniMapStartPartyInfoRecv(aIndex);
					#endif
					break;
				case 0x02:
					#if(GAMESERVER_UPDATE>=802)
					gMiniMap.CGMiniMapClosePartyInfoRecv(aIndex);
					#endif
					break;
				case 0x03:
					#if(GAMESERVER_UPDATE>=802)
					gMiniMap.CGMiniMapInfoRecv((PMSG_MINI_MAP_INFO_RECV*)lpMsg,aIndex);
					#endif
					break;
			}
			break;
		case 0xE9:
			CGUnionList((PMSG_UNIONLIST_REQ*)lpMsg,aIndex);
			break;
		case 0xEB:
			switch(lpMsg[3])
			{
				case 0x01:
					CGRelationShipReqKickOutUnionMember((PMSG_KICKOUT_UNIONMEMBER_REQ*)lpMsg,aIndex);
					break;
			}
			break;
		case 0xEC:
			switch(lpMsg[3])
			{
				case 0x00:
					#if(GAMESERVER_UPDATE>=701)
					gPentagramSystem.CGPentagramJewelInsertRecv((PMSG_PENTAGRAM_JEWEL_INSERT_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x01:
					#if(GAMESERVER_UPDATE>=701)
					gPentagramSystem.CGPentagramJewelRemoveRecv((PMSG_PENTAGRAM_JEWEL_REMOVE_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x02:
					#if(GAMESERVER_UPDATE>=701)
					gPentagramSystem.CGPentagramJewelRefineRecv((PMSG_PENTAGRAM_JEWEL_REFINE_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x03:
					#if(GAMESERVER_UPDATE>=701)
					gPentagramSystem.CGPentagramJewelUpgradeRecv((PMSG_PENTAGRAM_JEWEL_UPGRADE_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x31:
					#if(GAMESERVER_UPDATE>=802)
					gPersonalShop.CGPShopSearchRecv((PMSG_PSHOP_SEARCH_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x33:
					#if(GAMESERVER_UPDATE>=802)
					gPersonalShop.CGPShopSearchLogRecv((PMSG_PSHOP_SEARCH_LOG_RECV*)lpMsg,aIndex);
					#endif
					break;
			}
			break;
		case 0xED:
			switch(lpMsg[3])
			{
				case 0x00:
					#if(GAMESERVER_UPDATE>=801)
					gGuildMatching.CGGuildMatchingListRecv((PMSG_GUILD_MATCHING_LIST_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x01:
					#if(GAMESERVER_UPDATE>=801)
					gGuildMatching.CGGuildMatchingListSearchRecv((PMSG_GUILD_MATCHING_LIST_SEARCH_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x02:
					#if(GAMESERVER_UPDATE>=801)
					gGuildMatching.CGGuildMatchingInsertRecv((PMSG_GUILD_MATCHING_INSERT_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x03:
					#if(GAMESERVER_UPDATE>=801)
					gGuildMatching.CGGuildMatchingCancelRecv((PMSG_GUILD_MATCHING_CANCEL_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x04:
					#if(GAMESERVER_UPDATE>=801)
					gGuildMatching.CGGuildMatchingJoinInsertRecv((PMSG_GUILD_MATCHING_JOIN_INSERT_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x05:
					#if(GAMESERVER_UPDATE>=801)
					gGuildMatching.CGGuildMatchingJoinCancelRecv((PMSG_GUILD_MATCHING_JOIN_CANCEL_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x06:
					#if(GAMESERVER_UPDATE>=801)
					gGuildMatching.CGGuildMatchingJoinAcceptRecv((PMSG_GUILD_MATCHING_JOIN_ACCEPT_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x07:
					#if(GAMESERVER_UPDATE>=801)
					gGuildMatching.CGGuildMatchingJoinListRecv((PMSG_GUILD_MATCHING_JOIN_LIST_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x08:
					#if(GAMESERVER_UPDATE>=801)
					gGuildMatching.CGGuildMatchingJoinInfoRecv((PMSG_GUILD_MATCHING_JOIN_INFO_RECV*)lpMsg,aIndex);
					#endif
					break;
			}
			break;


		case 0xEF:
			switch(lpMsg[3])
			{
				case 0x00:
					//파티매칭
					#if(GAMESERVER_UPDATE>=801)
					gPartyMatching.CGPartyMatchingInsertRecv((PMSG_PARTY_MATCHING_INSERT_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x01:
					#if(GAMESERVER_UPDATE>=801)
					gPartyMatching.CGPartyMatchingListRecv((PMSG_PARTY_MATCHING_LIST_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x02:
					#if(GAMESERVER_UPDATE>=801)
					gPartyMatching.CGPartyMatchingJoinInsertRecv((PMSG_PARTY_MATCHING_JOIN_INSERT_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x03:
					#if(GAMESERVER_UPDATE>=801)
					gPartyMatching.CGPartyMatchingJoinInfoRecv((PMSG_PARTY_MATCHING_JOIN_INFO_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x04:
					#if(GAMESERVER_UPDATE>=801)
					gPartyMatching.CGPartyMatchingJoinListRecv((PMSG_PARTY_MATCHING_JOIN_LIST_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x05:
					#if(GAMESERVER_UPDATE>=801)
					gPartyMatching.CGPartyMatchingJoinAcceptRecv((PMSG_PARTY_MATCHING_JOIN_ACCEPT_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x06:
					#if(GAMESERVER_UPDATE>=801)
					gPartyMatching.CGPartyMatchingJoinCancelRecv((PMSG_PARTY_MATCHING_JOIN_CANCEL_RECV*)lpMsg,aIndex);
					#endif
					break;
			}
			break;
		case 0xF1:
			switch(lpMsg[3])
			{
				case 0x01:
					CGConnectAccountRecv((PMSG_CONNECT_ACCOUNT_RECV*)lpMsg,aIndex);
					break;
				case 0x02:
					CGCloseClientRecv((PMSG_CLOSE_CLIENT_RECV*)lpMsg,aIndex);
					//gCommandManager.CommandGuildAttack(&gObj[aIndex]); //길드어택
					break;
				case 0x03:
					break;
			}
			break;
		case 0xF3:
			switch(lpMsg[3])
			{
				case 0x00:
					CGCharacterListRecv(aIndex);
					break;
				case 0x01:
					CGCharacterCreateRecv((PMSG_CHARACTER_CREATE_RECV*)lpMsg,aIndex);
					break;
				case 0x02:
					CGCharacterDeleteRecv((PMSG_CHARACTER_DELETE_RECV*)lpMsg,aIndex);
					break;
				case 0x03:
					CGCharacterInfoRecv((PMSG_CHARACTER_INFO_RECV*)lpMsg,aIndex);
					break;
				case 0x06:
					CGLevelUpPointRecv((PMSG_LEVEL_UP_POINT_RECV*)lpMsg,aIndex);
					break;
				case 0x12:
					CGCharacterMoveViewportEnableRecv(aIndex);
					break;
				case 0x15:
					#if(GAMESERVER_UPDATE>=401)
					CGCharacterNameCheckRecv((PMSG_CHARACTER_NAME_CHECK_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x16:
					#if(GAMESERVER_UPDATE>=401)
					CGCharacterNameChangeRecv((PMSG_CHARACTER_NAME_CHANGE_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x21:
					#if(GAMESERVER_UPDATE>=701)
					CGOptionChangeSkinRecv((PMSG_OPTION_CHANGE_SKIN_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x30:
					CGOptionDataRecv((PMSG_OPTION_DATA_RECV*)lpMsg,aIndex);
					break;
				case 0x31:
					#if(GAMESERVER_UPDATE>=701)
					CGClientSecurityBreachRecv((PMSG_CLIENT_SECURITY_BREACH_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x52:
					#if(GAMESERVER_UPDATE>=401)
					gMasterSkillTree.CGMasterSkillRecv((PMSG_MASTER_SKILL_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0xE6:
					gCustomRanking.GCReqRanking(aIndex,(PMSG_CUSTOM_RANKING_RECV*)lpMsg);
					break;
				case 0xE7:
					gCustomRanking.GCReqRankingCount(aIndex,(PMSG_CUSTOM_RANKING_COUNT_RECV*)lpMsg);
					break;
				case 0xE8:
					gCustomEventTime.GCReqEventTime(aIndex,(PMSG_CUSTOM_EVENTTIME_RECV*)lpMsg);
					break;
					//하드
				//case 0xE9:
				//	gHwidManager.ConnectHwid((CG_HWID_SEND*)lpMsg, &gObj[aIndex]);
				//	break;
					//
				case 0xEB:
					gCustomStore.CGOffTradeRecv((PMSG_OFFTRADE_RECV*)lpMsg, aIndex);
					break;
				case 0xED:
					gItemManager.CGItemBuyConfirmRecv((PMSG_ITEM_BUY_NEW*)lpMsg,aIndex);
					break;
				case 0xF0:
					gCustomBuyVip.BuyVip(aIndex,(BUYPREMIUM_REQ*)lpMsg);
					break;

				case 0xF5:
					gCustomJewelBank.JewelBankRecv((PSBMSG_JEWELBANK_RECV*)lpMsg, aIndex);
					break;
				case 0xF6:
					gCustomJewelBank.JewelBankWithDrawRecv((PSBMSG_JEWELBANKWITHDRAW_RECV*)lpMsg, aIndex);
					break;

			}
			break;
		case 0xF6:
			switch(lpMsg[3])
			{
				case 0x0A:
					#if(GAMESERVER_UPDATE>=501)
					gQuestWorld.CGQuestWorldDialogRecv((PMSG_QUEST_WORLD_DIALOG_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x0B:
					#if(GAMESERVER_UPDATE>=501)
					gQuestWorld.CGQuestWorldAcceptRecv((PMSG_QUEST_WORLD_ACCEPT_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x0D:
					#if(GAMESERVER_UPDATE>=501)
					gQuestWorld.CGQuestWorldFinishRecv((PMSG_QUEST_WORLD_FINISH_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x0F:
					#if(GAMESERVER_UPDATE>=501)
					gQuestWorld.CGQuestWorldCancelRecv((PMSG_QUEST_WORLD_CANCEL_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x10:
					#if(GAMESERVER_UPDATE>=501)
					gQuestWorld.CGQuestWorldButtonRecv((PMSG_QUEST_WORLD_BUTTON_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x1B:
					#if(GAMESERVER_UPDATE>=501)
					gQuestWorld.CGQuestWorldDetailRecv((PMSG_QUEST_WORLD_DETAIL_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x30:
					#if(GAMESERVER_UPDATE>=501)
					gQuestWorld.CGQuestWorldListRecv(aIndex);
					#endif
					break;
				case 0x31:
					#if(GAMESERVER_UPDATE>=501)
					gQuestWorld.CGQuestWorldNpcElfBufferRecv(aIndex);
					#endif
					break;
			}
			break;
		case 0xF7:
			switch(lpMsg[3])
			{
				case 0x01:
					#if(GAMESERVER_UPDATE>=501)
					gImperialGuardian.CGImperialGuardianEnterRecv((PMSG_IMPERIAL_GUARDIAN_ENTER_RECV*)lpMsg,aIndex);
					#endif
					break;
			}
			break;
		case 0xF8:
			switch(lpMsg[3])
			{
				case 0x01:
					#if(GAMESERVER_UPDATE>=501)
					gGensSystem.CGGensSystemInsertRecv((PMSG_GENS_SYSTEM_INSERT_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x03:
					#if(GAMESERVER_UPDATE>=501)
					gGensSystem.CGGensSystemDeleteRecv((PMSG_GENS_SYSTEM_DELETE_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x09:
					#if(GAMESERVER_UPDATE>=501)
					gGensSystem.CGGensSystemRewardRecv((PMSG_GENS_SYSTEM_REWARD_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x0B:
					#if(GAMESERVER_UPDATE>=501)
					gGensSystem.CGGensSystemMemberRecv((PMSG_GENS_SYSTEM_MEMBER_RECV*)lpMsg,aIndex);
					#endif
					break;
				case 0x20:
					#if(GAMESERVER_UPDATE>=701)
					CGAcheronEnterRecv(aIndex);
					#endif
					break;
				case 0x30:
					#if(GAMESERVER_UPDATE>=702)
					gArcaBattle.CGArcaBattleGuildMasterRegisterRecv(aIndex);
					#endif
					break;
				case 0x32:
					#if(GAMESERVER_UPDATE>=702)
					gArcaBattle.CGArcaBattleGuildMemberRegisterRecv(aIndex);
					#endif
					break;
				case 0x34:
					//CGReqArcaBattleEnter((_tagPMSG_REQ_ARCA_BATTLE_ENTER *)aRecv, aIndex);
					break;
				case 0x36:
					//CGReqArcaBattleBootyExchange(aIndex);
					break;
				case 0x3C:
					//CGReqSpritemapExchange(aIndex);
					break;
				case 0x41:
					//CGReqRegisteredMemberCnt(aIndex);
					break;
				case 0x43:
					#if(GAMESERVER_UPDATE>=702)
					gArcaBattle.CGArcaBattleRegisterMarkRecv(aIndex);
					#endif
					break;
				case 0x45:
					//CArcaBattle::CGReqMarkRank(&g_ArcaBattle, aIndex);
					break;
				case 0x4B:
					//CAcheronGuardianEvent::CGReqAcheronEventEnter(&g_AcheronGuardianEvent,(_tagPMSG_REQ_ACHERON_EVENT_ENTER *)aRecv,aIndex);
					break;
			}
			break;
		case 0xFB:
			#if(GAMESERVER_UPDATE>=801)
			CGSNSDataRecv((PMSG_SNS_DATA_RECV*)lpMsg,aIndex);
			#endif
			break;

		case 0xFC:
			#if(GAMESERVER_UPDATE>=801)
			CGSNSDataLogRecv((PMSG_SNS_DATA_LOG_RECV*)lpMsg,aIndex);
			#endif
			break;

		case 0xFD:
			switch (lpMsg[3])
			{
				//룰렛
				case 0x16:
					gLuckySpin.StartRoll(lpObj);
				break;
				case 0x17:
					gLuckySpin.GCItemSend(aIndex);
				break;
				case 0x18: 
					 gQuaMocReset.GiftItem(&gObj[aIndex]); //선물
				break;

				case 0x27:
					RPSMode(lpObj, (RPSMODE_REQ*)lpMsg);
				break;
				//
			}
			break;

		case 0xFF:
			switch(((lpMsg[0]==0xC1)?lpMsg[3]:lpMsg[4]))
			{
				/*
#if (GAMESERVER_UPDATE == 603)
				case 0x00:
					g_ResetSystem.SendResetData(&gObj[aIndex], false);
					//gCommandManager.CommandReset(&gObj[aIndex], "");
					break;
#endif
				case 0x01:
					gCommandManager.CommandMasterReset(&gObj[aIndex], "");
					break;

				case 0x02:
					gCommandManager.CommandPKClear(&gObj[aIndex], "");
					break; */
				case 0x03:
					#if USE_TESTOFFEXP == TRUE
					gOffLevel.SetOfflineLeveling(aIndex);
					#else
					//gCustomAttack.CommandCustomAttack(&gObj[aIndex], "");
					//gCustomAttack.CommandCustomAttackOffline(&gObj[aIndex], "");
					#endif
					break;
			/*	case 0x04:
					CGUserPanelReq(aIndex);
					break;*/
//#if (GAMESERVER_UPDATE == 603)
				case 0x05:
					gChangeClass.RecvChangeClass((CG_CHANGECLASS_RECV*)lpMsg, aIndex);
				break;
				//case 0x06:
				//	CGShopOpen((PMSG_SHOPINTERFACE_RECV*)lpMsg, aIndex);
				//	break;
				/*case 0x07:
					g_ResetSystem.FinishResetReq(&gObj[aIndex]);
					break;
				case 0x09:
					gTeleportPanel.RecvTeleportPanel((PMSG_TELEPORTPANEL_RECV*)lpMsg, aIndex);
					break;
				case 0x0A:
					gOfflineMode.CGOfflineModeRecv(aIndex);
					break; */
				//case 0x0B:
				//	CGWarehouseOpen((PMSG_WAREHOUSEINTERFACE_RECV*)lpMsg, aIndex);
				//	break;
				//case 0x0C:
				//	CGStatAddRecv((PMSG_UPDATE_STATS_RECV*)lpMsg, aIndex);
				//	break;
			/*	case 0x0D:
					gGRSystem.SendResetData(&gObj[aIndex], false);
					break;
				case 0x0E:
					gGRSystem.FinishResetReq(&gObj[aIndex]);
					break; */

				
				case 0x10:
				gAchievements.CGWindowOpen((PMSG_CG_ACH_WINOPEN*)lpMsg, aIndex);
				break;
				case 0x0D:
					gCommandManager.CommandGuildAttack(&gObj[aIndex]); //길드어택
					break;

				case 0x0E:
					gCommandManager.CommandAutoChage(&gObj[aIndex]); //오토환전
					break;

				case 0x0F:
					gCommandManager.CommandOffExp(&gObj[aIndex]); //경험치 메세지
					break;


				//case 0x0F:
				//	CGResetStatsRecv((PMSG_RESET_STATS_RECV*)lpMsg, aIndex);
				//	break;

			/*	case 0x10:
					GDCharacterListMultiSend((PMSG_REQ_MULTI_CHAR_RECV*)lpMsg, aIndex);
					break;
				case 0x11:
					CGOffTradeRecv((PMSG_OFFTRADE_RECV*)lpMsg, aIndex);
					break; */
				//case 0x12:
				//	gPartySearch.PartySearchAddToList((PMSG_RECV_PARTYSEARCH_ADD*)lpMsg, aIndex);
				//	break;
				//case 0x13:
				//	gPartySearch.RequestParty((PMSG_PARTY_REQ_REQ*)lpMsg, aIndex);
				//	break;
				/*case 0x14:
					gOfflineMode.CGOfflineModeStartRecv((PMSG_OFFLINEMODE_DATA_RECV*)lpMsg,aIndex);
					break;
				case 0x15:
					gParty.SetLeader(&gObj[aIndex],(BYTE)*(lpMsg+4));
					break; */
				//case 0x16:
				//	gSmithy.GCItemSend(aIndex);
				//	break;
				//case 0x17:
				//	gSmithy.CGCreateItem((CG_SmithyCreateItem*)lpMsg,aIndex);
				//	break;
				/*case 0x18:
					gNpcTalk.NpcChaosGoblin(NULL,&gObj[aIndex]);
					break;
				//case 0x18:
				//	gPersonalShop.CGPShopSetItemPriceRecvEx((PMSG_PSHOP_SET_ITEM_PRICE_EX_RECV*)lpMsg,aIndex);
				//	break;
				case 0x19:
					gPackSystem.CGMixRecv((CG_MIX_RECV*)lpMsg,aIndex);
					break;
				case 0x1A:
					gPackSystem.CGUnMixRecv((CG_UNMIX_RECV*)lpMsg,aIndex);
					break; */
//#endif
			}
			break;

		//-- 핑
		case 0xFE:
			GCSendPing(aIndex);
			break;


	}

	PROTECT_FINAL
}

void CGChatRecv(PMSG_CHAT_RECV* lpMsg,int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(gObjIsConnectedGP(aIndex) == 0)
	{
		return;
	}

	char name[11] = {0};

	memcpy(name,lpMsg->name,sizeof(lpMsg->name));

	if(strcmp(name,lpObj->Name) != 0)
	{
		return;
	}

	lpMsg->message[(sizeof(lpMsg->message)-1)] = 0;

	gLog.Output(LOG_CHAT,"[General][%s][%s] - (Message: %s)",lpObj->Account,lpObj->Name,lpMsg->message);

	if(lpMsg->message[0] == '/')
	{

		if(gCommandManager.ManagementCore(&gObj[aIndex],lpMsg->message,-1) == 1)
		{
			return;
		}
		else if(gCustomCommandDescription.GetInfoByName(lpObj,lpMsg->message) != 0)
		{
			return;
		}
		else
		{
			CUSTOMMOVE_INFO CustomMoveInfo;

			if(gCustomMove.GetInfoByName(lpMsg->message,&CustomMoveInfo) != 0)
			{
				gCustomMove.GetMove(lpObj,CustomMoveInfo.Index);
			}

			return;
		}
	}

	gFilter.CheckSyntax(lpMsg->message);

	if(lpObj->ChatLimitTime > 0 && gServerInfo.m_CommandBanChatSwitch != 0)
	{
		gNotice.GCNoticeSend(aIndex,1,0,0,0,0,0,gMessage.GetMessage(269),lpObj->ChatLimitTime);
		return;
	}

	if((lpObj->Penalty & 2) != 0)
	{
		return;
	}

	PMSG_CHAT_SEND pMsg;

	pMsg.header.set(0x00,sizeof(pMsg));

	memcpy(pMsg.name,lpMsg->name,sizeof(pMsg.name));

	memcpy(pMsg.message,lpMsg->message,sizeof(pMsg.message));


	if(lpMsg->message[0] == '~')
	{
		if(OBJECT_RANGE(lpObj->PartyNumber) != 0)
		{
			for(int n=0;n < MAX_PARTY_USER;n++)
			{
				if(OBJECT_RANGE(gParty.m_PartyInfo[lpObj->PartyNumber].Index[n]) != 0)
				{
					DataSend(gParty.m_PartyInfo[lpObj->PartyNumber].Index[n],(BYTE*)&pMsg,pMsg.header.size);
				}
			}
		}
	}

	else if(lpMsg->message[0] == '@')
	{
		if(lpObj->Guild != 0)
		{
			if(lpMsg->message[1] == '>')
			{
				if(strcmp(lpObj->Name,lpObj->Guild->Names[0]) == 0)
				{
					GDGuildNoticeSave(lpObj->Guild->Name,&lpMsg->message[2]);
				}
			}
			else if(lpMsg->message[1] == '@')
			{
				if(lpObj->Guild->GuildUnion != 0)
				{
					GDUnionServerGroupChattingSend(lpObj->Guild->GuildUnion,lpMsg->name,lpMsg->message);
				}
			}
			else
			{
				if(lpObj->Guild->Number != 0)
				{
					GDGuildServerGroupChattingSend(lpObj->Guild->Number,lpMsg->name,lpMsg->message);
				}
			}
		}
	}

else if(lpMsg->message[0] == '$')
{
    // 겐스 채팅 비활성화 - 아무것도 하지 않음
    return;
}
else
{
    DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
    MsgSendV2(lpObj,(BYTE*)&pMsg,pMsg.header.size);
}
}

void CGChatWhisperRecv(PMSG_CHAT_WHISPER_RECV* lpMsg,int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(gObjIsConnectedGP(aIndex) == 0)
	{
		return;
	}

	char name[11] = {0};

	memcpy(name,lpMsg->name,sizeof(lpMsg->name));

	if(lpObj->ChatLimitTime > 0 && gServerInfo.m_CommandBanChatSwitch != 0)
	{
		gNotice.GCNoticeSend(aIndex,1,0,0,0,0,0,gMessage.GetMessage(269),lpObj->ChatLimitTime);
		return;
	}

	if((lpObj->Penalty & 2) != 0)
	{
		return;
	}

	LPOBJ lpTarget = gObjFind(name);

	if(lpTarget == 0)
	{
		GDGlobalWhisperSend(aIndex,"가라",lpMsg->message);
		return;
	}

	if(aIndex == lpTarget->Index)
	{
		gNotice.GCNoticeSend(aIndex,1,0,0,0,0,0,gMessage.GetMessage(270));
		return;
	}

	lpMsg->message[(sizeof(lpMsg->message)-1)] = 0;

	gLog.Output(LOG_CHAT,"[Whisper][%s][%s] - (Name: %s, Message: %s)",lpObj->Account,lpObj->Name, name, lpMsg->message);

	gFilter.CheckSyntax(lpMsg->message);

	GCChatWhisperSend(lpTarget->Index,lpObj->Name ,lpMsg->message);
}

void CGMainCheckRecv(PMSG_MAIN_CHECK_RECV* lpMsg,int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(gServerInfo.m_MainChecksum != 0)
	{
		if(lpObj->CheckSumTableNum < 0 || lpObj->CheckSumTableNum >= MAX_CHECKSUM_KEY)
		{
			gLog.Output(LOG_HACK,"[%s][%s] Main CheckSum error",lpObj->Account,lpObj->Name);
			GCCloseClientSend(aIndex,0);
			return;
		}

		if(gCheckSum[lpObj->CheckSumTableNum] != lpMsg->key)
		{
			gLog.Output(LOG_HACK,"[%s][%s] Invalid Main CheckSum",lpObj->Account,lpObj->Name);
			GCCloseClientSend(aIndex,0);
			return;
		}
	}

	lpObj->CheckSumTime = 0;
}

void CGLiveClientRecv(PMSG_LIVE_CLIENT_RECV* lpMsg,int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Connected != OBJECT_LOGGED && lpObj->Connected != OBJECT_ONLINE)
	{
		return;
	}

	if(gServerInfo.m_CheckLatencyHack != 0 && abs((int)((GetTickCount()-lpObj->ServerTickCount)-(lpMsg->TickCount-lpObj->ClientTickCount))) > gServerInfo.m_CheckLatencyHackTolerance)
	{
		gLog.Output(LOG_HACK,"[%s][%s] Client Latency Hack Detected [%d][%d]",lpObj->Account,lpObj->Name,(GetTickCount()-lpObj->ServerTickCount),(lpMsg->TickCount-lpObj->ClientTickCount));
		GCCloseClientSend(aIndex,0);
		return;
	}

	if(lpObj->Connected == OBJECT_ONLINE && gServerInfo.m_CheckSpeedHack != 0 && lpMsg->PhysiSpeed > lpObj->PhysiSpeed && abs((int)(lpObj->PhysiSpeed-lpMsg->PhysiSpeed)) > gServerInfo.m_CheckSpeedHackTolerance)
	{
		gLog.Output(LOG_HACK,"[%s][%s] Client Speed Hack Detected [%d][%d]",lpObj->Account,lpObj->Name,lpObj->PhysiSpeed,lpMsg->PhysiSpeed);
		GCCloseClientSend(aIndex,0);
		return;
	}

	if(lpObj->Connected == OBJECT_ONLINE && gServerInfo.m_CheckSpeedHack != 0 && lpMsg->MagicSpeed > lpObj->MagicSpeed && abs((int)(lpObj->MagicSpeed-lpMsg->MagicSpeed)) > gServerInfo.m_CheckSpeedHackTolerance)
	{
		gLog.Output(LOG_HACK,"[%s][%s] Client Speed Hack Detected [%d][%d]",lpObj->Account,lpObj->Name,lpObj->MagicSpeed,lpMsg->MagicSpeed);
		GCCloseClientSend(aIndex,0);
		return;
	}

	lpObj->ConnectTickCount = GetTickCount();
}

void CGPositionRecv(PMSG_POSITION_RECV* lpMsg,int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(gObjIsConnectedGS(aIndex) == 0)
	{
		return;
	}

	if(lpObj->Teleport != 0)
	{
		return;
	}

	if(gObjCheckMapTile(lpObj,2) != 0)
	{
		return;
	}

	if(CC_MAP_RANGE(lpObj->Map) != 0 && (GetTickCount()-lpObj->ChaosCastleBlowTime) < 1000)
	{
		return;
	}

	if(lpMsg->x < (lpObj->X-15) || lpMsg->x > (lpObj->X+15) || lpMsg->y < (lpObj->Y-15) || lpMsg->y > (lpObj->Y+15))
	{
		return;
	}

	gMap[lpObj->Map].DelStandAttr(lpObj->OldX,lpObj->OldY);

	lpObj->X = lpMsg->x;
	lpObj->Y = lpMsg->y;
	lpObj->TX = lpMsg->x;
	lpObj->TY = lpMsg->y;
	lpObj->OldX = lpMsg->x;
	lpObj->OldY = lpMsg->y;

	gMap[lpObj->Map].SetStandAttr(lpObj->TX,lpObj->TY);

	PMSG_POSITION_SEND pMsg;

	pMsg.header.set(PROTOCOL_CODE3,sizeof(pMsg));

	pMsg.index[0] = SET_NUMBERHB(aIndex);

	pMsg.index[1] = SET_NUMBERLB(aIndex);

	pMsg.x = (BYTE)lpObj->TX;

	pMsg.y = (BYTE)lpObj->TY;

	if(lpObj->Type == OBJECT_USER)
	{
		DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
	}

	for(int n=0;n < MAX_VIEWPORT;n++)
	{
		if(lpObj->VpPlayer2[n].type == OBJECT_USER)
		{
			if(lpObj->VpPlayer2[n].state != OBJECT_EMPTY && lpObj->VpPlayer2[n].state != OBJECT_DIECMD && lpObj->VpPlayer2[n].state != OBJECT_DIED)
			{
				DataSend(lpObj->VpPlayer2[n].index,(BYTE*)&pMsg,pMsg.header.size);
			}
		}
	}
}

void CGActionRecv(PMSG_ACTION_RECV* lpMsg,int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(gObjIsConnectedGP(aIndex) == 0)
	{
		return;
	}

	lpObj->Dir = lpMsg->dir;

	lpObj->ActionNumber = lpMsg->action;

	if(lpObj->ActionNumber == ACTION_SIT1)
	{
		lpObj->ViewState = 2;
		lpObj->Rest = lpObj->ActionNumber;
	}
	else if(lpObj->ActionNumber == ACTION_POSE1)
	{
		lpObj->ViewState = 3;
		lpObj->Rest = lpObj->ActionNumber;
	}
	else if(lpObj->ActionNumber == ACTION_HEALING1)
	{
		lpObj->ViewState = 4;
		lpObj->Rest = lpObj->ActionNumber;
	}

	PMSG_ACTION_SEND pMsg;

	pMsg.header.set(0x18,sizeof(pMsg));

	pMsg.index[0] = SET_NUMBERHB(aIndex);

	pMsg.index[1] = SET_NUMBERLB(aIndex);

	pMsg.dir = lpMsg->dir;

	pMsg.action = lpMsg->action;

	pMsg.target[0] = lpMsg->index[0];

	pMsg.target[1] = lpMsg->index[1];
	
	for(int n=0;n < MAX_VIEWPORT;n++)
	{
		if(lpObj->VpPlayer2[n].type == OBJECT_USER)
		{
			if(lpObj->VpPlayer2[n].state != OBJECT_EMPTY && lpObj->VpPlayer2[n].state != OBJECT_DIECMD && lpObj->VpPlayer2[n].state != OBJECT_DIED)
			{
				DataSend(lpObj->VpPlayer2[n].index,(BYTE*)&pMsg,pMsg.header.size);
			}
		}
	}
}
void CGEventRemainTimeRecv(PMSG_EVENT_REMAIN_TIME_RECV* lpMsg,int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(gObjIsConnectedGP(aIndex) == 0)
	{
		return;
	}

	PMSG_EVENT_REMAIN_TIME_SEND pMsg;

	pMsg.header.set(0x91,sizeof(pMsg));

	pMsg.EventType = lpMsg->EventType;

	pMsg.RemainTimeH = 0;

	pMsg.EnteredUser = 0;

	pMsg.RemainTimeL = 0;

	if(lpMsg->EventType == 4)
	{
		lpMsg->ItemLevel = gChaosCastle.GetUserAbleLevel(&gObj[aIndex]);
	}
	else
	{
		lpMsg->ItemLevel = ((lpMsg->EventType==2)?lpMsg->ItemLevel:(lpMsg->ItemLevel-1));
	}

	switch(lpMsg->EventType)
	{
		case 1:
			if(DS_LEVEL_RANGE(lpMsg->ItemLevel) != 0)
			{
				if(gDevilSquare.GetState(lpMsg->ItemLevel) == DS_STATE_EMPTY)
				{
					if(gDevilSquare.GetEnterEnabled(lpMsg->ItemLevel) == 0)
					{
						pMsg.RemainTimeH = gDevilSquare.GetRemainTime(lpMsg->ItemLevel);
					}
					else
					{
						pMsg.EnteredUser = gDevilSquare.GetEnteredUserCount(lpMsg->ItemLevel);
					}
				}
				else
				{
					pMsg.RemainTimeH = gDevilSquare.GetRemainTime(lpMsg->ItemLevel);
				}
			}
			break;
		case 2:
			if(BC_LEVEL_RANGE(lpMsg->ItemLevel) != 0)
			{
				if(gBloodCastle.GetState(lpMsg->ItemLevel) == BC_STATE_EMPTY)
				{
					if(gBloodCastle.GetEnterEnabled(lpMsg->ItemLevel) == 0)
					{
						pMsg.RemainTimeH = gBloodCastle.GetRemainTime(lpMsg->ItemLevel);
					}
					else
					{
						pMsg.EnteredUser = gBloodCastle.GetEnteredUserCount(lpMsg->ItemLevel);
					}
				}
				else
				{
					pMsg.RemainTimeH = gBloodCastle.GetRemainTime(lpMsg->ItemLevel);
				}
			}
			break;
		case 4:
			if(CC_LEVEL_RANGE(lpMsg->ItemLevel) != 0)
			{
				if(gChaosCastle.GetState(lpMsg->ItemLevel) == CC_STATE_EMPTY)
				{
					if(gChaosCastle.GetEnterEnabled(lpMsg->ItemLevel) == 0)
					{
						pMsg.RemainTimeL = gChaosCastle.GetRemainTime(lpMsg->ItemLevel);
					}
					else
					{
						pMsg.EnteredUser = gChaosCastle.GetEnteredUserCount(lpMsg->ItemLevel);
					}
				}
				else
				{
					pMsg.RemainTimeL = gChaosCastle.GetRemainTime(lpMsg->ItemLevel);
				}
			}
			break;
		case 5:
			if(IT_LEVEL_RANGE(lpMsg->ItemLevel) != 0)
			{
				if(gIllusionTemple.GetState(lpMsg->ItemLevel) == IT_STATE_EMPTY)
				{
					if(gIllusionTemple.GetEnterEnabled(lpMsg->ItemLevel) == 0)
					{
						pMsg.RemainTimeH = gIllusionTemple.GetRemainTime(lpMsg->ItemLevel);
					}
					else
					{
						pMsg.EnteredUser = gIllusionTemple.GetEnteredUserCount(lpMsg->ItemLevel);
					}
				}
				else
				{
					pMsg.RemainTimeH = gIllusionTemple.GetRemainTime(lpMsg->ItemLevel);
				}
			}
			break;
	}

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void CGPetItemCommandRecv(PMSG_PET_ITEM_COMMAND_RECV* lpMsg,int aIndex) // OK
{
	if(gObjIsConnectedGP(aIndex) == 0)
	{
		return;
	}

	if(lpMsg->type != 0)
	{
		return;
	}

	int bIndex = MAKE_NUMBERW(lpMsg->index[0],lpMsg->index[1]);

	gDarkSpirit[aIndex].ChangeCommand(lpMsg->command,bIndex);
}

void CGPetItemInfoRecv(PMSG_PET_ITEM_INFO_RECV* lpMsg,int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(gObjIsConnectedGP(aIndex) == 0)
	{
		return;
	}

	if(lpMsg->type != 0 && lpMsg->type != 1)
	{
		return;
	}

	if(lpMsg->flag == 0) // Inventory
	{
		if(INVENTORY_RANGE(lpMsg->slot) == 0)
		{
			return;
		}

		GCPetItemInfoSend(aIndex,lpMsg->type,lpMsg->flag,lpMsg->slot,lpObj->Inventory[lpMsg->slot].m_PetItemLevel,lpObj->Inventory[lpMsg->slot].m_PetItemExp,(BYTE)lpObj->Inventory[lpMsg->slot].m_Durability);
	}
	else if(lpMsg->flag == 1) // Warehouse
	{
		if(WAREHOUSE_RANGE(lpMsg->slot) == 0)
		{
			return;
		}

		if(lpObj->LoadWarehouse == 0)
		{
			return;
		}

		GCPetItemInfoSend(aIndex,lpMsg->type,lpMsg->flag,lpMsg->slot,lpObj->Warehouse[lpMsg->slot].m_PetItemLevel,lpObj->Warehouse[lpMsg->slot].m_PetItemExp,(BYTE)lpObj->Warehouse[lpMsg->slot].m_Durability);
	}
	else if(lpMsg->flag == 2) // Trade
	{
		if(TRADE_RANGE(lpMsg->slot) == 0)
		{
			return;
		}

		if(lpObj->Interface.use == 0 || lpObj->Interface.type != INTERFACE_TRADE || lpObj->Interface.state == 0)
		{
			return;
		}

		GCPetItemInfoSend(aIndex,lpMsg->type,lpMsg->flag,lpMsg->slot,lpObj->Trade[lpMsg->slot].m_PetItemLevel,lpObj->Trade[lpMsg->slot].m_PetItemExp,(BYTE)lpObj->Trade[lpMsg->slot].m_Durability);
	}
	else if(lpMsg->flag == 3) // Target Trade
	{
		if(TRADE_RANGE(lpMsg->slot) == 0)
		{
			return;
		}

		if(lpObj->Interface.use == 0 || lpObj->Interface.type != INTERFACE_TRADE || lpObj->Interface.state == 0)
		{
			return;
		}

		if(OBJECT_RANGE(lpObj->TargetNumber) == 0)
		{
			return;
		}

		LPOBJ lpTarget = &gObj[lpObj->TargetNumber];

		if(lpTarget->Interface.use == 0 || lpTarget->Interface.type != INTERFACE_TRADE || lpTarget->Interface.state == 0)
		{
			return;
		}

		GCPetItemInfoSend(aIndex,lpMsg->type,lpMsg->flag,lpMsg->slot,lpTarget->Trade[lpMsg->slot].m_PetItemLevel,lpTarget->Trade[lpMsg->slot].m_PetItemExp,(BYTE)lpTarget->Trade[lpMsg->slot].m_Durability);
	}
	else if(lpMsg->flag == 4) // Chaos Box
	{
		if(CHAOS_BOX_RANGE(lpMsg->slot) == 0)
		{
			return;
		}

		GCPetItemInfoSend(aIndex,lpMsg->type,lpMsg->flag,lpMsg->slot,lpObj->ChaosBox[lpMsg->slot].m_PetItemLevel,lpObj->ChaosBox[lpMsg->slot].m_PetItemExp,(BYTE)lpObj->ChaosBox[lpMsg->slot].m_Durability);
	}
	else if(lpMsg->flag == 5) // Target Personal Shop
	{
		if(INVENTORY_SHOP_RANGE(lpMsg->slot) == 0)
		{
			return;
		}

		if(OBJECT_RANGE(lpObj->PShopDealerIndex) == 0)
		{
			return;
		}

		LPOBJ lpTarget = &gObj[lpObj->PShopDealerIndex];

		GCPetItemInfoSend(aIndex,lpMsg->type,lpMsg->flag,lpMsg->slot,lpTarget->Inventory[lpMsg->slot].m_PetItemLevel,lpTarget->Inventory[lpMsg->slot].m_PetItemExp,(BYTE)lpTarget->Inventory[lpMsg->slot].m_Durability);
	}
}

void CGMapServerMoveAuthRecv(PMSG_MAP_SERVER_MOVE_AUTH_RECV* lpMsg,int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Connected != OBJECT_CONNECTED)
	{
		CloseClient(aIndex);
		return;
	}

	if(memcmp(gServerInfo.m_ServerVersion,lpMsg->ClientVersion,sizeof(lpMsg->ClientVersion)) != 0)
	{
		GCMapServerMoveAuthSend(aIndex,6);
		return;
	}

	if(memcmp(gServerInfo.m_ServerSerial,lpMsg->ClientSerial,sizeof(lpMsg->ClientSerial)) != 0)
	{
		GCMapServerMoveAuthSend(aIndex,6);
		return;
	}

	if(lpObj->LoginMessageSend == 0)
	{
		lpObj->LoginMessageSend++;
		lpObj->LoginMessageCount++;
		lpObj->ConnectTickCount = GetTickCount();
		lpObj->ClientTickCount = lpMsg->TickCount;
		lpObj->ServerTickCount = GetTickCount();

		char account[11] = {0};

		PacketArgumentDecrypt(account,lpMsg->account,sizeof(account));

		lpObj->MapServerMoveRequest = 1;

		GJMapServerMoveAuthSend(aIndex,account,lpMsg->name,lpMsg->AuthCode1,lpMsg->AuthCode2,lpMsg->AuthCode3,lpMsg->AuthCode4);
	}
}

void CGMoveRecv(PMSG_MOVE_RECV* lpMsg,int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(gObjIsConnectedGS(aIndex) == 0)
	{
		return;
	}

	if(lpObj->RegenOk > 0)
	{
		return;
	}

	if(lpObj->Teleport != 0)
	{
		return;
	}

	if(gObjCheckMapTile(lpObj,1) != 0)
	{
		return;
	}

	if((GetTickCount()-lpObj->LastMoveTime) < 100)
	{
		return;
	}

	if(gEffectManager.CheckStunEffect(lpObj) != 0 || gEffectManager.CheckImmobilizeEffect(lpObj) != 0)
	{
		return;
	}

	if(lpObj->SkillSummonPartyTime != 0)
	{
		lpObj->SkillSummonPartyTime = 0;
		gNotice.GCNoticeSend(lpObj->Index,1,0,0,0,0,0,gMessage.GetMessage(272));
	}

	lpObj->Dir = lpMsg->path[0] >> 4;
	lpObj->Rest = 0;
	lpObj->PathCur = 0;
	lpObj->PathCount = lpMsg->path[0] & 0x0F;
	lpObj->LastMoveTime = GetTickCount();

	memset(lpObj->PathX,0,sizeof(lpObj->PathX));

	memset(lpObj->PathY,0,sizeof(lpObj->PathY));

	memset(lpObj->PathOri,0,sizeof(lpObj->PathOri));

	lpObj->TX = lpMsg->x;
	lpObj->TY = lpMsg->y;
	lpObj->PathCur = ((lpObj->PathCount>0)?1:0);
	lpObj->PathCount = ((lpObj->PathCount>0)?(lpObj->PathCount+1):lpObj->PathCount);
	lpObj->PathStartEnd = 1;
	lpObj->PathX[0] = lpMsg->x;
	lpObj->PathY[0] = lpMsg->y;
	lpObj->PathDir[0] = lpObj->Dir;

	for(int n=1;n < lpObj->PathCount;n++)
	{
		if((n%2) == 0)
		{
			lpObj->TX = lpObj->PathX[n-1]+RoadPathTable[((lpMsg->path[((n+1)/2)] & 0x0F)*2)+0];
			lpObj->TY = lpObj->PathY[n-1]+RoadPathTable[((lpMsg->path[((n+1)/2)] & 0x0F)*2)+1];
			lpObj->PathX[n] = lpObj->PathX[n-1]+RoadPathTable[((lpMsg->path[((n+1)/2)] & 0x0F)*2)+0];
			lpObj->PathY[n] = lpObj->PathY[n-1]+RoadPathTable[((lpMsg->path[((n+1)/2)] & 0x0F)*2)+1];
			lpObj->PathOri[n-1] = lpMsg->path[((n+1)/2)] & 0x0F;
			lpObj->PathDir[n+0] = lpMsg->path[((n+1)/2)] & 0x0F;
		}
		else
		{
			lpObj->TX = lpObj->PathX[n-1]+RoadPathTable[((lpMsg->path[((n+1)/2)] / 0x10)*2)+0];
			lpObj->TY = lpObj->PathY[n-1]+RoadPathTable[((lpMsg->path[((n+1)/2)] / 0x10)*2)+1];
			lpObj->PathX[n] = lpObj->PathX[n-1]+RoadPathTable[((lpMsg->path[((n+1)/2)] / 0x10)*2)+0];
			lpObj->PathY[n] = lpObj->PathY[n-1]+RoadPathTable[((lpMsg->path[((n+1)/2)] / 0x10)*2)+1];
			lpObj->PathOri[n-1] = lpMsg->path[((n+1)/2)] / 0x10;
			lpObj->PathDir[n+0] = lpMsg->path[((n+1)/2)] / 0x10;
		}
	}

	if(lpObj->TX < (lpObj->X-15) || lpObj->TX > (lpObj->X+15) || lpObj->TY < (lpObj->Y-15) || lpObj->TY > (lpObj->Y+15))
	{
		lpObj->PathCur = 0;
		lpObj->PathCount = 0;
		lpObj->PathStartEnd = 0;
		memset(lpObj->PathX,0,sizeof(lpObj->PathX));
		memset(lpObj->PathY,0,sizeof(lpObj->PathY));
		memset(lpObj->PathOri,0,sizeof(lpObj->PathOri));
		gObjSetPosition(lpObj->Index,lpObj->X,lpObj->Y);
		return;
	}
	
	if(lpObj->PathCount > 0 && (gMap[lpObj->Map].CheckAttr(lpObj->TX,lpObj->TY,4) != 0 || gMap[lpObj->Map].CheckAttr(lpObj->TX,lpObj->TY,8) != 0))
	{
		lpObj->PathCur = 0;
		lpObj->PathCount = 0;
		lpObj->PathStartEnd = 0;
		memset(lpObj->PathX,0,sizeof(lpObj->PathX));
		memset(lpObj->PathY,0,sizeof(lpObj->PathY));
		memset(lpObj->PathOri,0,sizeof(lpObj->PathOri));
		gObjSetPosition(lpObj->Index,lpObj->X,lpObj->Y);
		return;
	}

	gMap[lpObj->Map].DelStandAttr(lpObj->OldX,lpObj->OldY);

	lpObj->X = lpMsg->x;
	lpObj->Y = lpMsg->y;
	lpObj->TX = lpObj->TX;
	lpObj->TY = lpObj->TY;
	lpObj->OldX = lpObj->TX;
	lpObj->OldY = lpObj->TY;
	lpObj->ViewState = 0;

	gMap[lpObj->Map].SetStandAttr(lpObj->TX,lpObj->TY);

	PMSG_MOVE_SEND pMsg;

	pMsg.header.set(PROTOCOL_CODE1,sizeof(pMsg));

	pMsg.index[0] = SET_NUMBERHB(aIndex);

	pMsg.index[1] = SET_NUMBERLB(aIndex);

	pMsg.x = (BYTE)lpObj->TX;

	pMsg.y = (BYTE)lpObj->TY;

	pMsg.dir = lpObj->Dir << 4;

	if(lpObj->Type == OBJECT_USER)
	{
		DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
	}

	for(int n=0;n < MAX_VIEWPORT;n++)
	{
		if(lpObj->VpPlayer2[n].type == OBJECT_USER)
		{
			if(lpObj->VpPlayer2[n].state != OBJECT_EMPTY && lpObj->VpPlayer2[n].state != OBJECT_DIECMD && lpObj->VpPlayer2[n].state != OBJECT_DIED)
			{
				DataSend(lpObj->VpPlayer2[n].index,(BYTE*)&pMsg,pMsg.header.size);
			}
		}
	}
}
void CGConnectAccountRecv(PMSG_CONNECT_ACCOUNT_RECV* lpMsg,int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Connected != OBJECT_CONNECTED)
	{
		CloseClient(aIndex);
		return;
	}

	if(memcmp(gServerInfo.m_ServerVersion,lpMsg->ClientVersion,sizeof(lpMsg->ClientVersion)) != 0)
	{
		GCConnectAccountSend(aIndex,6);
		return;
	}

	if(memcmp(gServerInfo.m_ServerSerial,lpMsg->ClientSerial,sizeof(lpMsg->ClientSerial)) != 0)
	{
		GCConnectAccountSend(aIndex,6);
		return;
	}

#if(OFFLINE_MODE == TRUE)
	char account[11] = { 0 };
	PacketArgumentDecrypt(account, lpMsg->account, (sizeof(account) - 1));

	char password[11] = { 0 };
	PacketArgumentDecrypt(password, lpMsg->password, (sizeof(password) - 1));

	for (int i = OBJECT_START_USER; i < MAX_OBJECT; i++)
	{
		LPOBJ sObj = &gObj[i];
		if (sObj->Connected == OBJECT_ONLINE)
		{
			if (account[0] == sObj->Account[0])
			{
				if (!strncmp(account, sObj->Account, 10))
				{
				if (sObj->m_OfflineMode == 1)
					{
						sObj->m_OfflineMode = 0;
						gObjDel(i);
					}

#if USE_FAKE_ONLINE == TRUE
					if (sObj->IsFakeOnline == 1)
					{
						s_FakeOnline.OnAttackAlreadyConnected(&gObj[i]);
						gObjDel(i); 
					}
#endif

					break;
				}
			}
		}
	}

	if (lpObj->LoginMessageSend == 0)
	{
		lpObj->LoginMessageSend++;
		lpObj->LoginMessageCount++;
		lpObj->ConnectTickCount = GetTickCount();
		lpObj->ClientTickCount = lpMsg->TickCount;
		lpObj->ServerTickCount = GetTickCount();

		lpObj->MapServerMoveRequest = 0;
		lpObj->LastServerCode = -1;
		lpObj->DestMap = -1;
		lpObj->DestX = 0;
		lpObj->DestY = 0;

		GJConnectAccountSend(aIndex, account, password, lpObj->IpAddr);
	}

#else

	if (lpObj->LoginMessageSend == 0)
	{
		lpObj->LoginMessageSend++;
		lpObj->LoginMessageCount++;
		lpObj->ConnectTickCount = GetTickCount();
		lpObj->ClientTickCount = lpMsg->TickCount;
		lpObj->ServerTickCount = GetTickCount();

		char account[11] = { 0 };

		PacketArgumentDecrypt(account, lpMsg->account, (sizeof(account) - 1));

		char password[11] = { 0 };

		PacketArgumentDecrypt(password, lpMsg->password, (sizeof(password) - 1));

		lpObj->MapServerMoveRequest = 0;
		lpObj->LastServerCode = -1;
		lpObj->DestMap = -1;
		lpObj->DestX = 0;
		lpObj->DestY = 0;

		GJConnectAccountSend(aIndex, account, password, lpObj->IpAddr);
	}

#endif
}

void CGCloseClientRecv(PMSG_CLOSE_CLIENT_RECV* lpMsg,int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Connected != OBJECT_LOGGED && lpObj->Connected != OBJECT_ONLINE)
	{
		return;
	}

	gObjectManager.CharacterGameCloseSet(aIndex,lpMsg->type);
}

void CGCharacterListRecv(int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Connected != OBJECT_LOGGED)
	{
		return;
	}

	GDCharacterListSend(aIndex);
}

void CGCharacterCreateRecv(PMSG_CHARACTER_CREATE_RECV* lpMsg,int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Connected != OBJECT_LOGGED)
	{
		return;
	}

	PMSG_CHARACTER_CREATE_SEND pMsg;

	pMsg.header.set(0xF3,0x01,sizeof(pMsg));

	pMsg.result = 0;

	memcpy(pMsg.name,lpMsg->name,sizeof(pMsg.name));

	if(gServerInfo.m_CharacterCreateSwitch == 0)
	{
		DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
		return;
	}

	if(lpMsg->Class != DB_CLASS_DW && lpMsg->Class != DB_CLASS_DK && lpMsg->Class != DB_CLASS_FE && lpMsg->Class != DB_CLASS_MG && lpMsg->Class != DB_CLASS_DL && lpMsg->Class != DB_CLASS_SU && lpMsg->Class != DB_CLASS_RF)
	{
		DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
		return;
	}

	if(lpMsg->Class == DB_CLASS_SU && (lpObj->ClassCode & 1) == 0)
	{
		DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
		return;
	}

	if(lpMsg->Class == DB_CLASS_MG && (lpObj->ClassCode & 4) == 0)
	{
		DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
		return;
	}

	if(lpMsg->Class == DB_CLASS_DL && (lpObj->ClassCode & 2) == 0)
	{
		DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
		return;
	}

	if(lpMsg->Class == DB_CLASS_RF && (lpObj->ClassCode & 8) == 0)
	{
		DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
		return;
	}

	char name[11] = {0};

	memcpy(name,lpMsg->name,sizeof(lpMsg->name));

	GDCharacterCreateSend(aIndex,name,lpMsg->Class);
}

void CGCharacterDeleteRecv(PMSG_CHARACTER_DELETE_RECV* lpMsg,int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Connected != OBJECT_LOGGED)
	{
		return;
	}

	if(lpObj->EnableDelCharacter == 0)
	{
		return;
	}

	PMSG_CHARACTER_DELETE_SEND pMsg;

	pMsg.header.set(0xF3,0x02,sizeof(pMsg));

	pMsg.result = 0;

	if(gObjCheckPersonalCode(aIndex,lpMsg->PersonalCode) == 0)
	{
		pMsg.result = 2;
		DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
		return;
	}

	//itemLock
	if(lpObj->Lock > 0)
	{
		gNotice.GCNoticeSend(lpObj->Index,1,0,0,0,2,0,gMessage.GetMessage(778));
		pMsg.result = 2;
		DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
		return;
	}

	char name[11] = {0};

	memcpy(name,lpMsg->name,sizeof(lpMsg->name));

	GDCharacterDeleteSend(aIndex,name);
}

void CGCharacterInfoRecv(PMSG_CHARACTER_INFO_RECV* lpMsg,int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Connected != OBJECT_LOGGED)
	{
		return;
	}

	lpObj->EnableDelCharacter = 0;
	
	char name[11] = {0};

	memcpy(name,lpMsg->name,sizeof(lpMsg->name));

	GDCharacterInfoSend(aIndex,name);
}

void CGLevelUpPointRecv(PMSG_LEVEL_UP_POINT_RECV* lpMsg,int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(gObjIsConnectedGP(aIndex) == 0)
	{
		return;
	}

	PMSG_LEVEL_UP_POINT_SEND pMsg;

	pMsg.header.set(0xF3,0x06,sizeof(pMsg));

	pMsg.result = 0;
	
	if(gObjectManager.CharacterLevelUpPointAdd(lpObj,lpMsg->type,1) != 0)
	{
		pMsg.result = 16+lpMsg->type;

		switch(lpMsg->type)
		{
			case 2: // Vitality
				pMsg.MaxLifeAndMana = GET_MAX_WORD_VALUE((lpObj->MaxLife+lpObj->AddLife));
				break;
			case 3: // Energy
				pMsg.MaxLifeAndMana = GET_MAX_WORD_VALUE((lpObj->MaxMana+lpObj->AddMana));
				break;
		}

		pMsg.MaxBP = GET_MAX_WORD_VALUE((lpObj->MaxBP+lpObj->AddBP));

		pMsg.MaxShield = GET_MAX_WORD_VALUE((lpObj->MaxShield+lpObj->AddShield));

		#if(GAMESERVER_EXTRA==1)
		pMsg.ViewPoint = (DWORD)(lpObj->LevelUpPoint);
		pMsg.ViewMaxHP = (DWORD)(lpObj->MaxLife+lpObj->AddLife);
		pMsg.ViewMaxMP = (DWORD)(lpObj->MaxMana+lpObj->AddMana);
		pMsg.ViewMaxBP = (DWORD)(lpObj->MaxBP+lpObj->AddBP);
		pMsg.ViewMaxSD = (DWORD)(lpObj->MaxShield+lpObj->AddShield);
		pMsg.ViewStrength = lpObj->Strength;
		pMsg.ViewDexterity = lpObj->Dexterity;
		pMsg.ViewVitality = lpObj->Vitality;
		pMsg.ViewEnergy = lpObj->Energy;
		pMsg.ViewLeadership = lpObj->Leadership;
		#endif
	}

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void CGCharacterMoveViewportEnableRecv(int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(gObjIsConnectedGP(aIndex) == 0)
	{
		return;
	}

	lpObj->RegenOk = ((lpObj->RegenOk==1)?2:lpObj->RegenOk);
}

void CGCharacterNameCheckRecv(PMSG_CHARACTER_NAME_CHECK_RECV* lpMsg,int aIndex) // OK
{
	#if(GAMESERVER_UPDATE>=401)

	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Connected != OBJECT_LOGGED)
	{
		return;
	}

	char name[11] = {0};

	memcpy(name,lpMsg->name,sizeof(lpMsg->name));

	GDCharacterNameCheckSend(aIndex,name);

	#endif
}

void CGCharacterNameChangeRecv(PMSG_CHARACTER_NAME_CHANGE_RECV* lpMsg,int aIndex) // OK
{
	#if(GAMESERVER_UPDATE>=401)

	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Connected != OBJECT_LOGGED)
	{
		return;
	}

	char OldName[11] = {0};

	char NewName[11] = {0};

	memcpy(OldName,lpMsg->OldName,sizeof(lpMsg->OldName));

	memcpy(NewName,lpMsg->NewName,sizeof(lpMsg->NewName));

	GDCharacterNameChangeSend(aIndex,OldName,NewName);

	#endif
}

void CGOptionChangeSkinRecv(PMSG_OPTION_CHANGE_SKIN_RECV* lpMsg,int aIndex) // OK
{
	#if(GAMESERVER_UPDATE>=701)

	LPOBJ lpObj = &gObj[aIndex];

	if(gObjIsConnected(aIndex) == 0)
	{
		return;
	}

	lpObj->ChangeSkin = lpMsg->ChangeSkin;

	gObjViewportListProtocolCreate(lpObj);

	gObjectManager.CharacterUpdateMapEffect(lpObj);

	#endif
}

void CGOptionDataRecv(PMSG_OPTION_DATA_RECV* lpMsg,int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(gObjIsConnected(aIndex) == 0)
	{
		return;
	}

	if (lpObj->RenameActive == 0)
	{
		GDOptionDataSaveSend(aIndex,lpMsg->SkillKey,lpMsg->GameOption,lpMsg->QKey,lpMsg->WKey,lpMsg->EKey,lpMsg->ChatWindow,lpMsg->RKey,ntohl(lpMsg->QWERLevel));
	}
}

void CGClientSecurityBreachRecv(PMSG_CLIENT_SECURITY_BREACH_RECV* lpMsg,int aIndex) // OK
{
	#if(GAMESERVER_UPDATE>=701)

	LPOBJ lpObj = &gObj[aIndex];

	if(gObjIsConnected(aIndex) == 0)
	{
		return;
	}

	gLog.Output(LOG_HACK,"[ClientSecurityBreach][%s][%s] (Code: %d)",lpObj->Account,lpObj->Name,MAKE_NUMBERDW(MAKE_NUMBERW(lpMsg->code[0],lpMsg->code[1]),MAKE_NUMBERW(lpMsg->code[2],lpMsg->code[3])));

	#endif
}

void CGAcheronEnterRecv(int aIndex) // OK
{
	#if(GAMESERVER_UPDATE>=701)

	LPOBJ lpObj = &gObj[aIndex];

	if(gObjIsConnectedGP(aIndex) == 0)
	{
		return;
	}

	PMSG_ACHERON_ENTER_SEND pMsg;

	pMsg.header.set(0xF8,0x21,sizeof(pMsg));

	if(gItemManager.GetInventoryItemCount(lpObj,GET_ITEM(13,146),0) == 0)
	{
		pMsg.result = 1;
		DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
		return;
	}

	gItemManager.DeleteInventoryItemCount(lpObj,GET_ITEM(13,146),0,1);

	gObjMoveGate(aIndex,417);

	#endif
}

void CGSNSDataRecv(PMSG_SNS_DATA_RECV* lpMsg,int aIndex) // OK
{
	#if(GAMESERVER_UPDATE>=801)

	LPOBJ lpObj = &gObj[aIndex];

	if(gObjIsConnectedGP(aIndex) == 0)
	{
		return;
	}

	GDSNSDataSaveSend(aIndex,lpMsg->data);

	#endif
}

void CGSNSDataLogRecv(PMSG_SNS_DATA_LOG_RECV* lpMsg,int aIndex) // OK
{
	#if(GAMESERVER_UPDATE>=801)

	LPOBJ lpObj = &gObj[aIndex];

	if(gObjIsConnectedGP(aIndex) == 0)
	{
		return;
	}

	//LogAdd(LOG_BLACK,"[SNSDataLog][%s][%s] - (Code: %d/%d/%d)",lpObj->Account,lpObj->Name,lpMsg->code[0],lpMsg->code[1],lpMsg->code[2]);

	#endif
}

void GCChatTargetSend(LPOBJ lpObj,int aIndex,char* message) // OK
{
	int size = strlen(message);

	size = ((size>MAX_CHAT_MESSAGE_SIZE)?MAX_CHAT_MESSAGE_SIZE:size);

	PMSG_CHAT_TARGET_SEND pMsg;

	pMsg.header.set(0x01,(sizeof(pMsg)-(sizeof(pMsg.message)-(size+1))));

	pMsg.index[0] = SET_NUMBERHB(aIndex);

	pMsg.index[1] = SET_NUMBERLB(aIndex);

	memcpy(pMsg.message,message,size);

	pMsg.message[size] = 0;

	DataSend(lpObj->Index,(BYTE*)&pMsg,pMsg.header.size);
}

void GCChatTargetNewSend(LPOBJ lpObj,int aIndex,char* message,...) // OK
{
	char buff[256] = {0};

	va_list arg;
	va_start(arg,message);
	vsprintf_s(buff,message,arg);
	va_end(arg);

	int size = strlen(buff);

	size = ((size>MAX_CHAT_MESSAGE_SIZE)?MAX_CHAT_MESSAGE_SIZE:size);

	PMSG_CHAT_TARGET_SEND pMsg;

	pMsg.header.set(0x01,(sizeof(pMsg)-(sizeof(pMsg.message)-(size+1))));

	pMsg.index[0] = SET_NUMBERHB(aIndex);

	pMsg.index[1] = SET_NUMBERLB(aIndex);

	memcpy(pMsg.message,buff,size);

	pMsg.message[size] = 0;

	DataSend(lpObj->Index,(BYTE*)&pMsg,pMsg.header.size);
}

//채팅
void GCChatWhisperSend(int aIndex,char* name,char* message) // OK
{
	int size = strlen(message);

	size = ((size>MAX_CHAT_MESSAGE_SIZE)?MAX_CHAT_MESSAGE_SIZE:size);

	PMSG_CHAT_WHISPER_SEND pMsg;

	pMsg.header.set(0x02,(sizeof(pMsg)-(sizeof(pMsg.message)-(size+1))));

	memcpy(pMsg.name,name,sizeof(pMsg.name));

	memcpy(pMsg.message,message,size);

	pMsg.message[size] = 0;

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCMainCheckSend(int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	lpObj->CheckSumTableNum = GetLargeRand()%MAX_CHECKSUM_KEY;

	lpObj->CheckSumTime = GetTickCount();

	PMSG_MAIN_CHECK_SEND pMsg;

	pMsg.header.set(0x03,sizeof(pMsg));

	pMsg.key = (((GetLargeRand()%64)*16) | ((lpObj->CheckSumTableNum & 0x3F0)*64) | ((lpObj->CheckSumTableNum & 0x0F)) ^ 0xB479);

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCEventStateSend(int aIndex,BYTE state,BYTE event) // OK
{
	PMSG_EVENT_STATE_SEND pMsg;

	pMsg.header.set(0x0B,sizeof(pMsg));

	pMsg.state = state;
	
	pMsg.event = event;

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCEventStateSendToAll(BYTE state,BYTE event) // OK
{
	PMSG_EVENT_STATE_SEND pMsg;

	pMsg.header.set(0x0B,sizeof(pMsg));

	pMsg.state = state;
	
	pMsg.event = event;

	DataSendAll((BYTE*)&pMsg,pMsg.header.size);
}

void GCServerMsgSend(int aIndex,BYTE msg) // OK
{
	PMSG_SERVER_MSG_SEND pMsg;

	pMsg.header.set(0x0C,sizeof(pMsg));

	pMsg.MsgNumber = msg;

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCWeatherSend(int aIndex,BYTE weather) // OK
{
	PMSG_WEATHER_SEND pMsg;

	pMsg.header.set(0x0F,sizeof(pMsg));
	
	pMsg.weather = weather;

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCDamageSend(int aIndex,int bIndex,BYTE flag,int damage,int type,int ShieldDamage) // OK
{
	PMSG_DAMAGE_SEND pMsg;

	pMsg.header.set(PROTOCOL_CODE2,sizeof(pMsg));

	pMsg.index[0] = SET_NUMBERHB(bIndex) | (flag*0x80);
	pMsg.index[1] = SET_NUMBERLB(bIndex);

	pMsg.damage[0] = SET_NUMBERHB(GET_MAX_WORD_VALUE(damage));
	pMsg.damage[1] = SET_NUMBERLB(GET_MAX_WORD_VALUE(damage));

	#if(GAMESERVER_UPDATE>=701)

	pMsg.type[0] = SET_NUMBERHB(type);
	pMsg.type[1] = SET_NUMBERLB(type);

	#else

	pMsg.type = type;

	#endif

	pMsg.ShieldDamage[0] = SET_NUMBERHB(GET_MAX_WORD_VALUE(ShieldDamage));
	pMsg.ShieldDamage[1] = SET_NUMBERLB(GET_MAX_WORD_VALUE(ShieldDamage));

	#if(GAMESERVER_UPDATE>=701)

	pMsg.attribute = 0;

	#endif

	#if(GAMESERVER_EXTRA==1)
	pMsg.ViewCurHP = (DWORD)gObj[bIndex].Life;
	pMsg.ViewCurSD = (DWORD)gObj[bIndex].Shield;
	pMsg.ViewDamageHP = damage;
	pMsg.ViewDamageSD = ShieldDamage;
	#endif

	if(gObj[aIndex].Type == OBJECT_USER)
	{
		DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
	}

	if(gObj[bIndex].Type == OBJECT_USER)
	{
		DataSend(bIndex,(BYTE*)&pMsg,pMsg.header.size);
	}
}

void GCUserDieSend(LPOBJ lpObj,int aIndex,int skill,int bIndex) // OK
{
	PMSG_USER_DIE_SEND pMsg;

	pMsg.header.set(0x17,sizeof(pMsg));

	pMsg.index[0] = SET_NUMBERHB(aIndex);
	pMsg.index[1] = SET_NUMBERLB(aIndex);

	pMsg.skill[0] = SET_NUMBERHB(skill);
	pMsg.skill[1] = SET_NUMBERLB(skill);

	pMsg.killer[0] = SET_NUMBERHB(bIndex);
	pMsg.killer[1] = SET_NUMBERLB(bIndex);

	if(lpObj->Type == OBJECT_USER)
	{

		DataSend(lpObj->Index,(BYTE*)&pMsg,pMsg.header.size);
	}

	MsgSendV2(lpObj,(BYTE*)&pMsg,pMsg.header.size);
}

void GCActionSend(LPOBJ lpObj,BYTE action,int aIndex,int bIndex) // OK
{
	PMSG_ACTION_SEND pMsg;

	pMsg.header.set(0x18,sizeof(pMsg));

	pMsg.index[0] = SET_NUMBERHB(aIndex);

	pMsg.index[1] = SET_NUMBERLB(aIndex);

	pMsg.dir = lpObj->Dir;

	pMsg.action = action;

	pMsg.target[0] = SET_NUMBERHB(bIndex);

	pMsg.target[1] = SET_NUMBERLB(bIndex);

	MsgSendV2(lpObj,(BYTE*)&pMsg,pMsg.header.size);
}

void GCMoneySend(int aIndex,DWORD money) // OK
{
	PMSG_ITEM_GET_SEND pMsg;

	pMsg.header.setE(0x22,sizeof(pMsg));

	pMsg.result = 0xFE;

	memset(pMsg.ItemInfo,0,sizeof(pMsg.ItemInfo));

	pMsg.ItemInfo[0] = SET_NUMBERHB(SET_NUMBERHW(money));
	pMsg.ItemInfo[1] = SET_NUMBERLB(SET_NUMBERHW(money));
	pMsg.ItemInfo[2] = SET_NUMBERHB(SET_NUMBERLW(money));
	pMsg.ItemInfo[3] = SET_NUMBERLB(SET_NUMBERLW(money));

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCLifeSend(int aIndex,BYTE type,int life,int shield) // OK
{
	PMSG_LIFE_SEND pMsg;

	pMsg.header.set(0x26,sizeof(pMsg));

	pMsg.type = type;

	pMsg.life[0] = SET_NUMBERHB(GET_MAX_WORD_VALUE(life));
	pMsg.life[1] = SET_NUMBERLB(GET_MAX_WORD_VALUE(life));

	pMsg.flag = 0;

	pMsg.shield[0] = SET_NUMBERHB(GET_MAX_WORD_VALUE(shield));
	pMsg.shield[1] = SET_NUMBERLB(GET_MAX_WORD_VALUE(shield));

	#if(GAMESERVER_EXTRA==1)
	pMsg.ViewHP = life;
	pMsg.ViewSD = shield;
	#endif

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCManaSend(int aIndex,BYTE type,int mana,int bp) // OK
{
	PMSG_MANA_SEND pMsg;

	pMsg.header.set(0x27,sizeof(pMsg));

	pMsg.type = type;

	pMsg.mana[0] = SET_NUMBERHB(GET_MAX_WORD_VALUE(mana));
	pMsg.mana[1] = SET_NUMBERLB(GET_MAX_WORD_VALUE(mana));

	pMsg.bp[0] = SET_NUMBERHB(GET_MAX_WORD_VALUE(bp));
	pMsg.bp[1] = SET_NUMBERLB(GET_MAX_WORD_VALUE(bp));

	#if(GAMESERVER_EXTRA==1)
	pMsg.ViewMP = mana;
	pMsg.ViewBP = bp;
	#endif

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCItemUseSpecialTimeSend(int aIndex,BYTE number,int time) // OK
{
	PMSG_ITEM_SPECIAL_TIME_SEND pMsg;

	pMsg.header.setE(0x29,sizeof(pMsg));

	pMsg.number = number;

	pMsg.time = time;

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCMapAttrSend(int aIndex,BYTE type,BYTE attr,BYTE flag,BYTE count,PMSG_MAP_ATTR* lpInfo) // OK
{
	BYTE send[256];

	PMSG_MAP_ATTR_SEND pMsg;

	pMsg.header.set(0x46,0);

	int size = sizeof(pMsg);

	pMsg.type = type;

	pMsg.attr = attr;

	pMsg.flag = flag;

	pMsg.count = count;

	PMSG_MAP_ATTR info;

	for(int n=0;n < count;n++)
	{
		info.x = lpInfo[n].x;
		info.y = lpInfo[n].y;
		info.tx = lpInfo[n].tx;
		info.ty = lpInfo[n].ty;

		memcpy(&send[size],&info,sizeof(info));
		size += sizeof(info);
	}

	pMsg.header.size = size;

	memcpy(send,&pMsg,sizeof(pMsg));

	DataSend(aIndex,send,size);
}

void GCPartyItemInfoSend(int aIndex,CItem* lpItem) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(OBJECT_RANGE(lpObj->PartyNumber) == 0)
	{
		return;
	}

	PMSG_PARTY_ITEM_INFO_SEND pMsg;

	pMsg.header.set(0x47,sizeof(pMsg));

	pMsg.index[0] = SET_NUMBERHB(aIndex);
	pMsg.index[1] = SET_NUMBERLB(aIndex);

	pMsg.ItemInfo = lpItem->m_Index & 0x1FFF;

	if(lpItem->m_Option1 != 0)
	{
		pMsg.ItemInfo |= 0x2000;
	}

	if(lpItem->m_Option2 != 0)
	{
		pMsg.ItemInfo |= 0x4000;
	}

	if(lpItem->m_Option3 != 0)
	{
		pMsg.ItemInfo |= 0x8000;
	}

	if(lpItem->IsExcItem() != 0)
	{
		pMsg.ItemInfo |= 0x10000;
	}

	if(lpItem->IsSetItem() != 0)
	{
		pMsg.ItemInfo |= 0x20000;
	}

	if(lpItem->Is380Item() != 0)
	{
		pMsg.ItemInfo |= 0x40000;
	}

	pMsg.level = (BYTE)lpItem->m_Level;

	for(int n=0;n < MAX_PARTY_USER;n++)
	{
		int index = gParty.m_PartyInfo[lpObj->PartyNumber].Index[n];

		if(OBJECT_RANGE(index) != 0)
		{
			DataSend(index,(BYTE*)&pMsg,pMsg.header.size);
		}
	}
}

void GCEffectInfoSend(int aIndex,BYTE effect) // OK
{
	PMSG_EFFECT_INFO_SEND pMsg;

	pMsg.header.set(0x48,sizeof(pMsg));

	pMsg.index[0] = SET_NUMBERHB(aIndex);
	pMsg.index[1] = SET_NUMBERLB(aIndex);

	pMsg.effect = effect;

	if(effect == 17)
	{
		DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
	}

	MsgSendV2(&gObj[aIndex],(BYTE*)&pMsg,pMsg.header.size);
}

void GCGuildMasterQuestionSend(int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Interface.use != 0)
	{
		return;
	}

	PBMSG_HEAD pMsg;

	pMsg.set(0x54,sizeof(pMsg));

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.size);
}

void GCMonsterSkillSend(LPOBJ lpObj,LPOBJ lpTarget,int skill) // OK
{
	PMSG_MONSTER_SKILL_SEND pMsg;

	pMsg.header.set(0x69,sizeof(pMsg));

	pMsg.skill[0] = SET_NUMBERHB(skill);
	pMsg.skill[1] = SET_NUMBERLB(skill);

	pMsg.index = lpObj->Index;

	pMsg.target = lpTarget->Index;

	if(lpObj->Index == OBJECT_USER)
	{
		DataSend(lpObj->Index,(BYTE*)&pMsg,pMsg.header.size);
	}

	MsgSendV2(lpObj,(BYTE*)&pMsg,pMsg.header.size);
}

void GCMonsterDieSend(int aIndex,int bIndex,int experience,int damage,BYTE flag) // OK
{
	PMSG_REWARD_EXPERIENCE_SEND pMsg;

	pMsg.header.setE(0x9C,sizeof(pMsg));

	pMsg.index[0] = SET_NUMBERHB(bIndex) | (flag*0x80);
	pMsg.index[1] = SET_NUMBERLB(bIndex);

	pMsg.experience[0] = SET_NUMBERHW(experience);
	pMsg.experience[1] = SET_NUMBERLW(experience);

	pMsg.damage[0] = SET_NUMBERHB(GET_MAX_WORD_VALUE(damage));
	pMsg.damage[1] = SET_NUMBERLB(GET_MAX_WORD_VALUE(damage));

	#if(GAMESERVER_EXTRA==1)
	pMsg.ViewDamageHP = damage;
	#endif

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCRewardExperienceSend(int aIndex,int experience) // OK
{
	PMSG_REWARD_EXPERIENCE_SEND pMsg;

	pMsg.header.setE(0x9C,sizeof(pMsg));

	pMsg.index[0] = 0xFF;
	pMsg.index[1] = 0xFF;

	pMsg.experience[0] = SET_NUMBERHW(experience);
	pMsg.experience[1] = SET_NUMBERLW(experience);

	pMsg.damage[0] = 0;
	pMsg.damage[1] = 0;

	#if(GAMESERVER_EXTRA==1)
	pMsg.ViewDamageHP = 0;
	#endif

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCEventEnterCountSend(int aIndex,BYTE EventType,BYTE EnterCount) // OK
{
	PMSG_EVENT_ENTER_COUNT_SEND pMsg;

	pMsg.header.setE(0x9F,sizeof(pMsg));

	pMsg.EventType = EventType;

	pMsg.EnterCount = EnterCount;

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCPetItemInfoSend(int aIndex,BYTE type,BYTE flag,BYTE slot,BYTE level,DWORD experience,BYTE durability) // OK
{
	PMSG_PET_ITEM_INFO_SEND pMsg;

	pMsg.header.set(0xA9,sizeof(pMsg));

	pMsg.type = type;

	pMsg.flag = flag;

	pMsg.slot = slot;

	pMsg.level = level;

	pMsg.experience = experience;

	#if(GAMESERVER_UPDATE>=401)

	pMsg.durability = durability;

	#endif

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCMapServerMoveAuthSend(int aIndex,BYTE result) // OK
{
	PMSG_MAP_SERVER_MOVE_AUTH_SEND pMsg;

	pMsg.header.set(0xB1,0x01,sizeof(pMsg));

	pMsg.result = result;

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCTaxInfoSend(int aIndex,BYTE type,BYTE rate) // OK
{
	PMSG_TAX_INFO_SEND pMsg;

	pMsg.header.set(0xB2,0x1A,sizeof(pMsg));

	pMsg.type = type;

	pMsg.rate = rate;

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCCreationStateSend(int aIndex,BYTE state) // OK
{
	PMSG_CREATION_STATE_SEND pMsg;

	pMsg.header.set(0xB9,0x01,sizeof(pMsg));

	pMsg.index[0] = SET_NUMBERHB(aIndex);

	pMsg.index[1] = SET_NUMBERLB(aIndex);

	pMsg.state = state;

	MsgSendV2(&gObj[aIndex],(BYTE*)&pMsg,pMsg.header.size);
}

void GCMonsterAreaSkillSend(int aIndex,int MonsterClass,int sx,int sy,int tx,int ty) // OK
{
	PMSG_MONSTER_AREA_SKILL_SEND pMsg;

	pMsg.header.set(0xBD,0x0C,sizeof(pMsg));

	pMsg.MonsterClass[0] = SET_NUMBERHB(MonsterClass);

	pMsg.MonsterClass[1] = SET_NUMBERLB(MonsterClass);

	pMsg.sx = sx;

	pMsg.sy = sy;

	pMsg.tx = tx;

	pMsg.ty = ty;

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCElementalDamageSend(int aIndex,int bIndex,BYTE attribute,int damage) // OK
{
	#if(GAMESERVER_UPDATE>=701)

	PMSG_ELEMENTAL_DAMAGE_SEND pMsg;

	pMsg.header.set(0xD8,sizeof(pMsg));

	pMsg.index[0] = SET_NUMBERHB(bIndex);

	pMsg.index[1] = SET_NUMBERLB(bIndex);

	pMsg.attribute = attribute;

	pMsg.damage = damage;

	#if(GAMESERVER_EXTRA==1)
	pMsg.ViewCurHP = (DWORD)gObj[bIndex].Life;
	pMsg.ViewCurSD = (DWORD)gObj[bIndex].Shield;
	#endif

	if(gObj[aIndex].Type == OBJECT_USER)
	{
		DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
	}

	if(gObj[bIndex].Type == OBJECT_USER)
	{
		DataSend(bIndex,(BYTE*)&pMsg,pMsg.header.size);
	}

	#endif
}

void GCCharacterCreationEnableSend(int aIndex,BYTE flag,BYTE result) // OK
{
	PMSG_CHARACTER_CREATION_ENABLE_SEND pMsg;

	pMsg.header.set(0xDE,sizeof(pMsg));

	pMsg.flag = flag;

	pMsg.result = result;

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCLifeUpdateSend(LPOBJ lpObj) // OK
{
	#if(GAMESERVER_UPDATE>=701)

	if(lpObj->Type != OBJECT_MONSTER)
	{
		return;
	}

	PMSG_LIFE_UPDATE_SEND pMsg;

	pMsg.header.set(0xEC,0x10,sizeof(pMsg));

	pMsg.index[0] = SET_NUMBERHB(lpObj->Index);
	pMsg.index[1] = SET_NUMBERLB(lpObj->Index);

	pMsg.MaxHP[0] = SET_NUMBERHB(SET_NUMBERHW((lpObj->MaxLife+lpObj->AddLife)));
	pMsg.MaxHP[1] = SET_NUMBERHB(SET_NUMBERLW((lpObj->MaxLife+lpObj->AddLife)));
	pMsg.MaxHP[2] = SET_NUMBERLB(SET_NUMBERHW((lpObj->MaxLife+lpObj->AddLife)));
	pMsg.MaxHP[3] = SET_NUMBERLB(SET_NUMBERLW((lpObj->MaxLife+lpObj->AddLife)));

	pMsg.CurHP[0] = SET_NUMBERHB(SET_NUMBERHW((lpObj->Life)));
	pMsg.CurHP[1] = SET_NUMBERHB(SET_NUMBERLW((lpObj->Life)));
	pMsg.CurHP[2] = SET_NUMBERLB(SET_NUMBERHW((lpObj->Life)));
	pMsg.CurHP[3] = SET_NUMBERLB(SET_NUMBERLW((lpObj->Life)));

	MsgSendV2(lpObj,(BYTE*)&pMsg,pMsg.header.size);

	#endif
}

void GCCharacterAttackSpeedSend(LPOBJ lpObj) // OK
{
	#if(GAMESERVER_UPDATE>=801)

	PMSG_CHARACTER_ATTACK_SPEED_SEND pMsg;

	pMsg.header.set(0xEC,0x30,sizeof(pMsg));

	pMsg.PhysiSpeed = lpObj->PhysiSpeed;

	pMsg.MagicSpeed = lpObj->MagicSpeed;

	DataSend(lpObj->Index,(BYTE*)&pMsg,pMsg.header.size);

	#endif
}

void GCConnectClientSend(int aIndex,BYTE result) // OK
{
	PMSG_CONNECT_CLIENT_SEND pMsg;

	pMsg.header.set(0xF1,0x00,sizeof(pMsg));

	pMsg.result = result;

	pMsg.index[0] = SET_NUMBERHB(aIndex);

	pMsg.index[1] = SET_NUMBERLB(aIndex);

	pMsg.ClientVersion[0] = gServerInfo.m_ServerVersion[0];

	pMsg.ClientVersion[1] = gServerInfo.m_ServerVersion[1];

	pMsg.ClientVersion[2] = gServerInfo.m_ServerVersion[2];

	pMsg.ClientVersion[3] = gServerInfo.m_ServerVersion[3];

	pMsg.ClientVersion[4] = gServerInfo.m_ServerVersion[4];

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);

	gObj[aIndex].ConnectTickCount = GetTickCount();
}

void GCConnectAccountSend(int aIndex,BYTE result) // OK
{
	PMSG_CONNECT_ACCOUNT_SEND pMsg;

	pMsg.header.set(0xF1,0x01,sizeof(pMsg));

	pMsg.result = result;

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCConnectAccountSend(int aIndex,BYTE result,SOCKET socket) // OK
{
	PMSG_CONNECT_ACCOUNT_SEND pMsg;

	pMsg.header.set(0xF1,0x01,sizeof(pMsg));

	pMsg.result = result;

	DataSendSocket(socket,(BYTE*)&pMsg,pMsg.header.size);
}

void GCCloseClientSend(int aIndex,BYTE result) // OK
{
	PMSG_CLOSE_CLIENT_SEND pMsg;

	pMsg.header.setE(0xF1,0x02,sizeof(pMsg));

	pMsg.result = result;

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCCharacterRegenSend(LPOBJ lpObj) // OK
{
	PMSG_CHARACTER_REGEN_SEND pMsg;

	pMsg.header.setE(0xF3,0x04,sizeof(pMsg));

	pMsg.X = (BYTE)lpObj->X;

	pMsg.Y = (BYTE)lpObj->Y;

	pMsg.Map = lpObj->Map;

	pMsg.Dir = lpObj->Dir;

	pMsg.Life = GET_MAX_WORD_VALUE(lpObj->Life);

	pMsg.Mana = GET_MAX_WORD_VALUE(lpObj->Mana);

	pMsg.Shield = GET_MAX_WORD_VALUE(lpObj->Shield);

	pMsg.BP = GET_MAX_WORD_VALUE(lpObj->BP);

	if(gMasterSkillTree.CheckMasterLevel(lpObj) == 0)
	{
		pMsg.Experience[0] = SET_NUMBERHB(SET_NUMBERHW(SET_NUMBERHDW(lpObj->Experience)));
		pMsg.Experience[1] = SET_NUMBERLB(SET_NUMBERHW(SET_NUMBERHDW(lpObj->Experience)));
		pMsg.Experience[2] = SET_NUMBERHB(SET_NUMBERLW(SET_NUMBERHDW(lpObj->Experience)));
		pMsg.Experience[3] = SET_NUMBERLB(SET_NUMBERLW(SET_NUMBERHDW(lpObj->Experience)));
		pMsg.Experience[4] = SET_NUMBERHB(SET_NUMBERHW(SET_NUMBERLDW(lpObj->Experience)));
		pMsg.Experience[5] = SET_NUMBERLB(SET_NUMBERHW(SET_NUMBERLDW(lpObj->Experience)));
		pMsg.Experience[6] = SET_NUMBERHB(SET_NUMBERLW(SET_NUMBERLDW(lpObj->Experience)));
		pMsg.Experience[7] = SET_NUMBERLB(SET_NUMBERLW(SET_NUMBERLDW(lpObj->Experience)));
	}
	else
	{
		pMsg.Experience[0] = SET_NUMBERHB(SET_NUMBERHW(SET_NUMBERHDW(lpObj->MasterExperience)));
		pMsg.Experience[1] = SET_NUMBERLB(SET_NUMBERHW(SET_NUMBERHDW(lpObj->MasterExperience)));
		pMsg.Experience[2] = SET_NUMBERHB(SET_NUMBERLW(SET_NUMBERHDW(lpObj->MasterExperience)));
		pMsg.Experience[3] = SET_NUMBERLB(SET_NUMBERLW(SET_NUMBERHDW(lpObj->MasterExperience)));
		pMsg.Experience[4] = SET_NUMBERHB(SET_NUMBERHW(SET_NUMBERLDW(lpObj->MasterExperience)));
		pMsg.Experience[5] = SET_NUMBERLB(SET_NUMBERHW(SET_NUMBERLDW(lpObj->MasterExperience)));
		pMsg.Experience[6] = SET_NUMBERHB(SET_NUMBERLW(SET_NUMBERLDW(lpObj->MasterExperience)));
		pMsg.Experience[7] = SET_NUMBERLB(SET_NUMBERLW(SET_NUMBERLDW(lpObj->MasterExperience)));
	}

	pMsg.Money = lpObj->Money;

	#if(GAMESERVER_EXTRA==1)
	pMsg.ViewCurHP = (DWORD)(lpObj->Life);
	pMsg.ViewCurMP = (DWORD)(lpObj->Mana);
	pMsg.ViewCurBP = (DWORD)(lpObj->BP);
	pMsg.ViewCurSD = (DWORD)(lpObj->Shield);
	#endif

	DataSend(lpObj->Index,(BYTE*)&pMsg,pMsg.header.size);
}

void GCLevelUpSend(LPOBJ lpObj) // OK
{
	PMSG_LEVEL_UP_SEND pMsg;

	pMsg.header.set(0xF3,0x05,sizeof(pMsg));

	pMsg.Level = lpObj->Level;

	pMsg.LevelUpPoint = lpObj->LevelUpPoint;

	pMsg.MaxLife = GET_MAX_WORD_VALUE((lpObj->MaxLife+lpObj->AddLife));

	pMsg.MaxMana = GET_MAX_WORD_VALUE((lpObj->MaxMana+lpObj->AddMana));

	pMsg.MaxShield = GET_MAX_WORD_VALUE((lpObj->MaxShield+lpObj->AddShield));

	pMsg.MaxBP = GET_MAX_WORD_VALUE((lpObj->MaxBP+lpObj->AddBP));

	pMsg.FruitAddPoint = lpObj->FruitAddPoint;

	pMsg.MaxFruitAddPoint = gFruit.GetMaxFruitPoint(lpObj);

	pMsg.FruitSubPoint = lpObj->FruitSubPoint;

	pMsg.MaxFruitSubPoint = gFruit.GetMaxFruitPoint(lpObj);

	#if(GAMESERVER_EXTRA==1)
	pMsg.ViewPoint = (DWORD)(lpObj->LevelUpPoint);
	pMsg.ViewMaxHP = (DWORD)(lpObj->MaxLife+lpObj->AddLife);
	pMsg.ViewMaxMP = (DWORD)(lpObj->MaxMana+lpObj->AddMana);
	pMsg.ViewMaxBP = (DWORD)(lpObj->MaxBP+lpObj->AddBP);
	pMsg.ViewMaxSD = (DWORD)(lpObj->MaxShield+lpObj->AddShield);
	pMsg.ViewExperience = lpObj->Experience;
	pMsg.ViewNextExperience = lpObj->NextExperience;
	#endif

	DataSend(lpObj->Index,(BYTE*)&pMsg,pMsg.header.size);

	GCEffectInfoSend(lpObj->Index,16);
}

void GCMonsterDamageSend(int aIndex,int damage,int ShieldDamage) // OK
{
	PMSG_MONSTER_DAMAGE_SEND pMsg;

	pMsg.header.set(0xF3,0x07,sizeof(pMsg));

	pMsg.damage[0] = SET_NUMBERHB(GET_MAX_WORD_VALUE(damage));

	pMsg.damage[1] = SET_NUMBERLB(GET_MAX_WORD_VALUE(damage));

	pMsg.ShieldDamage[0] = SET_NUMBERHB(GET_MAX_WORD_VALUE(ShieldDamage));

	pMsg.ShieldDamage[1] = SET_NUMBERLB(GET_MAX_WORD_VALUE(ShieldDamage));

	#if(GAMESERVER_EXTRA==1)
	pMsg.ViewCurHP = (DWORD)gObj[aIndex].Life;
	pMsg.ViewCurSD = (DWORD)gObj[aIndex].Shield;
	pMsg.ViewDamageHP = damage;
	pMsg.ViewDamageSD = ShieldDamage;
	#endif

	if(gObj[aIndex].Type == OBJECT_USER)
	{
		DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
	}
}

void GCPKLevelSend(int aIndex,int PKLevel) // OK
{
	PMSG_PK_LEVEL_SEND pMsg;

	pMsg.header.set(0xF3,0x08,sizeof(pMsg));

	pMsg.index[0] = SET_NUMBERHB(aIndex);
	pMsg.index[1] = SET_NUMBERLB(aIndex);

	pMsg.PKLevel = PKLevel;

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
	MsgSendV2(&gObj[aIndex],(BYTE*)&pMsg,pMsg.header.size);
}

void GCSummonLifeSend(int aIndex,int life,int MaxLife) // OK
{
	if(MaxLife <= 0)
	{
		return;
	}

	PMSG_SUMMON_LIFE_SEND pMsg;

	pMsg.header.set(0xF3,0x20,sizeof(pMsg));

	pMsg.life = (life*100)/MaxLife;

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCTimeViewSend(int aIndex,int time) // OK
{
	PMSG_TIME_VIEW_SEND pMsg;

	pMsg.header.set(0xF3,0x22,sizeof(pMsg));

	pMsg.time = time;

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCMathAuthenticatorSend(int aIndex) // OK
{
	#if(GAMESERVER_UPDATE>=701)

	PMSG_MATH_AUTHENTICATOR_SEND pMsg;

	pMsg.header.set(0xF3,0x32,sizeof(pMsg));

	pMsg.function = GetLargeRand()%6;

	pMsg.value = (float)(1+(GetLargeRand()%9));

	memset(pMsg.result,0,sizeof(pMsg.result));

	MAPM mapm = pMsg.value;

	switch(pMsg.function)
	{
		case 0:
			mapm = mapm.sin();
			break;
		case 1:
			mapm = mapm.cos();
			break;
		case 2:
			mapm = mapm.tan();
			break;
		case 3:
			mapm = mapm.sqrt();
			break;
		case 4:
			mapm = mapm.log();
			break;
		case 5:
			mapm = mapm.exp();
			break;
	}

	mapm.toString(pMsg.result,5);

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);

	#endif
}

void GCFireworksSend(LPOBJ lpObj,int x,int y) // OK
{
	PMSG_FIREWORKS_SEND pMsg;

	pMsg.header.set(0xF3,0x40,sizeof(pMsg));

	pMsg.type = 0;

	pMsg.x = x;

	pMsg.y = y;

	DataSend(lpObj->Index,(BYTE*)&pMsg,pMsg.header.size);
	MsgSendV2(lpObj,(BYTE*)&pMsg,pMsg.header.size);
}

void GCServerCommandSend(int aIndex,BYTE type,BYTE cmd1,BYTE cmd2) // OK
{
	PMSG_SERVER_COMMAND_SEND pMsg;

	pMsg.header.set(0xF3,0x40,sizeof(pMsg));

	pMsg.type = type;

	pMsg.cmd1 = cmd1;

	pMsg.cmd2 = cmd2;

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void GCNewCharacterInfoSend(LPOBJ lpObj) // OK
{
	#if(GAMESERVER_EXTRA==1)

	PMSG_NEW_CHARACTER_INFO_SEND pMsg;

	pMsg.header.set(0xF3,0xE0,sizeof(pMsg));

	pMsg.Level = lpObj->Level;
	pMsg.LevelUpPoint = lpObj->LevelUpPoint;
	pMsg.Experience = lpObj->Experience;
	pMsg.NextExperience = lpObj->NextExperience;
	pMsg.Strength = GET_MAX_WORD_VALUE(lpObj->Strength);
	pMsg.Dexterity = GET_MAX_WORD_VALUE(lpObj->Dexterity);
	pMsg.Vitality = GET_MAX_WORD_VALUE(lpObj->Vitality);
	pMsg.Energy = GET_MAX_WORD_VALUE(lpObj->Energy);
	pMsg.Leadership = GET_MAX_WORD_VALUE(lpObj->Leadership);
	pMsg.Life = GET_MAX_WORD_VALUE(lpObj->Life);
	pMsg.MaxLife = GET_MAX_WORD_VALUE((lpObj->MaxLife+lpObj->AddLife));
	pMsg.Mana = GET_MAX_WORD_VALUE(lpObj->Mana);
	pMsg.MaxMana = GET_MAX_WORD_VALUE((lpObj->MaxMana+lpObj->AddMana));
	pMsg.BP = GET_MAX_WORD_VALUE(lpObj->BP);
	pMsg.MaxBP = GET_MAX_WORD_VALUE((lpObj->MaxBP+lpObj->AddBP));
	pMsg.Shield = GET_MAX_WORD_VALUE(lpObj->Shield);
	pMsg.MaxShield = GET_MAX_WORD_VALUE((lpObj->MaxShield+lpObj->AddShield));
	pMsg.FruitAddPoint = lpObj->FruitAddPoint;
	pMsg.MaxFruitAddPoint = gFruit.GetMaxFruitPoint(lpObj);
	pMsg.FruitSubPoint = lpObj->FruitSubPoint;
	pMsg.MaxFruitSubPoint = gFruit.GetMaxFruitPoint(lpObj);

	//EXTRA
	pMsg.ViewReset = (DWORD)(lpObj->Reset);
	pMsg.ViewPoint = (DWORD)(lpObj->LevelUpPoint);
	pMsg.ViewCurHP = (DWORD)(lpObj->Life);
	pMsg.ViewMaxHP = (DWORD)(lpObj->MaxLife+lpObj->AddLife);
	pMsg.ViewCurMP = (DWORD)(lpObj->Mana);
	pMsg.ViewMaxMP = (DWORD)(lpObj->MaxMana+lpObj->AddMana);
	pMsg.ViewCurBP = (DWORD)(lpObj->BP);
	pMsg.ViewMaxBP = (DWORD)(lpObj->MaxBP+lpObj->AddBP);
	pMsg.ViewCurSD = (DWORD)(lpObj->Shield);
	pMsg.ViewMaxSD = (DWORD)(lpObj->MaxShield+lpObj->AddShield);
	pMsg.ViewStrength = lpObj->Strength;
	pMsg.ViewDexterity = lpObj->Dexterity;
	pMsg.ViewVitality = lpObj->Vitality;
	pMsg.ViewEnergy = lpObj->Energy;
	pMsg.ViewLeadership = lpObj->Leadership;

	DataSend(lpObj->Index,(BYTE*)&pMsg,pMsg.header.size);


	#endif
}

void GCNewCharacterCalcSend(LPOBJ lpObj) // OK
{
	#if(GAMESERVER_EXTRA==1)

	PMSG_NEW_CHARACTER_CALC_SEND pMsg;

	pMsg.header.set(0xF3,0xE1,sizeof(pMsg));

	pMsg.ViewCurHP = (DWORD)(lpObj->Life);

	pMsg.ViewMaxHP = (DWORD)(lpObj->MaxLife+lpObj->AddLife);

	pMsg.ViewCurMP = (DWORD)(lpObj->Mana);

	pMsg.ViewMaxMP = (DWORD)(lpObj->MaxMana+lpObj->AddMana);

	pMsg.ViewCurBP = (DWORD)(lpObj->BP);

	pMsg.ViewMaxBP = (DWORD)(lpObj->MaxBP+lpObj->AddBP);

	pMsg.ViewCurSD = (DWORD)(lpObj->Shield);

	pMsg.ViewMaxSD = (DWORD)(lpObj->MaxShield+lpObj->AddShield);

	pMsg.ViewAddStrength = lpObj->AddStrength;

	pMsg.ViewAddDexterity = lpObj->AddDexterity;

	pMsg.ViewAddVitality = lpObj->AddVitality;

	pMsg.ViewAddEnergy = lpObj->AddEnergy;

	pMsg.ViewAddLeadership = lpObj->AddLeadership;

	gAttack.GetPreviewPhysiDamage(lpObj,&pMsg.ViewPhysiDamageMin,&pMsg.ViewPhysiDamageMax,&pMsg.ViewMulPhysiDamage,&pMsg.ViewDivPhysiDamage);

	gAttack.GetPreviewMagicDamage(lpObj,&pMsg.ViewMagicDamageMin,&pMsg.ViewMagicDamageMax,&pMsg.ViewMulMagicDamage,&pMsg.ViewDivMagicDamage,&pMsg.ViewMagicDamageRate);

	gAttack.GetPreviewCurseDamage(lpObj,&pMsg.ViewCurseDamageMin,&pMsg.ViewCurseDamageMax,&pMsg.ViewMulCurseDamage,&pMsg.ViewDivCurseDamage,&pMsg.ViewCurseDamageRate);

	pMsg.ViewPhysiSpeed = lpObj->PhysiSpeed;

	pMsg.ViewMagicSpeed = lpObj->MagicSpeed;

	pMsg.ViewAttackSuccessRate = lpObj->AttackSuccessRate;

	pMsg.ViewAttackSuccessRate += lpObj->EffectOption.AddAttackSuccessRate;

	pMsg.ViewAttackSuccessRate += (pMsg.ViewAttackSuccessRate*lpObj->EffectOption.MulAttackSuccessRate)/100;

	pMsg.ViewAttackSuccessRate -= (pMsg.ViewAttackSuccessRate*lpObj->EffectOption.DivAttackSuccessRate)/100;

	pMsg.ViewAttackSuccessRatePvP = lpObj->AttackSuccessRatePvP;

	gAttack.GetPreviewDefense(lpObj,&pMsg.ViewDefense);

	pMsg.ViewDefenseSuccessRate = lpObj->DefenseSuccessRate;

	pMsg.ViewDefenseSuccessRate += lpObj->EffectOption.AddDefenseSuccessRate;

	pMsg.ViewDefenseSuccessRate += (pMsg.ViewDefenseSuccessRate*lpObj->EffectOption.MulDefenseSuccessRate)/100;

	pMsg.ViewDefenseSuccessRate -= (pMsg.ViewDefenseSuccessRate*lpObj->EffectOption.DivDefenseSuccessRate)/100;

	pMsg.ViewDefenseSuccessRatePvP = lpObj->DefenseSuccessRatePvP;

	gAttack.GetPreviewDamageMultiplier(lpObj,&pMsg.ViewDamageMultiplier,&pMsg.ViewRFDamageMultiplierA,&pMsg.ViewRFDamageMultiplierB,&pMsg.ViewRFDamageMultiplierC);

	gDarkSpirit[lpObj->Index].GetPreviewAttackDamage(lpObj,&pMsg.ViewDarkSpiritAttackDamageMin,&pMsg.ViewDarkSpiritAttackDamageMax,&pMsg.ViewDarkSpiritAttackSpeed,&pMsg.ViewDarkSpiritAttackSuccessRate);

	DataSend(lpObj->Index,(BYTE*)&pMsg,pMsg.header.size);

	#endif
}

void GCNewHealthBarSend(LPOBJ lpObj) // OK
{
	#if(GAMESERVER_EXTRA==1)

	if (gServerInfo.m_MonsterHealthBarSwitch == 0 && gServerInfo.m_UserHealthBarSwitch == 0)
	{
		return;
	}

	BYTE send[4096];

	PMSG_NEW_HEALTH_BAR_SEND pMsg;

	pMsg.header.set(0xF3, 0xE2, 0);

	int size = sizeof(pMsg);

	pMsg.count = 0;

	PMSG_NEW_HEALTH_BAR info;

	for (int n = 0;n < MAX_VIEWPORT;n++)
	{
		if (lpObj->VpPlayer[n].state != VIEWPORT_SEND && lpObj->VpPlayer[n].state != VIEWPORT_WAIT)
		{
			continue;
		}

		if (lpObj->VpPlayer[n].type == OBJECT_MONSTER && gServerInfo.m_MonsterHealthBarSwitch == 0)
		{
			continue;
		}

		if (lpObj->VpPlayer[n].type == OBJECT_USER && gServerInfo.m_UserHealthBarSwitch == 0)
		{
			continue;
		}

		if (OBJECT_RANGE(lpObj->VpPlayer[n].index) == 0)
		{
			continue;
		}

		LPOBJ lpTarget = &gObj[lpObj->VpPlayer[n].index];

		if (lpTarget->Type == OBJECT_USER && (GetTickCount() - lpTarget->timeshow) > 5000)
		{
			lpTarget->showhpbar = 0;
		
		}

		if (lpTarget->Type == OBJECT_MONSTER || lpTarget->showhpbar == 1 )
		{

			if (lpTarget->Live == 0 || lpTarget->State != OBJECT_PLAYING || OBJECT_RANGE(lpTarget->SummonIndex) != 0 || CC_MAP_RANGE(lpTarget->Map) != 0)
			{
				continue;
			}

			if(lpTarget->Type == OBJECT_USER && lpTarget->sendhpbartarget != lpObj->Index)
			{
				continue;
			}
		

			info.index = lpTarget->Index;

			info.type = (BYTE)lpTarget->Type;

			info.rate = (BYTE)((lpTarget->Life * 100) / (lpTarget->MaxLife + lpTarget->AddLife));

			if (lpObj->VpPlayer[n].type == OBJECT_USER)
			{
				info.rate2 = (BYTE)((lpTarget->Shield * 100) / (lpTarget->MaxShield + lpTarget->AddShield));
			}
			else
			{
				info.rate2 = 0;
			}

			memcpy(&send[size], &info, sizeof(info));
			size += sizeof(info);

			pMsg.count++;
		}

		pMsg.header.size[0] = SET_NUMBERHB(size);

		pMsg.header.size[1] = SET_NUMBERLB(size);

		memcpy(send, &pMsg, sizeof(pMsg));

		DataSend(lpObj->Index, send, size);
	}
	#endif
}


void GCNewGensBattleInfoSend(LPOBJ lpObj) // OK
{
	#if(GAMESERVER_EXTRA==1)

	#if(GAMESERVER_UPDATE>=501)

	PMSG_NEW_GENS_BATTLE_INFO_SEND pMsg;

	pMsg.header.set(0xF3,0xE3,sizeof(pMsg));

	pMsg.GensBattleMapCount = gGensSystem.GetGensBattleMap(pMsg.GensBattleMap);

	pMsg.GensMoveIndexCount = gGensSystem.GetGensMoveIndex(pMsg.GensMoveIndex);

	DataSend(lpObj->Index,(BYTE*)&pMsg,pMsg.header.size);

	#endif

	#endif
}

void GCNewMessageSend(LPOBJ lpObj,char* message) // OK
{
	#if(GAMESERVER_EXTRA==1)

	PMSG_NEW_MESSAGE_SEND pMsg;

	pMsg.header.set(0xF3,0xE4,sizeof(pMsg));

	memcpy(pMsg.message,message,sizeof(pMsg.message));

	DataSend(lpObj->Index,(BYTE*)&pMsg,pMsg.header.size);

	#endif
}

//**************************************************************************//
// RAW FUNCTIONS ***********************************************************//
//**************************************************************************//

void CGReqCastleSiegeState(PMSG_REQ_CASTLESIEGESTATE * lpMsg, int iIndex) 
{
#if(GAMESERVER_TYPE==1)
	GS_GDReqOwnerGuildMaster(gMapServerManager.GetMapServerGroup(), iIndex);
#endif
}

void GCAnsCastleSiegeState(int iIndex, int iResult, LPSTR lpszGuildName, LPSTR lpszGuildMaster)
{
#if (GAMESERVER_TYPE==1)
	if( (lpszGuildName == NULL) || (lpszGuildMaster == NULL) )
	{
		return;
	}

	PMSG_ANS_CASTLESIEGESTATE pMsgResult;


	pMsgResult.h.set(0xB2, 0x00, sizeof(pMsgResult));

	pMsgResult.btResult = iResult;

	memcpy(pMsgResult.cOwnerGuild, lpszGuildName, sizeof(pMsgResult.cOwnerGuild));
	memcpy(pMsgResult.cOwnerGuildMaster, lpszGuildMaster, sizeof(pMsgResult.cOwnerGuildMaster));

	SYSTEMTIME tmStateStartDate = {0};
	SYSTEMTIME tmStateEndDate = {0};
	SYSTEMTIME tmSiegeStartDate = {0};

	int iCastleState = gCastleSiege.GetCastleState();
	int bRETVAL = gCastleSiege.GetCastleStateTerm(&tmStateStartDate, &tmStateEndDate);
	tmSiegeStartDate = gCastleSiege.GetCastleLeftSiegeDate();

	if( bRETVAL == FALSE )
	{
		iCastleState = -1;
	}

	int iStateLeftSec = gCastleSiege.GetCurRemainSec();


	pMsgResult.cCastleSiegeState = iCastleState;

	pMsgResult.btStartYearH = SET_NUMBERHB(tmStateStartDate.wYear);
	pMsgResult.btStartYearL = SET_NUMBERLB(tmStateStartDate.wYear);
	pMsgResult.btStartMonth = (BYTE)tmStateStartDate.wMonth;
	pMsgResult.btStartDay   = (BYTE)tmStateStartDate.wDay;
	pMsgResult.btStartHour  = (BYTE)tmStateStartDate.wHour;
	pMsgResult.btStartMinute= (BYTE)tmStateStartDate.wMinute;

	pMsgResult.btEndYearH = SET_NUMBERHB(tmStateEndDate.wYear);
	pMsgResult.btEndYearL = SET_NUMBERLB(tmStateEndDate.wYear);
	pMsgResult.btEndMonth = (BYTE)tmStateEndDate.wMonth;
	pMsgResult.btEndDay   = (BYTE)tmStateEndDate.wDay;
	pMsgResult.btEndHour  = (BYTE)tmStateEndDate.wHour;
	pMsgResult.btEndMinute= (BYTE)tmStateEndDate.wMinute;

	pMsgResult.btSiegeStartYearH = SET_NUMBERHB(tmSiegeStartDate.wYear);
	pMsgResult.btSiegeStartYearL = SET_NUMBERLB(tmSiegeStartDate.wYear);
	pMsgResult.btSiegeStartMonth = (BYTE)tmSiegeStartDate.wMonth;
	pMsgResult.btSiegeStartDay   = (BYTE)tmSiegeStartDate.wDay;
	pMsgResult.btSiegeStartHour  = (BYTE)tmSiegeStartDate.wHour;
	pMsgResult.btSiegeStartMinute= (BYTE)tmSiegeStartDate.wMinute;

	pMsgResult.btStateLeftSec1 = SET_NUMBERHB(SET_NUMBERHW(iStateLeftSec));
	pMsgResult.btStateLeftSec2 = SET_NUMBERLB(SET_NUMBERHW(iStateLeftSec));
	pMsgResult.btStateLeftSec3 = SET_NUMBERHB(SET_NUMBERLW(iStateLeftSec));
	pMsgResult.btStateLeftSec4 = SET_NUMBERLB(SET_NUMBERLW(iStateLeftSec));

	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
#endif
}

void CGReqRegCastleSiege(PMSG_REQ_REGCASTLESIEGE * lpMsg, int iIndex) 
{
#if (GAMESERVER_TYPE==1)
	if( gCastleSiege.GetCastleState() != CASTLESIEGE_STATE_REGSIEGE )
	{
		GCAnsRegCastleSiege(iIndex, 7, "");
		return;
	}
	if( strcmp(gObj[iIndex].GuildName, "") == 0 )
	{
		GCAnsRegCastleSiege(iIndex, 6, "");
		return;
	}

	//공성선포
	//if ( gServerInfo.RegCastleGuildMoney > gObj[iIndex].Guild->TotalScore )
	//{
	//	gNotice.GCNoticeSend(gObj[iIndex].Index,1,0,0,0,0,0,"[☎] 길드점수가 필요 합니다 ll Guild Points are required", gServerInfo.RegCastleGuildMoney);
	//	return;
	//}

	if (gServerInfo.RegCastleGuildGPMoney > gObj[iIndex].Coin3)
	{
		gNotice.GCNoticeSend(gObj[iIndex].Index,1,0,0,0,0,0,"[☎] %d 고포가 필요 합니다 ll Requires %d GP", gServerInfo.RegCastleGuildGPMoney);
		return;
	}

	if( gCastleSiege.CheckUnionGuildMaster(iIndex) == FALSE )
	{
		GCAnsRegCastleSiege(iIndex, 0, "");
	}
	else if( (gCastleSiege.CheckCastleOwnerMember(iIndex) != FALSE) || 
		(gCastleSiege.CheckCastleOwnerUnionMember(iIndex) != FALSE) )
	{
		GCAnsRegCastleSiege(iIndex, 3, "");
	}
	else
	{
		GS_GDReqRegAttackGuild(gMapServerManager.GetMapServerGroup(), iIndex);
	}
#endif
}

void GCAnsRegCastleSiege(int iIndex, int iResult, LPSTR lpszGuildName) 
{
#if(GAMESERVER_TYPE==1)
	PMSG_ANS_REGCASTLESIEGE pMsgResult;

	if( lpszGuildName == NULL )
	{
		return;
	}

	if( OBJECT_RANGE(iIndex) == FALSE )
	{
		return;
	}

	pMsgResult.h.set(0xB2, 0x01, sizeof(pMsgResult));
	pMsgResult.btResult = iResult;
	memcpy(&pMsgResult.szGuildName, lpszGuildName, sizeof(pMsgResult.szGuildName));

	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

	if( ::gObjIsConnected(iIndex) )
	{
		//공성선포
		//GUILD_INFO_STRUCT* lpGuild = gGuildClass.SearchGuild_Number(gObj[iIndex].GuildNumber);
		//lpGuild->TotalScore -= gServerInfo.RegCastleGuildMoney;
		//DGGuildScoreUpdate(lpGuild->Name,lpGuild->TotalScore);

		gCashShop.GDCashShopSubPointSaveSend(gObj[iIndex].Index,0,0,0,gServerInfo.RegCastleGuildGPMoney);
		gCashShop.CGCashShopPointRecv(gObj[iIndex].Index);

		LogAdd(LOG_BLACK,"[CastleSiege] [%s][%s] Registered Castle Siege (GUILD:%s) - Result:%d",	gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, iResult);
	}
#endif
}

void CGReqGiveUpCastleSiege(PMSG_REQ_GIVEUPCASTLESIEGE * lpMsg, int iIndex) 
{
#if(GAMESERVER_TYPE==1)
	if( (gCastleSiege.GetCastleState() < CASTLESIEGE_STATE_REGSIEGE) || (gCastleSiege.GetCastleState() > CASTLESIEGE_STATE_REGMARK) ) //Fixed
	{
		GCAnsGiveUpCastleSiege(iIndex, 3, 0, 0, "");
		return;
	}

	if( strcmp(gObj[iIndex].GuildName, "") == 0 )
	{
		return;
	}
	
	if( gCastleSiege.CheckUnionGuildMaster(iIndex) == FALSE )
	{
		return;
	}

	GS_GDReqGuildSetGiveUp(gMapServerManager.GetMapServerGroup(), iIndex, lpMsg->btGiveUp);
#endif
}

void GCAnsGiveUpCastleSiege(int iIndex, int iResult, int bGiveUp, int iMarkCount, LPSTR lpszGuildName)
{
#if(GAMESERVER_TYPE==1)
	PMSG_ANS_GIVEUPCASTLESIEGE pMsgResult;

	if( lpszGuildName == NULL )
	{
		return;
	}

	if( OBJECT_RANGE(iIndex) == FALSE )
	{
		return;
	}

	pMsgResult.h.set(0xB2, 0x02, sizeof(pMsgResult));
	pMsgResult.btResult = iResult;
	pMsgResult.btIsGiveUp = bGiveUp;

	memcpy(&pMsgResult.szGuildName, lpszGuildName, sizeof(pMsgResult.szGuildName));

	//공성포기
	if( (pMsgResult.btResult == 1) && (iMarkCount > 0) )
	{
		gObj[iIndex].Money += (iMarkCount*1000);

		if( gObj[iIndex].Money > MAX_MONEY ) 
		{
			gObj[iIndex].Money = MAX_MONEY;
		}

		GCMoneySend(iIndex, gObj[iIndex].Money);
	}

	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);

	if( gObjIsConnected(iIndex) )
	{
		LogAdd(LOG_BLACK,"[CastleSiege] [%s][%s] GiveUp Castle Siege (GUILD:%s) - Result:%d", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, iResult);
	}
#endif
}

void CGReqGuildRegInfo(PMSG_REQ_GUILDREGINFO * lpMsg, int iIndex) 
{
#if (GAMESERVER_TYPE==1)
	if( lpMsg == NULL )
	{
		return;
	}

	if( strcmp(gObj[iIndex].GuildName, "") == 0 )
	{
		return;
	}

	GS_GDReqGuildMarkRegInfo(gMapServerManager.GetMapServerGroup(), iIndex);
#endif
}

void GCAnsGuildRegInfo(int iIndex, int iResult, CSP_ANS_GUILDREGINFO* lpMsgResult)
{
#if (GAMESERVER_TYPE==1)
	PMSG_ANS_GUILDREGINFO pMsgResult;

	if( lpMsgResult == NULL )
	{
		return;
	}

	if( OBJECT_RANGE(iIndex) == FALSE )
	{
		return;
	}

	pMsgResult.h.set(0xB2, 3, sizeof(pMsgResult));

	pMsgResult.btResult = iResult;
	pMsgResult.btGuildMark1 = SET_NUMBERHB(SET_NUMBERHW(lpMsgResult->iRegMarkCount));
	pMsgResult.btGuildMark2 = SET_NUMBERLB(SET_NUMBERHW(lpMsgResult->iRegMarkCount));
	pMsgResult.btGuildMark3 = SET_NUMBERHB(SET_NUMBERLW(lpMsgResult->iRegMarkCount));
	pMsgResult.btGuildMark4 = SET_NUMBERLB(SET_NUMBERLW(lpMsgResult->iRegMarkCount));
	pMsgResult.btRegRank = lpMsgResult->btRegRank;
	pMsgResult.btIsGiveUp = lpMsgResult->bIsGiveUp;
	memcpy(&pMsgResult.szGuildName, lpMsgResult->szGuildName, sizeof(pMsgResult.szGuildName));

	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);


#endif
}

void CGReqRegGuildMark(PMSG_REQ_REGGUILDMARK * lpMsg, int iIndex) 
{
#if (GAMESERVER_TYPE==1)
	if( lpMsg == NULL )
	{
		return;
	}
	
	if( OBJECT_RANGE(iIndex) == FALSE )
	{
		return;
	}
	
	if( gObj[iIndex].UseEventServer == TRUE )
	{
		return;
	}

	gObj[iIndex].UseEventServer = TRUE;

	if( gCastleSiege.GetCastleState() != CASTLESIEGE_STATE_REGMARK )
	{
		gObj[iIndex].UseEventServer = FALSE;
		return;
	}
	if( strcmp( gObj[iIndex].GuildName, "") == 0)
	{
		gObj[iIndex].UseEventServer = FALSE;
		return;
	}
	
	if(lpMsg->btItemPos < 0 || lpMsg->btItemPos >= 64)
	{
		PMSG_ANS_REGGUILDMARK pMsgResult = {0};
		pMsgResult.h.set(0xB2, 0x04, sizeof(pMsgResult));
		pMsgResult.btResult = 3;		
		DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
		gObj[iIndex].UseEventServer = FALSE;
	}
	else
	{
		int iItemPos = (lpMsg->btItemPos + 12);

		if( gObj[iIndex].Inventory[iItemPos].IsItem() == FALSE )
		{
			PMSG_ANS_REGGUILDMARK pMsgResult = {0};
			pMsgResult.h.set(0xB2, 0x04, sizeof(pMsgResult));
			pMsgResult.btResult = 3;		
			DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
			gObj[iIndex].UseEventServer = FALSE;
		}
		else
		{
			if( gObj[iIndex].Inventory[iItemPos].m_Index != GET_ITEM(14,21) || 
				gObj[iIndex].Inventory[iItemPos].m_Level != 3 || 
				gObj[iIndex].Inventory[iItemPos].m_Durability <= 0.0f )
			{
				PMSG_ANS_REGGUILDMARK pMsgResult = {0};
				pMsgResult.h.set(0xB2, 0x04, sizeof(pMsgResult));
				pMsgResult.btResult = 3;		
				DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
				gObj[iIndex].UseEventServer = FALSE;
			}
			else
			{
				GS_GDReqRegGuildMark(gMapServerManager.GetMapServerGroup(), iIndex, iItemPos);
			}
		}
	}
#endif
}

void GCAnsRegGuildMark(int iIndex, int iResult, CSP_ANS_GUILDREGMARK* lpMsgResult) 
{
#if (GAMESERVER_TYPE==1)
	if( lpMsgResult == NULL )
	{
		return;
	}

	if( OBJECT_RANGE(iIndex) == FALSE )
	{
		return;
	}

	if( gObj[iIndex].Inventory[lpMsgResult->iItemPos].IsItem() == FALSE )
	{	
		PMSG_ANS_REGGUILDMARK pMsgResult ={0};
		pMsgResult.h.set(0xB2, 0x04, sizeof(pMsgResult));
		pMsgResult.btResult = 3;
		DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
		gObj[iIndex].UseEventServer = 0;
	}
	else
	{
		if( gObj[iIndex].Inventory[lpMsgResult->iItemPos].m_Index != GET_ITEM(14,21) && 
			gObj[iIndex].Inventory[lpMsgResult->iItemPos].m_Level == 3 || 
			gObj[iIndex].Inventory[lpMsgResult->iItemPos].m_Durability <= 0.0f ) 
		{
			PMSG_ANS_REGGUILDMARK pMsgResult = {0};
			pMsgResult.h.set(0xB2, 0x04, sizeof(pMsgResult));
			pMsgResult.btResult = 3;
			DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
			gObj[iIndex].UseEventServer = FALSE;
		}
		else
		{
			if( (gObj[iIndex].Inventory[lpMsgResult->iItemPos].m_Durability -= 1.0) > 0.0f )
			{
				gItemManager.GCItemDurSend(iIndex, lpMsgResult->iItemPos, (BYTE)gObj[iIndex].Inventory[lpMsgResult->iItemPos].m_Durability, 0);
			}
			else
			{
				gItemManager.InventoryDelItem(iIndex, lpMsgResult->iItemPos);
				gItemManager.GCItemDeleteSend(iIndex,lpMsgResult->iItemPos,1);
			}
			
			PMSG_ANS_REGGUILDMARK pMsgResult;
			pMsgResult.h.set(0xB2, 0x04, sizeof(pMsgResult));
			
			pMsgResult.btResult = iResult;
			pMsgResult.btGuildMark1 = SET_NUMBERHB(SET_NUMBERHW(lpMsgResult->iRegMarkCount));
			pMsgResult.btGuildMark2 = SET_NUMBERLB(SET_NUMBERHW(lpMsgResult->iRegMarkCount));
			pMsgResult.btGuildMark3 = SET_NUMBERHB(SET_NUMBERLW(lpMsgResult->iRegMarkCount));
			pMsgResult.btGuildMark4 = SET_NUMBERLB(SET_NUMBERLW(lpMsgResult->iRegMarkCount));
			memcpy(&pMsgResult.szGuildName, lpMsgResult->szGuildName, sizeof(pMsgResult.szGuildName));
			DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
			gObj[iIndex].UseEventServer = 0;
			
		}
	}
#endif
}

void CGReqNpcBuy(PMSG_REQ_NPCBUY * lpMsg, int iIndex) 
{
#if (GAMESERVER_TYPE==1)
	if( lpMsg == NULL )
	{
		return;
	}

	if( ::gObjIsConnected(iIndex) == FALSE )
	{
		return;
	}

	if( strcmp(gObj[iIndex].GuildName, "") == 0 )
	{
		return;
	}

	if( gCastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE || (gObj[iIndex].GuildStatus != G_MASTER && gObj[iIndex].GuildStatus != G_SUB_MASTER) )
	{
		LogAdd(LOG_RED, "[CastleSiege] CGReqNpcBuy() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",	gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex);
	}
	else
	{
		BYTE btResult = 0;

		BOOL bRETVAL = gCastleSiege.CheckAddDbNPC(iIndex, lpMsg->iNpcNumber, lpMsg->iNpcIndex, btResult);

		if( bRETVAL == FALSE )
		{
			GCAnsNpcBuy(iIndex, btResult, lpMsg->iNpcNumber, lpMsg->iNpcIndex);
			LogAdd(LOG_RED, "[CastleSiege] CGReqNpcBuy() ERROR - CCastleSiege::CheckAddDbNPC() [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex);
		}
		else
		{
			LogAdd(LOG_RED, "[CastleSiege] CGReqNpcBuy() OK - [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus,lpMsg->iNpcNumber,lpMsg->iNpcIndex);
		}
	}
#endif
}

void GCAnsNpcBuy(int iIndex, int iResult, int iNpcNumber, int iNpcIndex) 
{
#if(GAMESERVER_TYPE==1)
	PMSG_ANS_NPCBUY pMsgResult;

	pMsgResult.h.set(0xB2, 0x05, sizeof(pMsgResult));
	pMsgResult.btResult = iResult;
	pMsgResult.iNpcNumber = iNpcNumber;
	pMsgResult.iNpcIndex = iNpcIndex;
	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
#endif
}

void CGReqNpcRepair(PMSG_REQ_NPCREPAIR * lpMsg, int iIndex) 
{
#if (GAMESERVER_TYPE==1)
	if( lpMsg == NULL )
	{
		return;
	}

	if( ::gObjIsConnected(iIndex) == FALSE )
	{
		return;
	}

	if( strcmp(gObj[iIndex].GuildName, "") == 0 )
	{
		return;
	}

	if( (gCastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE) || (gObj[iIndex].GuildStatus != G_MASTER) && (gObj[iIndex].GuildStatus != G_SUB_MASTER) )
	{
		LogAdd(LOG_RED, "[CastleSiege] CGReqNpcRepair() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);
		return;
	}

	_CS_NPC_DATA pNpcData;
	BOOL bRETVAL;
	int iNpcIndex;
	int iRepairCost;

	bRETVAL = gCastleSiege.GetNpcData(lpMsg->iNpcNumber, lpMsg->iNpcIndex,pNpcData);

	if( bRETVAL == FALSE )
	{
		GCAnsNpcRepair(iIndex, 0, lpMsg->iNpcNumber, lpMsg->iNpcIndex, 0, 0);
		LogAdd(LOG_RED, "[CastleSiege] CGReqNpcRepair() ERROR - CL Request Fail [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",	gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, lpMsg->iNpcNumber,lpMsg->iNpcIndex);
		return;
	}
	else
	{
		iNpcIndex = pNpcData.m_iNPC_OBJINDEX;

		if( gObjIsConnected(iNpcIndex) == FALSE )
		{
			GCAnsNpcRepair(iIndex, 0, lpMsg->iNpcNumber, lpMsg->iNpcIndex, 0, 0);
			LogAdd(LOG_RED,"[CastleSiege] CGReqNpcRepair() ERROR - Npc Alive Data Mismatch [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, pNpcData.m_iNPC_NUM, pNpcData.m_iNPC_INDEX);
			return;
		}
		else if( gObj[iNpcIndex].Live == 0 )
		{
			GCAnsNpcRepair(iIndex, 0, lpMsg->iNpcNumber, lpMsg->iNpcIndex, 0, 0);
			LogAdd(LOG_RED, "[CastleSiege] CGReqNpcRepair() ERROR - Npc Alive Data Mismatch [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)",	gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, pNpcData.m_iNPC_NUM, pNpcData.m_iNPC_INDEX);
			return;
		}
		else
		{
			if( (gObj[iNpcIndex].MaxLife == gObj[iNpcIndex].Life) || (gObj[iNpcIndex].MaxLife < gObj[iNpcIndex].Life) )
			{
				gObj[iNpcIndex].Life = gObj[iNpcIndex].MaxLife;
				GCAnsNpcRepair(iIndex, 0, lpMsg->iNpcNumber, lpMsg->iNpcIndex, 0, 0);
				return;
			}
			else
			{
				iRepairCost = 0;

				switch( lpMsg->iNpcNumber )
				{
					case 277:
						iRepairCost	= (int)(float((gObj[iNpcIndex].MaxLife - gObj[iNpcIndex].Life) * 0.5f) + float(gObj[iNpcIndex].CsNpcDfLevel * 1000000));
						break;
					case 283:
						iRepairCost	= (int)((gObj[iNpcIndex].MaxLife - gObj[iNpcIndex].Life)* 0.3f + float((gObj[iNpcIndex].CsNpcDfLevel + gObj[iNpcIndex].CsNpcRgLevel) * 1000000));
						break;
					default:
						GCAnsNpcRepair(iIndex, 0, lpMsg->iNpcNumber, lpMsg->iNpcIndex, 0, 0);
						return;
				}

				if( gObj[iIndex].Money < ((DWORD)iRepairCost) )
				{
					GCAnsNpcRepair(iIndex, 3, lpMsg->iNpcNumber, lpMsg->iNpcIndex, 0, 0);
					LogAdd(LOG_RED, "[CastleSiege] CGReqNpcRepair() ERROR - Money isn't enough [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, pNpcData.m_iNPC_NUM, pNpcData.m_iNPC_INDEX);
					return;
				}
				else
				{
					LogAdd(LOG_RED, "[CastleSiege] CGReqNpcRepair() OK - [%s][%s], Guild:(%s)(%d), Npc:(CLS:%d, IDX:%d)", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, pNpcData.m_iNPC_NUM, pNpcData.m_iNPC_INDEX);
					GS_GDReqCastleNpcRepair(gMapServerManager.GetMapServerGroup(), iIndex, lpMsg->iNpcNumber, lpMsg->iNpcIndex, iRepairCost);
					return;
				}
			}
		}
	}
#endif
}

void GCAnsNpcRepair(int iIndex, int iResult, int iNpcNumber, int iNpcIndex, int iNpcHP, int iNpcMaxHP) 
{
#if(GAMESERVER_TYPE==1)
	PMSG_ANS_NPCREPAIR pMsgResult;

	pMsgResult.h.set(0xB2, 0x06, sizeof(pMsgResult));
	pMsgResult.btResult = iResult;
	pMsgResult.iNpcNumber = iNpcNumber;
	pMsgResult.iNpcIndex = iNpcIndex;
	pMsgResult.iNpcHP = iNpcHP;
	pMsgResult.iNpcMaxHP = iNpcMaxHP;

	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
#endif
}

void CGReqNpcUpgrade(PMSG_REQ_NPCUPGRADE * lpMsg, int iIndex) 
{
#if (GAMESERVER_TYPE==1)

	if( lpMsg == NULL )
	{
		return;
	}

	if( ::gObjIsConnected(iIndex) == FALSE )
	{
		return;
	}

	int iNEED_GEMOFDEFEND = 0; 
	int	iNEED_MONEY = 0;
	int	iCUR_UPLVL = 0;
	int	iNXT_UPLVL = 0; 
	int	iNXT_UPVALUE = 0;
	int	bENABLE_UPGRADE = FALSE;

	if( strcmp(gObj[iIndex].GuildName, "") == 0 )
		return;

	if( (gCastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE) || (gObj[iIndex].GuildStatus != G_MASTER) )
	{
		LogAdd(LOG_BLACK,"[CastleSiege] CGReqNpcUpgrade() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);
		return;
	}

	switch( lpMsg->iNpcNumber )
	{
		case 277:
		{
			_CS_NPC_DATA m_NpcData;
			BOOL bResult = gCastleSiege.GetNpcData(lpMsg->iNpcNumber, lpMsg->iNpcIndex, m_NpcData);

			if( bResult )
			{
				switch( lpMsg->iNpcUpType )
				{
					case 1:
					{
						iCUR_UPLVL = m_NpcData.m_iNPC_DF_LEVEL;
						iNXT_UPLVL = lpMsg->iNpcUpValue;

						if( (iNXT_UPLVL >= 1) && (iNXT_UPLVL <= 3) && (iNXT_UPLVL == (iCUR_UPLVL+1)) )
						{
							bENABLE_UPGRADE = TRUE;
							iNXT_UPVALUE = iNXT_UPLVL;
							iNEED_GEMOFDEFEND =  g_iNpcUpDfLevel_CGATE[(iNXT_UPLVL-1)][1];
							iNEED_MONEY = g_iNpcUpDfLevel_CGATE[(iNXT_UPLVL-1)][2];
						}
					}
					break;

					case 3:
					{
						iCUR_UPLVL = 0;

						for( int i = 0; i < 3; i++ )
						{
							if( m_NpcData.m_iNPC_MAXHP >= *g_iNpcUpMaxHP_CGATE[i] )
							{
								iCUR_UPLVL = (i+1);
							}
						}
						iNXT_UPLVL = 0;

						for(int i = 0; i < 3; i++ )
						{
							if( lpMsg->iNpcUpValue >= *g_iNpcUpMaxHP_CGATE[i] )
							{
								iNXT_UPLVL = (i+1);
							}
						}

						if( (iNXT_UPLVL >= 1) && (iNXT_UPLVL <= 3) && (iNXT_UPLVL == (iCUR_UPLVL+1)) )
						{
							bENABLE_UPGRADE = TRUE;
							iNXT_UPVALUE = g_iNpcUpMaxHP_CGATE[(iNXT_UPLVL-1)][0];
							iNEED_GEMOFDEFEND = g_iNpcUpMaxHP_CGATE[(iNXT_UPLVL-1)][1];
							iNEED_MONEY = g_iNpcUpMaxHP_CGATE[(iNXT_UPLVL-1)][2];
						}
					}
					break;
					default:
						{
							GCAnsNpcUpgrade(iIndex, 5, lpMsg->iNpcNumber, lpMsg->iNpcIndex, lpMsg->iNpcUpType, lpMsg->iNpcUpValue);
							return;
						}
						break;
				}
			}
			else
			{
				GCAnsNpcUpgrade(iIndex, 7, lpMsg->iNpcNumber, lpMsg->iNpcIndex, lpMsg->iNpcUpType, lpMsg->iNpcUpValue);
				return;
			}
		}
		break;
		case 283:
		{
			_CS_NPC_DATA m_NpcData;

			BOOL bResult;
			
			bResult	= gCastleSiege.GetNpcData(lpMsg->iNpcNumber, lpMsg->iNpcIndex, m_NpcData);

			if( bResult )
			{
				switch( lpMsg->iNpcUpType )
				{
					case 1:
						{
							iCUR_UPLVL = m_NpcData.m_iNPC_DF_LEVEL;
							iNXT_UPLVL = lpMsg->iNpcUpValue;

							if( (iNXT_UPLVL >= 1) && (iNXT_UPLVL <= 3) && (iNXT_UPLVL == (iCUR_UPLVL+1)) )
							{
								bENABLE_UPGRADE = TRUE;
								iNXT_UPVALUE = iNXT_UPLVL;
								iNEED_GEMOFDEFEND = g_iNpcUpDfLevel_CSTATUE[(iNXT_UPLVL-1)][1];
								iNEED_MONEY = g_iNpcUpDfLevel_CSTATUE[(iNXT_UPLVL-1)][2];
							}
						}
						break;
					case 2:
						{
							iCUR_UPLVL = m_NpcData.m_iNPC_RG_LEVEL;
							iNXT_UPLVL = lpMsg->iNpcUpValue;
							
							if( (iNXT_UPLVL >= 1) && (iNXT_UPLVL <= 3) && (iNXT_UPLVL == (iCUR_UPLVL+1)) )
							{
								bENABLE_UPGRADE = TRUE;
								iNXT_UPVALUE = iNXT_UPLVL;
								iNEED_GEMOFDEFEND = g_iNpcUpRgLevel_CSTATUE[(iNXT_UPLVL-1)][1];
								iNEED_MONEY = g_iNpcUpRgLevel_CSTATUE[(iNXT_UPLVL-1)][2];
							}
						}
						break;
					case 3:
						{
							iCUR_UPLVL = 0;

							for( int i = 0; i < 3; i++ )
							{
								if( m_NpcData.m_iNPC_MAXHP >= *g_iNpcUpMaxHP_CSTATUE[i] )
								{
									iCUR_UPLVL = (i+1);
								}
							}

							iNXT_UPLVL = 0;

							for(int i = 0; i < 3; i++ )
							{
								if( lpMsg->iNpcUpValue >= *g_iNpcUpMaxHP_CSTATUE[i] )
								{
									iNXT_UPLVL = (i+1);
								}
							}

							if( (iNXT_UPLVL >= 1) && (iNXT_UPLVL <= 3) && (iNXT_UPLVL == (iCUR_UPLVL+1)) )
							{
								bENABLE_UPGRADE = TRUE;
								iNXT_UPVALUE = g_iNpcUpMaxHP_CSTATUE[(iNXT_UPLVL-1)][0];
								iNEED_GEMOFDEFEND = g_iNpcUpMaxHP_CSTATUE[(iNXT_UPLVL-1)][1];
								iNEED_MONEY = g_iNpcUpMaxHP_CSTATUE[(iNXT_UPLVL-1)][2];
							}
						}
						break;
					default:
						{
							GCAnsNpcUpgrade(iIndex, 5, lpMsg->iNpcNumber, lpMsg->iNpcIndex, lpMsg->iNpcUpType, lpMsg->iNpcUpValue);
							LogAdd(LOG_BLACK,"[CastleSiege] CGReqNpcUpgrade() ERROR - UpType doesn't Exist [%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d", gObj[iIndex].Account,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildNumber,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue);
							return;
						}
						break;
				}
			}
			else
			{
				GCAnsNpcUpgrade(iIndex, 7, lpMsg->iNpcNumber, lpMsg->iNpcIndex, lpMsg->iNpcUpType, lpMsg->iNpcUpValue);		
				return;
			}
		}
		break;
	}

	int iGEMOFDEFEND_COUNT;
	int x;
	int bRETVAL;

	if( bENABLE_UPGRADE == FALSE )
	{
		GCAnsNpcUpgrade(iIndex, 6, lpMsg->iNpcNumber, lpMsg->iNpcIndex, lpMsg->iNpcUpType, lpMsg->iNpcUpValue);		
	}
	else 
	{
		if( gObj[iIndex].Money < ((DWORD)iNEED_MONEY) )
		{
			GCAnsNpcUpgrade(iIndex, 3, lpMsg->iNpcNumber, lpMsg->iNpcIndex, lpMsg->iNpcUpType, lpMsg->iNpcUpValue);
			LogAdd(LOG_BLACK,"[CastleSiege] CGReqNpcUpgrade() ERROR - Money is Low [%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTLV:%d, Money:%d, Need Money:%d", gObj[iIndex].Account,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildNumber,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL,gObj[iIndex].Money,iNEED_MONEY);
		}
		else
		{
			for( iGEMOFDEFEND_COUNT = 0, x = 0; x < INVENTORY_MAIN_SIZE; x++ )
			{
				if( gObj[iIndex].Inventory[x].IsItem() == TRUE )
				{
					if( gObj[iIndex].Inventory[x].m_Index == GET_ITEM(14,31) )
					{
						iGEMOFDEFEND_COUNT += 1;
					}
				}
			}

			if( iGEMOFDEFEND_COUNT < iNEED_GEMOFDEFEND )
			{
				GCAnsNpcUpgrade(iIndex, 4, lpMsg->iNpcNumber, lpMsg->iNpcIndex, lpMsg->iNpcUpType, lpMsg->iNpcUpValue);
				LogAdd(LOG_BLACK,"[CastleSiege] CGReqNpcUpgrade() ERROR - Gem is Low [%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTLV:%d, Gem:%d, Need Gem:%d",	gObj[iIndex].Account,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildNumber,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL,iGEMOFDEFEND_COUNT,iNEED_GEMOFDEFEND);
			}
			else
			{
				bRETVAL = gCastleSiege.PayForUpgradeDbNpc(iIndex,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,(iNXT_UPLVL-1));
				
				if( bRETVAL == FALSE )
				{
				}
				else
				{
					gObj[iIndex].IsCastleNPCUpgradeCompleted = TRUE;
					LogAdd(LOG_BLACK,"[CastleSiege] [0xB2][0x07] CGReqNpcUpgrade() - Pay For Npc Upgrade (CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d)", lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,iNXT_UPVALUE);
					GS_GDReqCastleNpcUpgrade(gMapServerManager.GetMapServerGroup(),iIndex,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,iNXT_UPVALUE,(iNXT_UPLVL-1));
					LogAdd(LOG_BLACK,"[CastleSiege] CGReqNpcUpgrade() REQ OK - [%s][%s], Guild:(%s)(%d), NPC CLS:%d, IDX:%d, UPTYPE:%d, UPVAL:%d, NXTLV:%d", gObj[iIndex].Account,gObj[iIndex].Name,gObj[iIndex].GuildName,gObj[iIndex].GuildNumber,lpMsg->iNpcNumber,lpMsg->iNpcIndex,lpMsg->iNpcUpType,lpMsg->iNpcUpValue,iNXT_UPLVL);
				}	
			}
		}

	}
#endif
}

void GCAnsNpcUpgrade(int iIndex, int iResult, int iNpcNumber, int iNpcIndex, int iNpcUpType, int iNpcUpValue) 
{
#if(GAMESERVER_TYPE==1)
	PMSG_ANS_NPCUPGRADE pMsgResult;

	pMsgResult.h.set(0xB2, 0x07, sizeof(pMsgResult));
	pMsgResult.btResult = iResult;
	pMsgResult.iNpcNumber = iNpcNumber;
	pMsgResult.iNpcIndex = iNpcIndex;
	pMsgResult.iNpcUpType = iNpcUpType;
	pMsgResult.iNpcUpValue = iNpcUpValue;

	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
#endif
}

void CGReqTaxMoneyInfo(PMSG_REQ_TAXMONEYINFO * lpMsg, int iIndex) 
{
#if(GAMESERVER_TYPE==1)
	if( lpMsg == NULL )
	{
		return;
	}

	if( strcmp(gObj[iIndex].GuildName, "") == 0 )
	{
		return;
	}
	
	if( (gCastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE) || (gObj[iIndex].GuildStatus != G_MASTER) )
	{
		LogAdd(LOG_RED,"[CastleSiege] CGReqTaxMoneyInfo() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);
	}
	else
	{
		GS_GDReqTaxInfo(gMapServerManager.GetMapServerGroup(), iIndex);
		LogAdd(LOG_RED,"[CastleSiege] CGReqTaxMoneyInfo() REQ OK - [%s][%s], Guild:(%s)(%d)",	gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);
	}
#endif
}

void GCAnsTaxMoneyInfo(int iIndex, int iResult, BYTE btTaxRateChaos, BYTE btTaxRateStore, __int64 i64Money) 
{
#if (GAMESERVER_TYPE==1)
	PMSG_ANS_TAXMONEYINFO pMsgResult;

	pMsgResult.h.set(0xB2, 0x08, sizeof(pMsgResult));
	pMsgResult.btResult = iResult;
	pMsgResult.btTaxRateChaos = btTaxRateChaos;
	pMsgResult.btTaxRateStore = btTaxRateStore;
	pMsgResult.btMoney1 = SET_NUMBERHB(SET_NUMBERHW(SET_NUMBERHDW(i64Money)));
	pMsgResult.btMoney2 = SET_NUMBERLB(SET_NUMBERHW(SET_NUMBERHDW(i64Money)));
	pMsgResult.btMoney3 = SET_NUMBERHB(SET_NUMBERLW(SET_NUMBERHDW(i64Money)));
	pMsgResult.btMoney4 = SET_NUMBERLB(SET_NUMBERLW(SET_NUMBERHDW(i64Money)));
	pMsgResult.btMoney5 = SET_NUMBERHB( SET_NUMBERHW( SET_NUMBERLDW( i64Money ) ) ) ;
	pMsgResult.btMoney6 = SET_NUMBERLB( SET_NUMBERHW( SET_NUMBERLDW( i64Money ) ) ) ;
	pMsgResult.btMoney7 = SET_NUMBERHB( SET_NUMBERLW( SET_NUMBERLDW( i64Money ) ) ) ;
	pMsgResult.btMoney8 = SET_NUMBERLB( SET_NUMBERLW( SET_NUMBERLDW( i64Money ) ) ) ;

	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
#endif
}

void CGReqTaxRateChange(PMSG_REQ_TAXRATECHANGE * lpMsg, int iIndex) 
{
#if(GAMESERVER_TYPE==1)

	int iMaxTaxRate;
	int iTaxRate;

	if( lpMsg == NULL )
	{
		return;
	}

	if( strcmp(gObj[iIndex].GuildName, "") == 0 )
	{
		return;
	}

	if( (gCastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE) || (gObj[iIndex].GuildStatus != G_MASTER) )
	{
		LogAdd(LOG_RED,"[CastleSiege] CGReqTaxRateChange() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)",	gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);
	}
	else
	{
		iMaxTaxRate = 0;

		switch( lpMsg->btTaxType )
		{
		case 1:
			iMaxTaxRate = 3;
			break;
		case 2:
			iMaxTaxRate = 3;
			break;
		case 3:
			iMaxTaxRate = 300000;
			break;
		}

		iTaxRate = MAKE_NUMBERDW(MAKE_NUMBERW(lpMsg->btTaxRate1, lpMsg->btTaxRate2), MAKE_NUMBERW(lpMsg->btTaxRate3, lpMsg->btTaxRate4)); 

		if( (iTaxRate < 0) || (iTaxRate > iMaxTaxRate) )
		{
			GCAnsTaxRateChange(iIndex,0,0,0);
			LogAdd(LOG_BLACK,"[CastleSiege] CGReqTaxRateChange() ERROR - Tax Rate Out of Range [%s][%s], Guild:(%s)(%d), TaxType:%d, TaxRate:%d", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, lpMsg->btTaxType, iTaxRate);
		}
		else
		{
			GS_GDReqTaxRateChange(gMapServerManager.GetMapServerGroup(), iIndex, lpMsg->btTaxType, iTaxRate);
			LogAdd(LOG_BLACK,"[CastleSiege] CGReqTaxRateChange() REQ OK - [%s][%s], Guild:(%s)(%d), TaxType:%d, TaxRate:%d", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, lpMsg->btTaxType, iTaxRate);
		}
	}
#endif
}

void GCAnsTaxRateChange(int iIndex, int iResult, BYTE btTaxType, int iTaxRate) 
{
#if (GAMESERVER_TYPE==1)
	PMSG_ANS_TAXRATECHANGE pMsgResult;
	pMsgResult.h.set(0xB2, 0x09, sizeof(pMsgResult));
	pMsgResult.btResult = iResult;
	pMsgResult.btTaxType = btTaxType;
	pMsgResult.btTaxRate1 = SET_NUMBERHB(SET_NUMBERHW(iTaxRate));
	pMsgResult.btTaxRate2 = SET_NUMBERLB(SET_NUMBERHW(iTaxRate));
	pMsgResult.btTaxRate3 = SET_NUMBERHB(SET_NUMBERLW(iTaxRate));
	pMsgResult.btTaxRate4 = SET_NUMBERLB(SET_NUMBERLW(iTaxRate));
	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
#endif
}

void CGReqMoneyDrawOut(PMSG_REQ_MONEYDRAWOUT * lpMsg, int iIndex) 
{
#if(GAMESERVER_TYPE==1)
	int iMoneyChange;
	BOOL bRETVAL;

	if( lpMsg == NULL )
	{
		return;
	}

	if( strcmp(gObj[iIndex].GuildName, "") == 0 )
	{
		return;
	}
	
	if( (gCastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE) || (gObj[iIndex].GuildStatus != G_MASTER) )
	{
		LogAdd(LOG_RED,"[CastleSiege] CGReqMoneyDrawOut() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);
	}
	else
	{
		iMoneyChange = MAKE_NUMBERDW(MAKE_NUMBERW(lpMsg->btMoney4, lpMsg->btMoney3), MAKE_NUMBERW(lpMsg->btMoney2, lpMsg->btMoney1));

		if( iMoneyChange <= 0 )
		{
			GCAnsMoneyDrawOut(iIndex, 0, 0);
			LogAdd(LOG_BLACK,"[CastleSiege] CGReqMoneyDrawOut() ERROR - Req Money < 0 [%s][%s], Guild:(%s)(%d), Money:%d, TotMoney:%d",	gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, iMoneyChange, gObj[iIndex].Money);
		}
		else
		{
			bRETVAL = gCastleSiege.CheckCastleHasMoney(iMoneyChange);

			if( bRETVAL == FALSE )
			{
				GCAnsMoneyDrawOut(iIndex, 0, 0);
				LogAdd(LOG_BLACK,"[CastleSiege] CGReqMoneyDrawOut() ERROR - Castle Money is Low [%s][%s], Guild:(%s)(%d), Money:%d, TotMoney:%d", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, iMoneyChange, gObj[iIndex].Money);
			}
			else
			{

				//성주머니
				if( (gObj[iIndex].Money + iMoneyChange) > MAX_MONEY )
				{
					GCAnsMoneyDrawOut(iIndex, 0, 0);
				}
				else
				{
					//int iMoneyChangeGP = (iMoneyChange*0.01)/100;
					//GDSetCoinSend(gObj[iIndex].Index, 0,  0, iMoneyChangeGP,"성주 고포 환전지급");

					GS_GDReqCastleMoneyChange(gMapServerManager.GetMapServerGroup(), iIndex, -iMoneyChange);
					LogAdd(LOG_BLACK,"[CastleSiege] CGReqMoneyDrawOut() REQ OK - [%s][%s], Guild:(%s)(%d), Money:%d, TotMoney:%d", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus, iMoneyChange, gObj[iIndex].Money);
				}
			}
		}
	}
#endif
}

void GCAnsMoneyDrawOut(int iIndex, int iResult, __int64 i64Money) 
{
#if(GAMESERVER_TYPE==1)
	PMSG_ANS_MONEYDRAWOUT pMsgResult;
	pMsgResult.h.set(0xB2, 0x10, sizeof(pMsgResult));
	pMsgResult.btResult = iResult;
	pMsgResult.btMoney1 = SET_NUMBERHB(SET_NUMBERHW(SET_NUMBERHDW(i64Money)));
	pMsgResult.btMoney2 = SET_NUMBERLB(SET_NUMBERHW(SET_NUMBERHDW(i64Money)));
	pMsgResult.btMoney3 = SET_NUMBERHB(SET_NUMBERLW(SET_NUMBERHDW(i64Money)));
	pMsgResult.btMoney4 = SET_NUMBERLB(SET_NUMBERLW(SET_NUMBERHDW(i64Money)));
	pMsgResult.btMoney5 = SET_NUMBERHB( SET_NUMBERHW( SET_NUMBERLDW( i64Money ) ) ) ;
	pMsgResult.btMoney6 = SET_NUMBERLB( SET_NUMBERHW( SET_NUMBERLDW( i64Money ) ) ) ;
	pMsgResult.btMoney7 = SET_NUMBERHB( SET_NUMBERLW( SET_NUMBERLDW( i64Money ) ) ) ;
	pMsgResult.btMoney8 = SET_NUMBERLB( SET_NUMBERLW( SET_NUMBERLDW( i64Money ) ) ) ;
	
	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
#endif
}

void GCAnsCsGateState(int iIndex, int iResult, int iGateIndex) 
{
#if(GAMESERVER_TYPE==1)
	PMSG_ANS_CSGATESTATE pMsgResult;
	pMsgResult.h.set(0xB2, 0x11, sizeof(pMsgResult));
	pMsgResult.btResult = iResult;
	pMsgResult.btIndex1 = SET_NUMBERHB( (iGateIndex &0xffff) );
	pMsgResult.btIndex2 = SET_NUMBERLB( (iGateIndex &0xffff) );
	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
#endif
}

void CGReqCsGateOperate(PMSG_REQ_CSGATEOPERATE * lpMsg, int iIndex) 
{
#if(GAMESERVER_TYPE==1)
	int iGateIndex;

	if( strcmp(gObj[iIndex].GuildName, "") == 0 )
	{
		return;
	}
	
	if( gCastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
	{
		if( gObj[iIndex].CsJoinSide != 1 )
		{
			LogAdd(LOG_BLACK,"[CastleSiege] CGReqCsGateOperate() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);
			return;
		}
	}
	else
	{
		if( (gCastleSiege.CheckCastleOwnerMember(iIndex) == FALSE) && (gCastleSiege.CheckCastleOwnerUnionMember(iIndex) == FALSE) )
		{
			LogAdd(LOG_BLACK,"[CastleSiege] CGReqCsGateOperate() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);
			return;
		}
	}
	
	iGateIndex = MAKE_NUMBERW(lpMsg->btIndex1,lpMsg->btIndex2);

	if( gCastleSiege.CheckCsGateAlive(iGateIndex) == TRUE ) 
	{
		int iOperateGate = gCastleSiege.OperateGate(iGateIndex, gObj[iGateIndex].CsNpcExistVal, lpMsg->btOperate);

		if( iOperateGate == 0 )
		{
			GCAnsCsGateOperate(iIndex, 0, -1, 0);
			LogAdd(LOG_BLACK,"[CastleSiege] CGReqCsGateOperate() ERROR - Operate Gate Failed [%s][%s], Guild:(%s)(%d)",	gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);	
		}
		else
		{
			GCAnsCsGateOperate(iIndex, 1, iGateIndex, lpMsg->btOperate);
			gCastleSiege.SendCsGateStateViewPort(iGateIndex, lpMsg->btOperate);
			LogAdd(LOG_BLACK,"[CastleSiege] CGReqCsGateOperate() OK - [%s][%s], Guild:(%s)(%d), DOOR:(%d)(X:%d,Y:%d)(STATUE:%d)", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildNumber,iGateIndex, gObj[iGateIndex].X, gObj[iGateIndex].Y, gObj[iGateIndex].CsGateOpen);
		}
	}
	else
	{
		GCAnsCsGateOperate(iIndex, 2, -1, 0);
		LogAdd(LOG_BLACK,"[CastleSiege] CGReqCsGateOperate() ERROR - Gate Doesn't Exist [%s][%s], Guild:(%s)(%d)", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);	
	}
#endif
}

void GCAnsCsGateOperate(int iIndex, int iResult, int iGateIndex, int iGateOperate) 
{
#if(GAMESERVER_TYPE==1)
	PMSG_ANS_CSGATEOPERATE pMsgResult;

	pMsgResult.h.set(0xB2, 0x12, sizeof(pMsgResult));
	pMsgResult.btResult = iResult;
	pMsgResult.btOperate = iGateOperate;
	pMsgResult.btIndex1 = SET_NUMBERHB(iGateIndex & 0xffff);
	pMsgResult.btIndex2 = SET_NUMBERLB(iGateIndex & 0xffff);
	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
#endif
}

void GCAnsCsGateCurState(int iIndex, int iGateIndex, int iGateOperate) 
{
#if(GAMESERVER_TYPE==1)
	PMSG_ANS_CSGATECURSTATE pMsgResult;
	pMsgResult.h.set(0xB2, 0x13, sizeof(pMsgResult));
	pMsgResult.btOperate = iGateOperate;
	pMsgResult.btIndex1 = SET_NUMBERHB(iGateIndex & 0xffff);
	pMsgResult.btIndex2 = SET_NUMBERLB(iGateIndex & 0xffff);
	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
#endif
}

void GCAnsCsAccessSwitchState(int iIndex, int iSwitchIndex, int iSwitchUserIndex, BYTE btSwitchState) 
{
#if(GAMESERVER_TYPE==1)
	PMSG_ANS_NOTIFYSWITCHPROC pMsgResult;
	pMsgResult.h.set(0xB2, 0x14, sizeof(pMsgResult));
	pMsgResult.btIndex1 = SET_NUMBERHB(iSwitchIndex & 0xffff);
	pMsgResult.btIndex2 = SET_NUMBERLB(iSwitchIndex & 0xffff);
	pMsgResult.btUserIndex1 = SET_NUMBERHB(iSwitchUserIndex & 0xffff);
	pMsgResult.btUserIndex2 = SET_NUMBERLB(iSwitchUserIndex & 0xffff);
	pMsgResult.btSwitchState = btSwitchState;
	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
#endif
}

void GCAnsCsAccessCrownState(int iIndex, BYTE btCrownState) 
{
#if(GAMESERVER_TYPE==1)
	PMSG_ANS_NOTIFYCROWNPROC pMsgResult;
	pMsgResult.h.set(0xB2, 0x15, sizeof(pMsgResult));
	pMsgResult.btCrownState = btCrownState;

	if( btCrownState == 0 )
	{
		if( gObj[iIndex].AccumulatedCrownAccessTime < 0 || gObj[iIndex].AccumulatedCrownAccessTime > 61000 )
		{
			gObj[iIndex].AccumulatedCrownAccessTime = 0;
		}

		LogAdd(LOG_BLACK,"[CastleSiege] [Reg. Attempt] Accumulated Crown AccessTime : %d [%s](%s)(%s)",	gObj[iIndex].AccumulatedCrownAccessTime,gObj[iIndex].GuildName,gObj[iIndex].Account,gObj[iIndex].Name);
	}

	if( btCrownState == 1 )
	{
		LogAdd(LOG_BLACK,"[CastleSiege] [Reg. Success] Accumulated Crown AccessTime : %d [%s](%s)(%s)",	gObj[iIndex].AccumulatedCrownAccessTime,gObj[iIndex].GuildName,gObj[iIndex].Account,gObj[iIndex].Name);
		gObj[iIndex].AccumulatedCrownAccessTime = 0;
	}

	if( btCrownState == 2 )
	{
		gObj[iIndex].AccumulatedCrownAccessTime += GetTickCount() - gCastleSiege.GetCrownAccessTickCount();

		gObj[iIndex].AccumulatedCrownAccessTime -= gServerInfo.m_CastleSiegeLowerAccumulatedTimeValue;

		if( gObj[iIndex].AccumulatedCrownAccessTime < 0 || gObj[iIndex].AccumulatedCrownAccessTime > 61000 )
		{
			gObj[iIndex].AccumulatedCrownAccessTime = 0;
		}

		LogAdd(LOG_BLACK,"[CastleSiege] [Reg. Fail] Accumulated Crown AccessTime : %d [%s](%s)(%s)", gObj[iIndex].AccumulatedCrownAccessTime,gObj[iIndex].GuildName,gObj[iIndex].Account,gObj[iIndex].Name);
	}

	pMsgResult.dwAccumulatedCrownAccessTime = gObj[iIndex].AccumulatedCrownAccessTime;

	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
#endif
}

void GCAnsCsNotifyStart(int iIndex, BYTE btStartState) 
{
#if(GAMESERVER_TYPE==1)
	PMSG_ANS_NOTIFYCSSTART pMsgResult;
	pMsgResult.h.set(0xB2, 0x17, sizeof(pMsgResult));
	pMsgResult.btStartState = btStartState;
	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
#endif
}

void GCAnsCsNotifyProgress(int iIndex, BYTE btCastleSiegeState, LPCSTR lpszGuildName) 
{
	if ( lpszGuildName == NULL )
	{
		return;
	}

	PMSG_ANS_NOTIFYCSPROGRESS pMsgResult;

	pMsgResult.h.set(0xB2, 0x18, sizeof(pMsgResult));
	pMsgResult.btCastleSiegeState = btCastleSiegeState;
	memset(pMsgResult.szGuildName, 0, sizeof(pMsgResult.szGuildName));
	memcpy(pMsgResult.szGuildName, lpszGuildName, sizeof(pMsgResult.szGuildName));

	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
}

void GCAnsCsMapSvrTaxInfo(int iIndex, BYTE btTaxType, BYTE btTaxRate) 
{
	PMSG_ANS_MAPSVRTAXINFO pMsgResult;
	
	pMsgResult.h.set(0xB2, 0x1A, sizeof(pMsgResult));
	pMsgResult.btTaxType = btTaxType;
	pMsgResult.btTaxRate = btTaxRate;

	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
}

void CGReqCsMiniMapData(PMSG_REQ_MINIMAPDATA * lpMsg, int iIndex) 
{
#if(GAMESERVER_TYPE==1)
	if( gObjIsConnected(iIndex) == FALSE )
	{
		return;
	}

	if( (gObj[iIndex].CsJoinSide <= 0) || ( gCastleSiege.CheckUnionGuildMaster(iIndex) == FALSE ) )
	{
		GCAnsCsMiniMapData(iIndex, 3);
	}
	else if( gCastleSiege.GetCastleState() != CASTLESIEGE_STATE_STARTSIEGE )
	{
		GCAnsCsMiniMapData(iIndex, 2);
	}
	else
	{
		gCastleSiege.AddMiniMapDataReqUser(iIndex);
		GCAnsCsMiniMapData(iIndex, 1);
	}
#endif
}

void GCAnsCsMiniMapData(int iIndex, BYTE btResult) 
{
	PMSG_ANS_MINIMAPDATA pMsgResult;

	pMsgResult.h.set(0xB2, 0x1B, sizeof(pMsgResult));
	pMsgResult.btResult = btResult;

	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
}

void CGReqStopCsMiniMapData(PMSG_REQ_STOPMINIMAPDATA * lpMsg, int iIndex) 
{
#if(GAMESERVER_TYPE==1)
	if( gObjIsConnected(iIndex) == FALSE )
	{
		return;
	}

	gCastleSiege.DelMiniMapDataReqUser(iIndex);
#endif
}

void CGReqCsSendCommand(PMSG_REQ_CSCOMMAND * lpMsg, int iIndex) 
{
#if(GAMESERVER_TYPE==1)
	if( gObjIsConnected(iIndex) == FALSE )
	{
		return;
	}

	if( gObj[iIndex].CsJoinSide <= 0 ||	gCastleSiege.CheckUnionGuildMaster(iIndex) == FALSE )
	{
		return;
	}

	if( gCastleSiege.GetCastleState() != CASTLESIEGE_STATE_STARTSIEGE )
	{
		return;
	}

	GCAnsCsSendCommand(gObj[iIndex].CsJoinSide, lpMsg->btTeam, lpMsg->btX, lpMsg->btY, lpMsg->btCommand);
#endif
}

void GCAnsCsSendCommand(int iCsJoinSize, BYTE btTeam, BYTE btX, BYTE btY, BYTE btCommand) 
{
#if(GAMESERVER_TYPE==1)
	PMSG_ANS_CSCOMMAND pMsgResult;

	pMsgResult.h.set(0xB2, 0x1D, sizeof(pMsgResult));
	
	pMsgResult.btTeam = btTeam;
	pMsgResult.btX = btX;
	pMsgResult.btY = btY;
	pMsgResult.btCommand = btCommand;
	
	for( int iIndex = OBJECT_START_USER; iIndex < MAX_OBJECT; iIndex++ )
	{
		if( gObjIsConnected(iIndex) == FALSE ) continue;

		if( (gObj[iIndex].CsJoinSide == iCsJoinSize) && (gObj[iIndex].Map == MAP_CASTLE_SIEGE) )
		{
			DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
		}
	}
#endif
}

void GCAnsCsLeftTimeAlarm(BYTE btHour, BYTE btMinute) 
{
	PMSG_ANS_CSLEFTTIMEALARM pMsgResult;

	pMsgResult.h.set(0xB2, 0x1E, sizeof(pMsgResult));
	pMsgResult.btHour = btHour;
	pMsgResult.btMinute = btMinute;

	for (int iIndex = OBJECT_START_USER;iIndex < MAX_OBJECT;iIndex++)
	{
		if ( !gObjIsConnected(iIndex) )
		{
			continue;
		}

		DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
	}

}

void GCAnsSelfCsLeftTimeAlarm(int iIndex, BYTE btHour, BYTE btMinute) 
{
	PMSG_ANS_CSLEFTTIMEALARM pMsgResult;

	pMsgResult.h.set(0xB2, 0x1E, sizeof(pMsgResult));
	pMsgResult.btHour = btHour;
	pMsgResult.btMinute = btMinute;

	if ( !gObjIsConnected(iIndex))
	{
		return;
	}

	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
}

void CGReqCsSetEnterHuntZone(PMSG_REQ_CSHUNTZONEENTER * lpMsg, int iIndex) 
{
#if(GAMESERVER_TYPE==1)
	if( gObjIsConnected(iIndex) == FALSE )
	{
		return;
	}
	
	if( gCastleSiege.CheckCastleOwnerMember(iIndex) == FALSE )
	{
		GCAnsCsSetEnterHuntZone(iIndex, 2, lpMsg->btHuntZoneEnter);
	}
	else if( gCastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE )
	{
		GCAnsCsSetEnterHuntZone(iIndex, 0, lpMsg->btHuntZoneEnter);
	}
	else
	{
		gCastleSiege.SetHuntZoneEnter(lpMsg->btHuntZoneEnter);
		GCAnsCsSetEnterHuntZone(iIndex, 1, lpMsg->btHuntZoneEnter);
	}

#endif
}

void GCAnsCsSetEnterHuntZone(int iIndex, BYTE btResult, BYTE btEnterHuntZone) 
{
	PMSG_ANS_CSHUNTZONEENTER pMsgResult;

	pMsgResult.h.set(0xB2, 0x1F, sizeof(pMsgResult));
	pMsgResult.btResult = btResult;
	pMsgResult.btHuntZoneEnter = btEnterHuntZone;

	DataSend(iIndex, (LPBYTE)&pMsgResult, pMsgResult.h.size);
}

void CGReqNpcDbList(PMSG_REQ_NPCDBLIST * lpMsg, int iIndex) 
{
#if(GAMESERVER_TYPE==1)
	PMSG_ANS_NPCDBLIST pResult;

	if( lpMsg == NULL )
	{
		return;
	}

	if( strcmp(gObj[iIndex].GuildName, "") == 0 )
	{
		return;
	}
	
	if( gCastleSiege.CheckGuildOwnCastle(gObj[iIndex].GuildName) == FALSE || ( (gObj[iIndex].GuildStatus != 128) && (gObj[iIndex].GuildStatus != 64) ) )
	{
		LogAdd(LOG_RED, "[CastleSiege] CGReqNpcDbList() ERROR - Authority Fail [%s][%s], Guild:(%s)(%d)", gObj[iIndex].Account, gObj[iIndex].Name, gObj[iIndex].GuildName, gObj[iIndex].GuildStatus);
		pResult.h.set(0xB3, sizeof(pResult));
		pResult.iCount = 0;
		pResult.btResult = 2;
		DataSend(iIndex, (LPBYTE)&pResult, sizeof(pResult));
	}
	else
	{
		switch( lpMsg->btMonsterCode )
		{
		case 1:
			gCastleSiege.SendNpcStateList(iIndex, 277);
			break;
		case 2:
			gCastleSiege.SendNpcStateList(iIndex, 283);
			break;
		}
	}
#endif
}

void CGReqCsRegGuildList(PMSG_REQ_CSREGGUILDLIST * lpMsg, int iIndex) 
{
#if(GAMESERVER_TYPE==1)
	if( lpMsg == NULL ) return;

	GS_GDReqAllGuildMarkRegInfo(gMapServerManager.GetMapServerGroup(), iIndex);
#endif
}

void CGReqCsAttkGuildList(PMSG_REQ_CSATTKGUILDLIST * lpMsg, int iIndex) 
{
#if(GAMESERVER_TYPE==1)
	char cBUFFER[1625];
	PMSG_ANS_CSATTKGUILDLIST* lpMsgSend;
	PMSG_CSATTKGUILDLIST* lpMsgSendBody;
	int iCount;

	if( lpMsg == NULL )	return;
	
	lpMsgSend = (PMSG_ANS_CSATTKGUILDLIST*)(cBUFFER);
	lpMsgSendBody = (PMSG_CSATTKGUILDLIST*)(cBUFFER+sizeof(PMSG_ANS_CSATTKGUILDLIST));

	iCount = 0;

	lpMsgSend->btResult = gCastleSiege.GetCsAttkGuildList(lpMsgSendBody, iCount);
	lpMsgSend->iCount = iCount;

	if( lpMsgSend->iCount < 0 )	 lpMsgSend->iCount = 0;
	if( lpMsgSend->iCount > 100 )lpMsgSend->iCount = 100;

	lpMsgSend->h.set( 0xB5, ((lpMsgSend->iCount*sizeof(PMSG_CSATTKGUILDLIST))+sizeof(PMSG_ANS_CSATTKGUILDLIST)));
	DataSend(iIndex, (LPBYTE)lpMsgSend, ((lpMsgSend->iCount*sizeof(PMSG_CSATTKGUILDLIST))+sizeof(PMSG_ANS_CSATTKGUILDLIST)));
#endif
}

void CGReqGuildMarkOfCastleOwner(PMSG_REQ_GUILDMARK_OF_CASTLEOWNER * aRecv, int iIndex) 
{
	if ( !OBJECT_RANGE(iIndex) )
	{
		return;
	}

	LPOBJ lpObj = &gObj[iIndex];
	char szGuildName[9] = {0};

	memcpy(szGuildName, gCastleSiegeSync.GetCastleOwnerGuild(), 8);

	if ( szGuildName )
	{
		GUILD_INFO_STRUCT * lpGuild = gGuildClass.SearchGuild(szGuildName);

		if ( lpGuild != NULL )
		{
			PMSG_ANS_GUILDMARK_OF_CASTLEOWNER pMsg = {0};

			pMsg.h.set(0xB9, 0x02, sizeof(pMsg));
			memcpy(pMsg.GuildMarkOfCastleOwner, lpGuild->Mark, sizeof(pMsg.GuildMarkOfCastleOwner));

			DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));
		}
	}
}

void CGReqCastleHuntZoneEntrance(PMSG_REQ_MOVE_TO_CASTLE_HUNTZONE * aRecv, int iIndex) 
{
#if(GAMESERVER_TYPE==1)
	if( !OBJECT_RANGE(iIndex) )
	{
		return;
	}
	
	LPOBJ lpObj = &gObj[iIndex];

	PMSG_ANS_MOVE_TO_CASTLE_HUNTZONE pMsg = {0};

	pMsg.h.set(0xB9, 0x05, sizeof(pMsg));

	pMsg.btResult = 0;

	int iEnterTaxMoney = 0;

	iEnterTaxMoney = gCastleSiegeSync.GetTaxHuntZone(lpObj->Index, TRUE);

	if( iEnterTaxMoney < 0)
	{
		iEnterTaxMoney = 0;
	}

	BOOL bPermission = FALSE;

	if( gCastleSiege.GetHuntZoneEnter() )
	{
		bPermission = TRUE;
	}

	if( lpObj->Guild )
	{
		if( gCastleSiege.CheckCastleOwnerMember(lpObj->Index) )
		{
			bPermission = TRUE;
		}

		if( gCastleSiege.CheckCastleOwnerUnionMember(lpObj->Index) )
		{
			bPermission = TRUE;
		}
	}
	else
	{
		if( gCastleSiege.GetHuntZoneEnter() )
		{
			bPermission = TRUE;
		}
	}

	if( bPermission == TRUE )
	{
		if( lpObj->Coin3 >= ((DWORD)iEnterTaxMoney) )
		{
			if( lpObj->Map == MAP_CASTLE_SIEGE )
			{
				if( gObjMoveGate(lpObj->Index, 95) == TRUE )
				{
					pMsg.btResult = 1;
					int iOldMoney = lpObj->Coin3;

					lpObj->Coin3 -= iEnterTaxMoney;

					gCastleSiegeSync.AddTributeMoney(iEnterTaxMoney);
					
					if( lpObj->Coin3 < 0)
					{
						lpObj->Coin3 = 0;
					}
					
					gCashShop.GDCashShopSubPointSaveSend(lpObj->Index, 0, 0, 0, iEnterTaxMoney);
					gCashShop.CGCashShopPointRecv(lpObj->Index);

					LogAdd(LOG_BLACK,"[Castle HuntZone] [%s][%s] - Entrance TAX : %d - %d = %d", lpObj->Account, lpObj->Name, iOldMoney, iEnterTaxMoney, lpObj->Coin3);
				}
			}
		}
	}

	DataSend(iIndex, (LPBYTE)&pMsg, sizeof(pMsg));
#endif
}


//창고
void CGWarehouseOpen(PMSG_WAREHOUSEINTERFACE_RECV* lpMsg, int aIndex)
{

	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Interface.use != 0)
	{
		return;
	}


	//캐시샵  버그
	if (lpObj->Interface.type == INTERFACE_CHAOS_BOX || lpObj->Interface.type == INTERFACE_TRADE || lpObj->Interface.type == INTERFACE_PERSONAL_SHOP || lpObj->Interface.type == INTERFACE_SHOP)
	{
		return;
	}
	if (gItemManager.ChaosBoxHasItem(lpObj) || gItemManager.TradeHasItem(lpObj))
	{
		return;
	}
	//

	//if(gServerInfo.m_CommandOpenWareOnlySafeZone == 1 && gMap[lpObj->Map].CheckAttr(lpObj->X,lpObj->Y,1) == 0)
	//{
	//	gNotice.GCNoticeSend(lpObj->Index,1,0,0,0,0,0,gMessage.GetMessage(631));
	//	return;
	//}

	lpObj->Interface.use = 1;
	lpObj->Interface.type = INTERFACE_WAREHOUSE;
	lpObj->Interface.state = 0;
	

	gWarehouse.GDWarehouseItemSend(lpObj->Index,lpObj->Account);
}

//상점
void CGShopOpen(PMSG_SHOPINTERFACE_RECV* lpMsg, int aIndex)
{

	LPOBJ lpObj = &gObj[aIndex];

	if (lpMsg->Type == 0)
	{

	if(lpObj->Interface.use != 0)
	{
		return;
	}

	//캐시샵  버그
	if (lpObj->Interface.type == INTERFACE_CHAOS_BOX || lpObj->Interface.type == INTERFACE_TRADE || lpObj->Interface.type == INTERFACE_WAREHOUSE || lpObj->Interface.type == INTERFACE_PERSONAL_SHOP)
	{
		return;
	}
	if (gItemManager.ChaosBoxHasItem(lpObj) || gItemManager.TradeHasItem(lpObj))
	{
		return;
	}
	//
					struct PMSG_NPC_TALK_SEND
					{
						PBMSG_HEAD header; // C3:30
						BYTE result;
						BYTE level[7];
					};

					int ShopNum = 5;

					PMSG_NPC_TALK_SEND pMsg;

					lpObj->TargetShopNumber = ShopNum;

					lpObj->Interface.use = 1;
					lpObj->Interface.type = INTERFACE_SHOP;
					lpObj->Interface.state = 0;
					lpObj->ShopDelay = GetTickCount();
					//lpObj->ItemshopDelay = GetTickCount();

					pMsg.header.setE(0x30,sizeof(pMsg));

					pMsg.result = 0;

					DataSend(lpObj->Index,(BYTE*)&pMsg,pMsg.header.size);
					gShopManager.GCShopItemListSendByIndex(ShopNum,lpObj->Index);

					GCTaxInfoSend(aIndex,2,gCastleSiegeSync.GetTaxRateStore(aIndex));
	}
			
}


void GCSendPing(int aIndex)
{
	PMSG_PING pMsgPing;
	pMsgPing.h.set(0xFE,sizeof(pMsgPing));
	DataSend(aIndex,(BYTE*)&pMsgPing,sizeof(pMsgPing));
}

void RPSMode(LPOBJ lpUser, RPSMODE_REQ *aRecv)
{
	lpUser->RPSMode = aRecv->Number;
}
void RPSModeInface(int aIndex)
{
	RPSMODE_INTERFACE pMsg;
	pMsg.header.set(0xFB, 0x22, sizeof(pMsg));
	DataSend(aIndex, (BYTE*)&pMsg, pMsg.header.size);
}

void ChatSend(LPOBJ lpObj, char* szChat)
{
	int size = strlen(szChat);
	size = ((size>MAX_CHAT_MESSAGE_SIZE) ? MAX_CHAT_MESSAGE_SIZE : size);
	PMSG_CHAT_TARGET_SEND pMsg;
	pMsg.header.set(0x01, (sizeof(pMsg)-(sizeof(pMsg.message) - (size + 1))));
	//strcpy(pMsg.message, szChat);
	pMsg.index[0] = SET_NUMBERHB(lpObj->Index);
	pMsg.index[1] = SET_NUMBERLB(lpObj->Index);
	memcpy(pMsg.message, szChat, size);
	pMsg.message[size] = 0;
	MsgSendV2(lpObj, (BYTE*)&pMsg, pMsg.header.size);
}



////////////////////////////////////(SERVER) USER.H
#pragma once

//#include "CommandManager.h"
#include "ComboSkill.h"
#include "Effect.h"
#include "Item.h"
#include "MonsterAIAgro.h"
#include "MonsterSkillElementOption.h"
#include "Skill.h"
#include "Achievements.h"

#if(GAMESERVER_TYPE==0)

#define MAX_OBJECT 10000
#define MAX_OBJECT_MONSTER 8000
#define MAX_OBJECT_USER 1000
#define MAX_OBJECT_USER_AND_BOTS 2000 //MC bot
#define MAX_OBJECT_BOTS 200

#else

#define MAX_OBJECT 4500
#define MAX_OBJECT_MONSTER 2500
#define MAX_OBJECT_USER 1000
#define MAX_OBJECT_USER_AND_BOTS 2000 //MC bot
#define MAX_OBJECT_BOTS 200

#endif

#define OBJECT_START_BOTS 0
#define OBJECT_START_MONSTER 0
#define OBJECT_START_USER (MAX_OBJECT-MAX_OBJECT_USER)
#define OBJECT_START_USER_AND_BOTS (MAX_OBJECT-MAX_OBJECT_USER_AND_BOTS) // MC EMPIEZA DESDE LOS USER SIGE POR LOS BOT Y TERMINA

#define MAX_SELF_DEFENSE 5
#define MAX_HIT_DAMAGE 40
#define MAX_VIEWPORT 75
#define MAX_GUILD_USER 80
#define MAX_MONEY 2000000000
#define MAX_CHECKSUM_KEY 1024
#define MAX_CHARACTER_LEVEL 10000 //최대레벨
#define MAX_ACCOUNT_LEVEL 4
#define MAX_DAMAGE_REDUCTION 6
#define MAX_MESSAGE_SIZE 255
#define MAX_CHAT_MESSAGE_SIZE 59
#define MAX_ROAD_PATH_TABLE 16
#define MAX_MONSTER_SEND_MSG 20
#define MAX_MONSTER_SEND_ATTACK_MSG 30

#define OBJECT_RANGE(x) (((x)<0)?0:((x)>=MAX_OBJECT)?0:1)
#define OBJECT_MONSTER_RANGE(x) (((x)<OBJECT_START_MONSTER)?0:((x)>=MAX_OBJECT_MONSTER)?0:1)
#define OBJECT_SUMMON_RANGE(x) (((x)<MAX_OBJECT_MONSTER)?0:((x)>=OBJECT_START_USER)?0:1)
#define OBJECT_USER_RANGE(x) (((x)<OBJECT_START_USER)?0:((x)>=MAX_OBJECT)?0:1)
#define GET_MAX_RESISTANCE(x,y,z) (((((x)>(y))?(x):(y))>(z))?(((x)>(y))?(x):(y)):(z))
#define GET_MAX_WORD_VALUE(x) (((x)>65000)?65000:((WORD)(x)))
#define CHECK_RANGE(x,y) (((x)<0)?0:((x)>=(y))?0:1)
#define OBJECT_BOTS_RANGE(x) (((x)<OBJECT_START_BOTS)?0:((x)>=OBJECT_BOTS)?0:1)

//MC
#define OBJ_STARTUSERINDEX			(MAX_OBJECT-MAX_OBJECT_USER)
#define OBJMAX_RANGE(aIndex)		(((aIndex) < 0 )?FALSE:( (aIndex) > MAX_OBJECT-1 )?FALSE:TRUE)
#define CS_SET_CHANGEUP(x)			(((x) << 4) & 0x10)
#define MAX_EXTENDED_INV			2
#define EXTENDED_INV_SIZE			32
#define MAX_ACCOUNT_LEN				10
#define CURRENT_DB_VERSION			3
#define BASIC_INV_HEIGHT			8
#define EXTENDED_INV_HEIGHT			4
//MC


#if (BOT_STORE == 1)
enum
{
	Type_Player = 0,
	Type_Pet = 1,
	Type_Alchemist = 2,
	Type_Buffer = 3,
	Type_Store = 4,
	Type_Trader = 5,
	Type_Reset = 6,
	Type_PK = 7,
	Type_Warper = 10,
	Type_Racer = 11,
	Type_Reward = 12,
	Type_Hiden = 13,
};
#endif

enum eObjectConnectState
{
	OBJECT_OFFLINE = 0,
	OBJECT_CONNECTED = 1,
	OBJECT_LOGGED = 2,
	OBJECT_ONLINE = 3,
};

enum eObjectType
{
	OBJECT_NONE = 0,
	OBJECT_USER = 1,
	OBJECT_MONSTER = 2,
	OBJECT_NPC = 3,
	OBJECT_ITEM = 5,
	OBJECT_BOTS	= 6,//MC
};

enum eObjectState
{
	OBJECT_EMPTY = 0,
	OBJECT_CREATE = 1,
	OBJECT_PLAYING = 2,
	OBJECT_DYING = 4,
	OBJECT_DIECMD = 8,
	OBJECT_DIED = 16,
	OBJECT_DELCMD = 32,
};

enum eInterfaceType
{
	INTERFACE_NONE = 0,
	INTERFACE_TRADE = 1,
	INTERFACE_PARTY = 2,
	INTERFACE_SHOP = 3,
	INTERFACE_GUILD = 4,
	INTERFACE_GUILD_CREATE = 5,
	INTERFACE_WAREHOUSE = 6,
	INTERFACE_CHAOS_BOX = 7,
	INTERFACE_PERSONAL_SHOP = 8,
	INTERFACE_GOLDEN_ARCHER = 9,
	INTERFACE_QUEST = 10,
	INTERFACE_TRANSFER = 11,
	INTERFACE_COMMON = 12,
	INTERFACE_TRAINER = 13,
	INTERFACE_CASTLE_SIEGE_WEAPON_OFFENSE = 15,
	INTERFACE_CASTLE_SIEGE_WEAPON_DEFENSE = 16,
	INTERFACE_QUEST_WORLD = 17,
	INTERFACE_CASH_SHOP = 18,
	INTERFACE_MINING = 19,
};

enum eActionType
{
	ACTION_ATTACK1 = 120,
	ACTION_ATTACK2 = 121,
	ACTION_STAND1 = 122,
	ACTION_STAND2 = 123,
	ACTION_MOVE1 = 124,
	ACTION_MOVE2 = 125,
	ACTION_DAMAGE1 = 126,
	ACTION_DIE1 = 127,
	ACTION_SIT1 = 128,
	ACTION_POSE1 = 129,
	ACTION_HEALING1 = 130,
	ACTION_GREETING1 = 131,
	ACTION_GOODBYE1 = 132,
	ACTION_CLAP1 = 133,
	ACTION_GESTURE1 = 134,
	ACTION_DIRECTION1 = 135,
	ACTION_UNKNOWN1 = 136,
	ACTION_CRY1 = 137,
	ACTION_CHEER1 = 138,
	ACTION_AWKWARD1 = 139,
	ACTION_SEE1 = 140,
	ACTION_WIN1 = 141,
	ACTION_SMILE1 = 142,
	ACTION_SLEEP1 = 143,
	ACTION_COLD1 = 144,
	ACTION_AGAIN1 = 145,
	ACTION_RESPECT1 = 146,
	ACTION_SALUTE1 = 147,
	ACTION_RUSH1 = 148,
	ACTION_SCISSORS = 149,
	ACTION_ROCK = 150,
	ACTION_PAPER = 151,
	ACTION_HUSTLE = 152,
	ACTION_PROVOCATION = 153,
	ACTION_LOOK_AROUND = 154,
	ACTION_CHEERS = 155,
	ACTION_HANDCLAP = 156,
	ACTION_POINTDANCE = 157,
	ACTION_JACK1 = 158,
	ACTION_JACK2 = 159,
	ACTION_SANTA1_1 = 160,
	ACTION_SANTA1_2 = 161,
	ACTION_SANTA1_3 = 162,
	ACTION_SANTA2_1 = 163,
	ACTION_SANTA2_2 = 164,
	ACTION_SANTA2_3 = 165,
	ACTION_RAGEBUFF_1 = 166,
	ACTION_RAGEBUFF_2 = 167,
	ACTION_PICKAXE = 168,
};

enum eDamageReductionType
{
	DAMAGE_REDUCTION_EXCELLENT_ITEM = 0,
	DAMAGE_REDUCTION_SET_ITEM = 1,
	DAMAGE_REDUCTION_JOH_ITEM = 2,
	DAMAGE_REDUCTION_380_ITEM = 3,
	DAMAGE_REDUCTION_MASTER_SKILL_TREE = 4,
	DAMAGE_REDUCTION_SOCKET_ITEM = 5,
};

enum eExperienceType
{
	EXPERIENCE_COMMON = 0,
	EXPERIENCE_PARTY = 1,
	EXPERIENCE_QUEST = 2,
	EXPERIENCE_DEVIL_SQUARE = 3,
	EXPERIENCE_BLOOD_CASTLE = 4,
	EXPERIENCE_CHAOS_CASTLE = 5,
	EXPERIENCE_CRYWOLF = 6,
	EXPERIENCE_ILLUSION_TEMPLE = 7,
	EXPERIENCE_IMPERIAL_GUARDIAN = 8,
};

struct MESSAGE_STATE_MACHINE
{
	MESSAGE_STATE_MACHINE() // OK
	{
		this->Clear();
	}

	void Clear() // OK
	{
		this->MsgCode = -1;
		this->SendUser = -1;
		this->MsgTime = 0;
		this->SubCode = 0;
	}

	int MsgCode;
	int SendUser;
	int MsgTime;
	int SubCode;
};

struct MESSAGE_STATE_MACHINE_COMMON
{
	MESSAGE_STATE_MACHINE_COMMON() // OK
	{
		this->CommonStruct = new MESSAGE_STATE_MACHINE;

		for(int n=0;n < MAX_MONSTER_SEND_MSG;n++){this->ObjectStruct[n] = this->CommonStruct;}
	}

	MESSAGE_STATE_MACHINE& operator[](int index) // OK
	{
		return (*this->ObjectStruct[index]);
	}

	MESSAGE_STATE_MACHINE* CommonStruct;
	MESSAGE_STATE_MACHINE* ObjectStruct[MAX_MONSTER_SEND_MSG];
};

struct MESSAGE_STATE_MACHINE_HEADER
{
	MESSAGE_STATE_MACHINE_HEADER() // OK
	{
		this->CommonStruct = new MESSAGE_STATE_MACHINE_COMMON;

		for(int n=0;n < MAX_OBJECT;n++){this->ObjectStruct[n] = this->CommonStruct;}
	}

	MESSAGE_STATE_MACHINE_COMMON& operator[](int index) // OK
	{
		return (*this->ObjectStruct[index]);
	}

	MESSAGE_STATE_MACHINE_COMMON* CommonStruct;
	MESSAGE_STATE_MACHINE_COMMON* ObjectStruct[MAX_OBJECT];
};

struct MESSAGE_STATE_ATTACK_MACHINE
{
	MESSAGE_STATE_ATTACK_MACHINE() // OK
	{
		this->Clear();
	}

	void Clear() // OK
	{
		this->MsgCode = -1;
		this->SendUser = -1;
		this->MsgTime = 0;
		this->SubCode = 0;
		this->SubCode2 = 0;
	}

	int MsgCode;
	int SendUser;
	int MsgTime;
	int SubCode;
	int SubCode2;
};

struct MESSAGE_STATE_ATTACK_MACHINE_COMMON
{
	MESSAGE_STATE_ATTACK_MACHINE_COMMON() // OK
	{
		this->CommonStruct = new MESSAGE_STATE_ATTACK_MACHINE;

		for(int n=0;n < MAX_MONSTER_SEND_ATTACK_MSG;n++){this->ObjectStruct[n] = this->CommonStruct;}
	}

	MESSAGE_STATE_ATTACK_MACHINE& operator[](int index) // OK
	{
		return (*this->ObjectStruct[index]);
	}

	MESSAGE_STATE_ATTACK_MACHINE* CommonStruct;
	MESSAGE_STATE_ATTACK_MACHINE* ObjectStruct[MAX_MONSTER_SEND_ATTACK_MSG];
};

struct MESSAGE_STATE_ATTACK_MACHINE_HEADER
{
	MESSAGE_STATE_ATTACK_MACHINE_HEADER() // OK
	{
		this->CommonStruct = new MESSAGE_STATE_ATTACK_MACHINE_COMMON;

		for(int n=0;n < MAX_OBJECT;n++){this->ObjectStruct[n] = this->CommonStruct;}
	}

	MESSAGE_STATE_ATTACK_MACHINE_COMMON& operator[](int index) // OK
	{
		return (*this->ObjectStruct[index]);
	}

	MESSAGE_STATE_ATTACK_MACHINE_COMMON* CommonStruct;
	MESSAGE_STATE_ATTACK_MACHINE_COMMON* ObjectStruct[MAX_OBJECT];
};

struct EFFECT_OPTION
{
	int AddPhysiDamage;
	int AddMagicDamage;
	int AddCurseDamage;
	int AddMinPhysiDamage;
	int AddMaxPhysiDamage;
	int AddMinMagicDamage;
	int AddMaxMagicDamage;
	int AddMinCurseDamage;
	int AddMaxCurseDamage;
	int AddAttackSuccessRate;
	int AddPhysiSpeed;
	int AddMagicSpeed;
	int AddDefense;
	int AddDefenseSuccessRate;
	int AddMaxHP;
	int AddMaxMP;
	int AddMaxBP;
	int AddMaxSD;
	int AddStrength;
	int AddDexterity;
	int AddVitality;
	int AddEnergy;
	int AddLeadership;
	int AddDamageReduction;
	int AddDamageReflect;
	int AddCriticalDamageRate;
	int AddCriticalDamage;
	int AddExcellentDamageRate;
	int AddExcellentDamage;
	int AddExperienceRate;
	int AddMasterExperienceRate;
	int AddVolcanoExperienceRate;
	int AddPartyBonusExperienceRate;
	int AddIgnoreDefenseRate;
	int AddItemDropRate;
	int AddHPRecovery;
	int AddMPRecovery;
	int AddBPRecovery;
	int AddSDRecovery;
	int AddHPRecoveryRate;
	int AddMPRecoveryRate;
	int AddBPRecoveryRate;
	int AddSDRecoveryRate;
	int AddSwordPowerDamageRate;
	int AddSwordPowerDefenseRate;
	int SubDefense;
	int MulPhysiDamage;
	int MulMagicDamage;
	int MulCurseDamage;
	int MulAttackSuccessRate;
	int MulPhysiSpeed;
	int MulMagicSpeed;
	int MulDefense;
	int MulDefenseSuccessRate;
	int MulMaxHP;
	int MulMaxMP;
	int MulMaxBP;
	int MulMaxSD;
	int DivPhysiDamage;
	int DivMagicDamage;
	int DivCurseDamage;
	int DivAttackSuccessRate;
	int DivPhysiSpeed;
	int DivMagicSpeed;
	int DivDefense;
	int DivDefenseSuccessRate;
	int DivMaxHP;
	int DivMaxMP;
	int DivMaxBP;
	int DivMaxSD;
};

struct PENTAGRAM_OPTION
{
	int MulPentagramDamage;
	int MulPentagramDefense;
	int AddElementalCriticalDamageRate;
	int AddElementalDefenseTransferRate;
	int AddElementalAttackTransferRate;
	int MulElementalDefenseSuccessRate;
	int MulElementalAttackSuccessRate;
};

struct PENTAGRAM_JEWEL_OPTION
{
	int AddElementalDamage;
	int AddElementalDamagePvP;
	int AddElementalDamagePvM;
	int AddElementalDamageRange;
	int AddElementalDamageMelee;
	int MulElementalDamagePvP;
	int MulElementalDamagePvM;
	int MulElementalDamageVsFire;
	int MulElementalDamageVsWater;
	int MulElementalDamageVsEarth;
	int MulElementalDamageVsWind;
	int MulElementalDamageVsDark;
	int AddElementalDefense;
	int AddElementalDefensePvP;
	int AddElementalDefensePvM;
	int AddElementalDefenseRange;
	int AddElementalDefenseMelee;
	int MulElementalDefenseVsFire;
	int MulElementalDefenseVsWater;
	int MulElementalDefenseVsEarth;
	int MulElementalDefenseVsWind;
	int MulElementalDefenseVsDark;
	int MulElementalAttackSuccessRate;
	int MulElementalDefenseSuccessRate;
	int AddElementalDamageReductionPvP;
	int AddElementalDamageReductionPvM;
	int AddElementalSlowRate;
	int AddElementalDebuffRate;
	int AddElementalCriticalDamageRatePvP;
	int AddElementalCriticalDamageRatePvM;
	int AddElementalExcellentDamageRatePvP;
	int AddElementalExcellentDamageRatePvM;
};

struct ACTION_STATE
{
	DWORD Rest:1;
	DWORD Attack:1;
	DWORD Move:1;
	DWORD Escape:1;
	DWORD Emotion:4;
	DWORD EmotionCount:8;
};

struct VIEWPORT_STRUCT
{
	#pragma pack(1)
	BYTE state;
	shrt index;
	BYTE type;
	#pragma pack()
};

struct HIT_DAMAGE_STRUCT
{
	int index;
	int damage;
	DWORD time;
};

struct INTERFACE_STATE
{
	DWORD use:2;
	DWORD state:4;
	DWORD type:10;
};

//뱅크
struct BANKEX_USER_DATA
{
	long Money;
	long JBless;
	long JSoul;
	long JChaos;
	long JCreation;
	long JLife;
	long JHarmony;
};
//

struct OBJECTSTRUCT
{
	DWORD BlessTime;
	 DWORD AntidoteDelay;    // 해독약 딜레이
	//int gPKWinStreak[MAX_OBJECT] = {0}; // 모든 객체의 연승을 저장, 0으로 초기화
	int Index;
	int Connected;
	char LoginMessageSend;
	char LoginMessageCount;
	char CloseCount;
	char CloseType;
	BOOL EnableDelCharacter;
	struct PER_SOCKET_CONTEXT* PerSocketContext;
	SOCKET Socket;
	char IpAddr[16];
	//char HardwareId[36]; //하드
	BYTE ClassCode;
	BYTE ClassFlag;
	DWORD AutoSaveTime;
	DWORD ConnectTickCount;
	DWORD ClientTickCount;
	DWORD ServerTickCount;
	BYTE CheckTickCount;
	DWORD PostTime;
	DWORD TimeCount;
	DWORD PKTickCount;
	short CheckSumTableNum;
	DWORD CheckSumTime;
	WORD Type;
	BYTE Live;
	char Account[11];
	char Name[11];
	char Password[11];	//접속종료
	char PersonalCode[14];
	CComboSkill ComboSkill;
	WORD Class;
	BYTE DBClass;
	BYTE ChangeUp;
	short Level;
	int LevelUpPoint;
	WORD FruitAddPoint;
	WORD FruitSubPoint;
	//경험치
	QWORD Experience;
	QWORD NextExperience;
	//DWORD Experience;
	//DWORD NextExperience;
	DWORD Money;
	int Strength;
	int Dexterity;
	int Vitality;
	int Energy;
	int Leadership;
	float Life;
	float MaxLife;
	float ScriptMaxLife;
	float Mana;
	float MaxMana;
	WORD ChatLimitTime;
	BYTE ChatLimitTimeSec;
	int AddStrength;
	int AddDexterity;
	int AddVitality;
	int AddEnergy;
	int AddLeadership;
	int BP;
	int MaxBP;
	int AddBP;
	float VitalityToLife;
	float EnergyToMana;
	char PKCount;
	char PKLevel;
	int PKTime;
	short X;
	short Y;
	BYTE Dir;
	BYTE Map;
	int AddLife;
	int AddMana;
	int Shield;
	int MaxShield;
	int AddShield;
	BYTE StartX;
	BYTE StartY;
	short OldX;
	short OldY;
	short TX;
	short TY;
	short MTX;
	short MTY;
	int PathCount;
	int PathCur;
	char PathStartEnd;
	short PathOri[15];
	short PathX[15];
	short PathY[15];
	char PathDir[15];
	DWORD PathTime;
	DWORD Authority;
	DWORD AuthorityCode;
	DWORD Penalty;
	BYTE AccountItemBlock;
	ACTION_STATE ActionState;
	BYTE ActionNumber;
	DWORD State;
	BYTE Rest;
	char ViewState;
	DWORD LastMoveTime;
	DWORD LastAttackTime;
	DWORD TeleportTime;
	char Teleport;
	char KillerType;
	char DieRegen;
	char RegenOk;
	BYTE RegenMapNumber;
	BYTE RegenMapX;
	BYTE RegenMapY;
	DWORD RegenTime;
	DWORD MaxRegenTime;
	short PosNum;
	DWORD CurActionTime;
	DWORD NextActionTime;
	DWORD DelayActionTime;
	char DelayLevel;
	int DrinkSpeed;
	DWORD DrinkLastTime;
	DWORD MonsterDeleteTime;
	char KalimaGateExist;
	int KalimaGateIndex;
	char KalimaGateEnterCount;
	OBJECTSTRUCT* AttackObj;
	bool AttackerKilled;
	int SelfDefense[MAX_SELF_DEFENSE];
	DWORD SelfDefenseTime[MAX_SELF_DEFENSE];
	DWORD MySelfDefenseTime;
	int PartyNumber;
	int PartyTargetUser;
	int GuildNumber;
	struct GUILD_INFO_STRUCT* Guild;
	char GuildName[11];
	int GuildStatus;
	int GuildUnionTimeStamp;
	int SummonIndex;
	int Change;
	short TargetNumber;
	short TargetShopNumber;
	short ShopNumber;
	short LastAttackerID;
	int PhysiDamageMin;
	int PhysiDamageMax;
	int MagicDamageMin;
	int MagicDamageMax;
	int CurseDamageMin;
	int CurseDamageMax;
	int PhysiDamageMaxLeft;
	int PhysiDamageMinLeft;
	int PhysiDamageMaxRight;
	int PhysiDamageMinRight;
	int DKDamageMultiplierRate;
	int DWDamageMultiplierRate;
	int FEDamageMultiplierRate;
	int DLDamageMultiplierRate;
	int MGDamageMultiplierRate;
	int SUDamageMultiplierRate;
	//int RFDamageMultiplierRate[3];
	int RFDamageMultiplierRate;
	int AttackSuccessRate;
	int PhysiSpeed;
	int MagicSpeed;
	int Defense;
	int MagicDefense;
	int DefenseSuccessRate;
	#if(GAMESERVER_UPDATE>=701)
	int ElementalAttribute;
	int ElementalPattern;
	int ElementalDefense;
	int ElementalDamageMin;
	int ElementalDamageMax;
	int ElementalAttackSuccessRate;
	int ElementalDefenseSuccessRate;
	#endif
	short MoveSpeed;
	short MoveRange;
	short AttackRange;
	short AttackType;
	short ViewRange;
	short Attribute;
	short ItemRate;
	short MoneyRate;
	CSkill* SkillBackup;
	CSkill* Skill;
	WORD MultiSkillIndex;
	WORD MultiSkillCount;
	WORD RageFighterSkillIndex;
	WORD RageFighterSkillCount;
	WORD RageFighterSkillTarget;
	BYTE CharSet[18];
	BYTE Resistance[MAX_RESISTANCE_TYPE];
	BYTE AddResistance[MAX_RESISTANCE_TYPE];
	VIEWPORT_STRUCT* VpPlayer;
	VIEWPORT_STRUCT* VpPlayer2;
	VIEWPORT_STRUCT* VpPlayerItem;
	int VPCount;
	int VPCount2;
	int VPCountItem;
	HIT_DAMAGE_STRUCT* HitDamage;
	short HitDamageCount;
	INTERFACE_STATE Interface;
	DWORD InterfaceTime;
	char Transaction;
	CItem* Inventory;
	CItem* Inventory1;
	CItem* Inventory2;
	BYTE* InventoryMap;
	BYTE* InventoryMap1;
	BYTE* InventoryMap2;
	CItem* Trade;
	BYTE* TradeMap;
	int TradeMoney;
	bool TradeOk;
	CItem* Warehouse;
	BYTE* WarehouseMap;
	char WarehouseCount;
	short WarehousePW;
	BYTE WarehouseLock;
	int WarehouseMoney;
	int WarehouseSave;
	CItem* ChaosBox;
	BYTE* ChaosBoxMap;
	int ChaosMoney;
	int ChaosSuccessRate;
	int ChaosLock;
	#if(GAMESERVER_UPDATE>=802)
	int LoadEventInventory;
	CItem* EventInventory;
	CItem* EventInventory1;
	CItem* EventInventory2;
	BYTE* EventInventoryMap;
	BYTE* EventInventoryMap1;
	BYTE* EventInventoryMap2;
	#endif
	#if(GAMESERVER_UPDATE>=803)
	int MuunItemStatus[2];
	int LoadMuunInventory;
	CItem* MuunInventory;
	BYTE* MuunInventoryMap;
	#endif
	DWORD Option;
	int ChaosCastleBlowTime;
	int DuelUserReserved;
	int DuelUserRequested;
	int DuelUser;
	BYTE DuelScore;
	DWORD DuelTickCount;
	bool PShopOpen;
	bool PShopTransaction;
	bool PShopItemChange;
	bool PShopRedrawAbs;
	char PShopText[36];
	bool PShopWantDeal;
	int PShopDealerIndex;
	char PShopDealerName[10];
	int PShopCustom;
	int PShopCustomType;
	int PShopCustomOffline;
	int PShopCustomOfflineTime;
	int PShopCustomTime;
	CRITICAL_SECTION PShopTrade;
	int VpPShopPlayer[MAX_VIEWPORT];
	int VpPShopPlayerCount;
	bool IsInBattleGround;
	bool HaveWeaponInHand;
	bool UseEventServer;
	int LoadWarehouse;
	int LoadGuildWarehouse;
	BYTE Quest[50];
	bool SendQuestInfo;
	int CheckLifeTime;
	BYTE LastTeleportTime;
	BYTE SkillNovaState;
	BYTE SkillNovaCount;
	DWORD SkillNovaTime;
	BYTE ReqWarehouseOpen;
	bool IsFullSetItem;
	WORD SkillSummonPartyTime;
	BYTE SkillSummonPartyMap;
	BYTE SkillSummonPartyX;
	BYTE SkillSummonPartyY;
	bool IsChaosMixCompleted;
	bool SkillLongSpearChange;
	DWORD CharSaveTime;
	int LoadQuestKillCount;
	int QuestKillCountIndex;
	struct QUEST_KILL_COUNT* QuestKillCount;
	int LoadMasterLevel;
	int MasterLevel;
	int MasterPoint;
	#pragma pack(1)
	QWORD MasterExperience;
	QWORD MasterNextExperience;
	#pragma pack()
	CSkill* MasterSkill;
	CEffect* Effect;
	DWORD* SkillDelay;
	DWORD* HackPacketDelay;
	DWORD* HackPacketCount;
	int ExtInventory;
	int PCPoint;
	int ExtWarehouse;
	int WarehouseNumber;
	int AccountLevel;
	char AccountExpireDate[20];
	char AutoPartyPassword[11];
	int AutoAddPointCount;
	int AutoAddPointStats[5];
	int AutoResetEnable;
	int AutoResetStats[5];
	int AttackCustom;
	int AttackCustomTime;
	int AttackCustomSkill;
	int AttackCustomDelay;
	int AttackCustomZoneX;
	int AttackCustomZoneY;
	int AttackCustomZoneMap;
	int AttackCustomOffline;
	int AttackCustomOfflineTime;
	//int AttackCustomOfflineMoneyDelay;
	int AttackCustomAutoBuff;
	int AttackCustomAutoBuffDelay;
	int MiniMapState;
	int MiniMapValue;
	int MiningStage;
	int MiningIndex;
	int UseGuildMatching;
	int UseGuildMatchingJoin;
	int UsePartyMatching;
	int UsePartyMatchingJoin;
	int CashShopTransaction[4];
	int CommandManagerTransaction[1];
	int LuckyCoinTransaction[2];
	int PcPointTransaction[2];
	DWORD AutoAttackTime;
	DWORD TradeOkTime;
	DWORD PotionTime;
	DWORD ComboTime;
	DWORD AutoChageTime; //오토환전
	DWORD HelperDelayTime;
	DWORD HelperTotalTime;
	DWORD PcPointPointTime;
	DWORD HPAutoRecuperationTime;
	DWORD MPAutoRecuperationTime;
	DWORD BPAutoRecuperationTime;
	DWORD SDAutoRecuperationTime;
	DWORD CashShopGoblinPointTime;
	int Reset;
	int MasterReset;
	int ChangeSkin;
	int LoadQuestWorld;
	struct QUEST_WORLD_LIST* QuestWorldList;
	int QuestWorldMonsterClass;
	int LoadGens;
	int GensFamily;
	int GensRank;
	int GensSymbol;
	int GensContribution;
	int GensNextContribution;
	struct GENS_SYSTEM_VICTIM_LIST* GensVictimList;
	#if(GAMESERVER_UPDATE>=701)
	struct PENTAGRAM_JEWEL_INFO* PentagramJewelInfo_Inventory;
	struct PENTAGRAM_JEWEL_INFO* PentagramJewelInfo_Warehouse;
	#endif
	#if(GAMESERVER_UPDATE>=802)
	class CMuRummyInfo* MuRummyInfo;
	#endif
	EFFECT_OPTION EffectOption;
	#if(GAMESERVER_UPDATE>=701)
	PENTAGRAM_OPTION PentagramOption;
	PENTAGRAM_JEWEL_OPTION PentagramJewelOption;
	#endif
	int ArmorSetBonus;
	int SkillDamageBonus;
	int DoubleDamageRate;
	int TripleDamageRate;
	int IgnoreDefenseRate;
	int IgnoreShieldGaugeRate;
	int CriticalDamageRate;
	int CriticalDamage;
	int ExcellentDamageRate;
	int ExcellentDamage;
	int ResistDoubleDamageRate;
	int ResistIgnoreDefenseRate;
	int ResistIgnoreShieldGaugeRate;
	int ResistCriticalDamageRate;
	int ResistExcellentDamageRate;
	int ResistStunRate;
	int ExperienceRate;
	int MasterExperienceRate;
	int ItemDropRate;
	int MoneyAmountDropRate;
	int HPRecovery;
	int MPRecovery;
	int BPRecovery;
	int SDRecovery;
	int HPRecoveryRate;
	int MPRecoveryRate;
	int BPRecoveryRate;
	int SDRecoveryRate;
	int SDRecoveryType;
	int HPRecoveryCount;
	int MPRecoveryCount;
	int BPRecoveryCount;
	int SDRecoveryCount;
	int MPConsumptionRate;
	int BPConsumptionRate;
	int ShieldGaugeRate;
	int DecreaseShieldGaugeRate;
	int DamagePvP;
	int DefensePvP;
	int AttackSuccessRatePvP;
	int DefenseSuccessRatePvP;
	int ShieldDamageReduction;
	int ShieldDamageReductionTime;
	int DamageReduction[MAX_DAMAGE_REDUCTION];
	int DamageReflect;
	int HuntHP;
	int HuntMP;
	int HuntBP;
	int HuntSD;
	int WeaponDurabilityRate;
	int ArmorDurabilityRate;
	int WingDurabilityRate;
	int GuardianDurabilityRate;
	int PendantDurabilityRate;
	int RingDurabilityRate;
	int PetDurabilityRate;
	int FullDamageReflectRate;
	int DefensiveFullHPRestoreRate;
	int DefensiveFullMPRestoreRate;
	int DefensiveFullSDRestoreRate;
	int DefensiveFullBPRestoreRate;
	int OffensiveFullHPRestoreRate;
	int OffensiveFullMPRestoreRate;
	int OffensiveFullSDRestoreRate;
	int OffensiveFullBPRestoreRate;
	int ResurrectionTalismanActive;
	int ResurrectionTalismanMap;
	int ResurrectionTalismanX;
	int ResurrectionTalismanY;
	int MobilityTalismanActive;
	int MobilityTalismanMap;
	int MobilityTalismanX;
	int MobilityTalismanY;
	bool MapServerMoveQuit;
	bool MapServerMoveRequest;
	DWORD MapServerMoveQuitTickCount;
	short NextServerCode;
	short LastServerCode;
	short DestMap;
	BYTE DestX;
	BYTE DestY;
	DWORD RenameTime;
	int RenameActive;
	int RunAndCatch;
	int CustomQuest;
	int CustomQuestMonsterIndex;
	int CustomQuestMonsterQtd;
	int CustomNpcQuest;
	int CustomNpcQuestMonsterIndex;
	int CustomNpcQuestMonsterQtd;
	int CustomNpcQuestFinished;
	int RussianRoulette;

	int Kills;
	int Deads;
	int KillStreak; // 🔥 연승 카운트 변수 추가

    



	int BuyStat;  //스텟구매
	int Login;  //로그인
	int LevelStat;  //로그인
	int BuystatMs;
	bool AutoChange; //오토환전
	bool AutoExp;
	BYTE TheGift;
	int PAddDamage;
	int PAddDefence;
	int PAddLife;
	int PAddExellent;
	int PAddCritical;
	int RPSMode;
	int RuddCount;
	bool AutoGuildAttack; //길드어택
	bool AutoCtrl; //길드어택
	int BCCount; //캐슬
	int DSCount;
	int StatCount;
	int MsStatCount;

	BANKEX_USER_DATA BankEx; //뱅크

	int Coin1;
	int Coin2;
	int Coin3;

	int BuyVip;

	BYTE ChaosMassMixCurrItem;
	BYTE ChaosMassMixSuccessCount;

	int PickupEnable;
	int Pickup[20];
	int PickupExc;
	int PickupSocket;
	int PickupSetItem;

	bool RenameEnable;

	int CommandDelay[100];

	int CommandNotice[100];

	int DisablePvp;

	int Lock;

	int PvP;

	int KillAll;

	short MapMoveDisable;

	//DWORD ItemshopDelay;

	DWORD ShopDelay;

	DWORD LuckySpinTime; //행운룰렛

	DWORD TeleportSkillTime;


	#if(GAMESERVER_TYPE==1)
	union
	{
		struct
		{
			BYTE CsNpcExistVal1;
			BYTE CsNpcExistVal2;
			BYTE CsNpcExistVal3;
			BYTE CsNpcExistVal4;
		};

		int CsNpcExistVal;
	};
	BYTE CsNpcType;
	BYTE CsGateOpen;
	int CsGateLeverLinkIndex;
	BYTE CsNpcDfLevel;
	BYTE CsNpcRgLevel;
	BYTE CsJoinSide;
	bool CsGuildInvolved;
	#endif
	bool IsCastleNPCUpgradeCompleted;
	BYTE CsSiegeWeaponState;
	int CsWeaponIndex;
	BYTE KillCount;
	int AccumulatedDamage;
	#if(GAMESERVER_TYPE==1)
	BYTE LifeStoneCount;
	BYTE CreationState;
	int CreatedActivationTime;
	#endif
	int AccumulatedCrownAccessTime;
	CMonsterSkillElementOption MonsterSkillElementOption;
	int BasicAI;
	int CurrentAI;
	int CurrentAIState;
	int LastAIRunTime;
	int GroupNumber;
	int SubGroupNumber;
	int GroupMemberGuid;
	int RegenType;
	CMonsterAIAgro Agro;
	int LastAutomataRuntime;
	int LastAutomataDelay;
	int CrywolfMVPScore;
	DWORD LastCheckTick;
	DWORD ShopValueSendDelay;
	int EventChipCount;
	//SpeedHack
	DWORD SpeedHackDelay;
	int SpeedHackCount;
	int SpeedHackSkill;
	int SpeedHackDialog;
	#if (ARCHIVEMENT == 1)
	ACHIEVEMENTS_USER_DATA ach;
	#endif

//MC bot
	#if(ALLBOTSSTRUC == 1)

	BYTE IsBot;
	int BotNumOwner;
	int BotPower;
	int BotDefense;
	int BotLife;
	int BotMaxLife;

	int BotLvlUpDefense;
	int BotLvlUpPower;
	int BotLvlUpLife;
	int BotLvlUpMana;
	int BotLvlUpExp;
	short BotLvlUpMaxLevel;
	BYTE BotVersion;

	BYTE BotFollowMe;
	BYTE BotSkillAttack;

	BYTE HaveBot;
	WORD aFloodBotPetCmd;
	BYTE AccountExtraInfoModified;
	BYTE PlayerExtraInfoModified;
	
	BYTE RaceCheck;
	int RaceTime;

	DWORD	m_ShopPointExTime;
	DWORD	m_ShopPointExTimeBackup;
#if(BOT_BUFFER == 1)
	//Buff Times
	int ManaShieldTime;					// EFFECT_MANA_SHIELD
	int DamageReflectTime;				// EFFECT_DAMAGE_REFLECT
	int MagicCircleTime;				// EFFECT_MAGIC_CIRCLE
	int FitnessTime;					// EFFECT_FITNESS
	int GreaterLifeTime;				// EFFECT_GREATER_LIFE
	int GreaterDefenseTime;				// EFFECT_GREATER_DEFENSE
	int GreaterDamageTime;				// EFFECT_GREATER_DAMAGE
	int GreaterCriticalDamageTime;		// EFFECT_GREATER_CRITICAL_DAMAGE
	int GreaterIgnoreDefenseRateTime;	// EFFECT_GREATER_IGNORE_DEFENSE_RATE

#endif
#endif

	bool	m_OfflineSocket;
	int		m_OfflineMode;
	int		MuOffHelperTime;
	/*+172*/	DWORD	HuntingRange;
/*+176*/	BYTE	RecoveryPotionOn;
/*+177*/	BYTE	RecoveryPotionPercent;
/*+178*/	BYTE	RecoveryHealOn;			//-> CLASS_ELF
/*+179*/	BYTE	RecoveryHealPercent;	//-> CLASS_ELF
/*+180*/	BYTE	RecoveryDrainOn;		//-> CLASS_SUMMONER
/*+181*/	BYTE	RecoveryDrainPercent;	//-> CLASS_SUMMONER
/*+182*/	BYTE	DistanceLongOn;
/*+183*/	BYTE	DistanceReturnOn;
/*+184*/	DWORD	DistanceMin;
/*+188*/	DWORD	SkillBasicID;
/*+240*/	BYTE	ComboOn;				//-> CLASS_KNIGHT
/*+241*/	BYTE	PartyModeOn;
/*+242*/	BYTE	PartyModeHealOn;		//-> CLASS_ELF
/*+243*/	BYTE	PartyModeHealPercent;	//-> CLASS_ELF
/*+244*/	BYTE	PartyModeBuffOn;
/*+260*/	BYTE	BuffOn;
/*+264*/	DWORD	BuffSkill[3];
/*+288*/	DWORD	ObtainRange;
/*+292*/	BYTE	ObtainRepairOn;
/*+293*/	BYTE	ObtainPickNear;
/*+294*/	BYTE	ObtainPickSelected;
/*+295*/	BYTE	ObtainPickJewels;
/*+296*/	BYTE	ObtainPickAncient;
/*+297*/	BYTE	ObtainPickMoney;
/*+298*/	BYTE	ObtainPickExcellent;
/*+299*/	BYTE	ObtainPickExtra;
			int		ObtainPickExtraCount;
/*+300*/	char	ObtainPickItemList[12][16];

int orderskill;
	short m_OfflineCoordX;
	short m_OfflineCoordY;
	DWORD m_OfflineTimeResetMove;

	short DBNumber;
	BYTE ExInventory;	//botshop

	int PCPoints;
	int Resets;

	BYTE Vip;
	int VipMoney;
	WORD VipDays;
	DWORD MarryTimeMsj; //marry system
	//=== Fake Online
	bool	IsFakeOnline;
	DWORD m_OfflineMoveDelay;
	bool IsFakeRegen;
	int	 IsFakePVPMode;
	int	 IsFakePartyMode;
	int	 IsFakeMoveRange;
	DWORD	 IsFakeTimeLag;
	DWORD	 IsFakeSendParty;

	int showhpbar;
	int timeshow;
	int sendhpbartarget;

	int JewelBlessCount;
	int JewelSoulCount;
	int JewelLifeCount;
	int JewelCreationCount;
	int JewelGuardianCount;
	int JewelGemStoneCount;
	int JewelHarmonyCount;
	int JewelChaosCount;
	int JewelLowStoneCount;
	int JewelHighStoneCount;

	int removebuff;

};

enum ClassNumber {
  CLASS_WIZARD = 0x0,
  CLASS_KNIGHT = 0x1,
  CLASS_ELF = 0x2,
  CLASS_MAGICGLADIATOR = 0x3,
  CLASS_DARKLORD = 0x4,
  CLASS_SUMMONER = 0x5,
  CLASS_RAGEFIGHTER = 0x6,
};

struct botReward_Data_Struct
{
	WORD num;
	BYTE Level;
	BYTE Opt;
	BYTE Luck;
	BYTE Skill;
	BYTE Dur;
	BYTE Exc;
	BYTE Anc;

	BYTE Sock1;
	BYTE Sock2;
	BYTE Sock3;
	BYTE Sock4;
	BYTE Sock5;

	BYTE Days;
	BYTE JOH;
	BYTE IsForeverFFFE;
	
	int Zen;
	int PCPoints;
};



enum PROTO_CLASS_CODES {
	PR_DARK_WIZARD		= 0x0,
	PR_SOUL_MASTER		= 0x10,
	PR_GRAND_MASTER		= 0x18,

	PR_DARK_KNIGHT		= 0x20,
	PR_BLADE_KNIGHT		= 0x30,
	PR_BLADE_MASTER		= 0x38,

	PR_FAIRY_ELF		= 0x40,
	PR_MUSE_ELF			= 0x50,
	PR_HIGH_ELF			= 0x58,

	PR_MAGIC_GLADIATOR	= 0x60,
	PR_DUEL_MASTER		= 0x78,

	PR_DARK_LORD		= 0x80,
	PR_LORD_EMPEROR		= 0x98,

	PR_SUMMONER			= 0x0A0,
	PR_BLOODY_SUMMONER	= 0x0B0,
	PR_DIMENSION_MASTER = 0x0B8,

	PR_RAGEFIGHER		= 0xC0,
	PR_RAGEFIGHER_EVO	= 0xD8,
};

enum DB_CLASS_CODES {
	DB_DARK_WIZARD		= 0,
	DB_SOUL_MASTER		= 1,
	DB_GRAND_MASTER		= 2,

	DB_DARK_KNIGHT		= 16,
	DB_BLADE_KNIGHT		= 17,
	DB_BLADE_MASTER		= 18,

	DB_FAIRY_ELF		= 32,
	DB_MUSE_ELF			= 33,
	DB_HIGH_ELF			= 34,

	DB_MAGIC_GLADIATOR	= 48,
	DB_DUEL_MASTER		= 49,

	DB_DARK_LORD		= 64,
	DB_LORD_EMPEROR		= 65,

	DB_SUMMONER			= 80,
	DB_BLOODY_SUMMONER	= 81,
	DB_DIMENSION_MASTER = 82,

	DB_RAGEFIGHER		= 96,
	DB_RAGEFIGHER_EVO	= 97,
};
//MC bot

struct OBJECTSTRUCT_HEADER
{
	OBJECTSTRUCT_HEADER() // OK
	{
		this->CommonStruct = new OBJECTSTRUCT;

		for(int n=0;n < MAX_OBJECT;n++){this->ObjectStruct[n] = this->CommonStruct;}
	}

	OBJECTSTRUCT& operator[](int index) // OK
	{
		return (*this->ObjectStruct[index]);
	}

	OBJECTSTRUCT* CommonStruct;
	OBJECTSTRUCT* ObjectStruct[MAX_OBJECT];
};

typedef OBJECTSTRUCT* LPOBJ;

extern OBJECTSTRUCT_HEADER gObj;

extern MESSAGE_STATE_MACHINE_HEADER gSMMsg;

extern MESSAGE_STATE_ATTACK_MACHINE_HEADER gSMAttackProcMsg;

extern DWORD gCheckSum[MAX_CHECKSUM_KEY];

//extern DWORD gLevelExperience[MAX_CHARACTER_LEVEL+1];
//경험치
extern QWORD gLevelExperience[MAX_CHARACTER_LEVEL+1];

//**************************************************************************//
// OBJECT MAIN FUNCTIONS ***************************************************//
//**************************************************************************//
void gObjEventRunProc();
void gObjViewportProc();
void gObjFirstProc();
void gObjCloseProc();
void gObjCountProc();
void gObjAccountLevelProc();
void gObjMathAuthenticatorProc();
void gObjPickProc();
void gObjSetPKLevel(LPOBJ lpObj, int PKLevel);
//void gObjResetDateProc();//리셋
//**************************************************************************//
// OBJECT BASE FUNCTIONS ***************************************************//
//**************************************************************************//
void gObjInit();
void gObjAllLogOut();
void gObjAllDisconnect();
void gObjSetExperienceTable();
void gObjCharZeroSet(int aIndex);
void gObjClearPlayerOption(LPOBJ lpObj);
void gObjClearSpecialOption(LPOBJ lpObj);
void gObjCalcExperience(LPOBJ lpObj);
bool gObjGetRandomFreeLocation(int map,int* ox,int* oy,int tx,int ty,int count);
bool gObjAllocData(int aIndex);
void gObjFreeData(int aIndex);
short gObjAddSearch(SOCKET socket,char* IpAddress);
short gObjAdd(SOCKET socket,char* IpAddress,int aIndex);
short gObjDel(int aIndex);
LPOBJ gObjFind(char* name);
int gObjCalcDistance(LPOBJ lpObj,LPOBJ lpTarget);
//**************************************************************************//
// OBJECT CHECK FUNCTIONS **************************************************//
//**************************************************************************//
bool gObjIsConnected(int aIndex);
bool gObjIsConnectedGP(int aIndex);
bool gObjIsConnectedGS(int aIndex);
bool gObjIsNameValid(int aIndex,char* name);
bool gObjIsAccountValid(int aIndex,char* account);
bool gObjIsChangeSkin(int aIndex);
bool gObjCheckMaxMoney(int aIndex,DWORD AddMoney);
bool gObjCheckPersonalCode(int aIndex,char* PersonalCode);
bool gObjCheckResistance(LPOBJ lpObj,int type);
bool gObjCheckTeleportArea(int aIndex,int x,int y);
bool gObjCheckMapTile(LPOBJ lpObj,int type);
//**************************************************************************//
// ITEM TRANSACTION FUNCTIONS **********************************************//
//**************************************************************************//
bool gObjFixInventoryPointer(int aIndex);
void gObjSetInventory1Pointer(LPOBJ lpObj);
void gObjSetInventory2Pointer(LPOBJ lpObj);
bool gObjFixEventInventoryPointer(int aIndex);
void gObjSetEventInventory1Pointer(LPOBJ lpObj);
void gObjSetEventInventory2Pointer(LPOBJ lpObj);
bool gObjInventoryTransaction(int aIndex);
bool gObjInventoryCommit(int aIndex);
bool gObjInventoryRollback(int aIndex);
//**************************************************************************//
// VIEWPORT FUNCTIONS ******************************************************//
//**************************************************************************//
void gObjSetViewport(int aIndex,int state);
void gObjClearViewport(LPOBJ lpObj);
void gObjViewportListProtocolDestroy(LPOBJ lpObj);
void gObjViewportListProtocolCreate(LPOBJ lpObj);
void gObjViewportListProtocol(int aIndex);
void gObjViewportListDestroy(int aIndex);
void gObjViewportListCreate(int aIndex);
//**************************************************************************//
// USER FUNCTIONS **********************************************************//
//**************************************************************************//
void gObjSetKillCount(int aIndex,int type);
void gObjTeleportMagicUse(int aIndex,int x,int y);
void gObjInterfaceCheckTime(LPOBJ lpObj);
void gObjSkillNovaCheckTime(LPOBJ lpObj);
void gObjPKDownCheckTime(LPOBJ lpObj,int TargetLevel);
void gObjUserDie(LPOBJ lpObj,LPOBJ lpTarget);
void gObjPlayerKiller(LPOBJ lpObj,LPOBJ lpTarget);
BOOL gObjMoveGate(int aIndex,int gate);
void gObjTeleport(int aIndex,int map,int x,int y);
void gObjSummonAlly(LPOBJ lpObj,int map,int x,int y);
void gObjSkillUseProc(LPOBJ lpObj);
void gObjUserKill(int aIndex);
bool gObjInventorySearchSerialNumber(LPOBJ lpObj,DWORD serial);
bool gObjWarehouseSearchSerialNumber(LPOBJ lpObj,DWORD serial);
void gObjAddMsgSend(LPOBJ lpObj,int MsgCode,int SendUser,int SubCode);
void gObjAddMsgSendDelay(LPOBJ lpObj,int MsgCode,int SendUser,int MsgTimeDelay,int SubCode);
void gObjAddAttackProcMsgSendDelay(LPOBJ lpObj,int MsgCode,int SendUser,int MsgTimeDelay,int SubCode,int SubCode2);

#if USE_FAKE_ONLINE == TRUE
LPOBJ gObjFindByAcc(char* account);
#endif

//**************************************************************************//
// RAW FUNCTIONS ***********************************************************//
//**************************************************************************//

void gObjSecondProc();
void gObjDelayLifeCheck(int aIndex);
BOOL gObjBackSpring(LPOBJ lpObj,LPOBJ lpTarget);
BOOL gObjBackSpring2(LPOBJ lpObj,LPOBJ lpTarget,int count);
bool gObjIsSelfDefense(LPOBJ lpObj, int aTargetIndex);
void gObjCheckSelfDefense(LPOBJ lpObj, int aTargetIndex);
void gObjTimeCheckSelfDefense(LPOBJ lpObj);
BOOL gObjTargetGuildWarCheck(LPOBJ lpObj, LPOBJ lpTargetObj);
void gObjGuildWarEndSend(LPOBJ lpObj, BYTE Result1, BYTE Result2);
void gObjGuildWarEndSend(GUILD_INFO_STRUCT * lpGuild1, GUILD_INFO_STRUCT * lpGuild2, BYTE Result1, BYTE Result2);
void gObjGuildWarEnd(GUILD_INFO_STRUCT * lpGuild, GUILD_INFO_STRUCT * lpTargetGuild);
BOOL gObjGuildWarProc(GUILD_INFO_STRUCT * lpGuild1, GUILD_INFO_STRUCT * lpGuild2, int score);
BOOL gObjGuildWarCheck(LPOBJ lpObj, LPOBJ lpTargetObj);
BOOL gObjGuildWarMasterClose(LPOBJ lpObj);
int gObjGuildWarItemGive(GUILD_INFO_STRUCT * lpWinGuild, GUILD_INFO_STRUCT * lpLoseGuild);
void gObjSetPosition(int aIndex, int x, int y);
void gObjAuthorityCodeSet(LPOBJ lpObj);
int gObjGetGuildUnionNumber(LPOBJ lpObj);
void gObjGetGuildUnionName(LPOBJ lpObj, char* szUnionName, int iUnionNameLen);
BOOL gObjCheckRival(LPOBJ lpObj, LPOBJ lpTargetObj);
int gObjGetRelationShip(LPOBJ lpObj, LPOBJ lpTargetObj);
void gObjNotifyUpdateUnionV1(LPOBJ lpObj);
void gObjNotifyUpdateUnionV2(LPOBJ lpObj);
void gObjUnionUpdateProc(int iIndex);
bool gObjRebuildMasterSkillTree(LPOBJ lpObj);
void gObjUseDrink(LPOBJ lpObj,int level);
void gObjCustomLogPlusChaosMix(LPOBJ lpObj,int type,int index);
bool gObjCheckAutoParty(LPOBJ lpObj,LPOBJ lpTarget);
bool isRecconect(char* address, char* account);

extern int gObjCount;
extern int gObjMonCount;
extern int gObjBotCount;//MC
extern int gObjCallMonCount;
extern int gObjTotalUser;
extern int gObjTotalMonster;
extern int gObjTotalBot;
extern int gCloseMsg;
extern int gCloseMsgTime;
extern int gGameServerLogOut;
extern int gGameServerDisconnect;
extern int gObjOffStore;
extern int gObjOffAttack;








///////////////////////////////////////////////// 

/////////////////////////SERVER USER.CPP
#include "stdafx.h"
#include "User.h"
#include "380ItemOption.h"
#include "Attack.h"
#include "Log.h"
#include "BattleSoccerManager.h"
#include "BloodCastle.h"
#include "BonusManager.h"
#include "CannonTower.h"
#include "CashShop.h"
#include "CastleDeep.h"
#include "CastleSiege.h"
#include "CastleSiegeCrown.h"
#include "CastleSiegeCrownSwitch.h"
#include "CastleSiegeSync.h"
#include "CastleSiegeWeapon.h"
#include "ChaosBox.h"
#include "ChaosCastle.h"
#include "CommandManager.h"
#include "Crywolf.h"
#include "CrywolfAltar.h"
#include "CrywolfSync.h"
#include "CustomArena.h"
#include "CustomAttack.h"
#include "CustomEventDrop.h"
#include "CustomOnlineLottery.h"
#include "CustomQuiz.h"
#include "CustomPick.h"
#include "CustomRankUser.h"
#include "CustomStore.h"
#include "DarkSpirit.h"
#include "DefaultClassInfo.h"
#include "DevilSquare.h"
#include "DoubleGoer.h"
#include "DSProtocol.h"
#include "Duel.h"
#include "EffectManager.h"
#include "ESProtocol.h"
#include "EventInventory.h"
#include "EventHideAndSeek.h"
#include "EventKillAll.h"
#include "EventPvp.h"
#include "EventQuickly.h"
#include "EventRunAndCatch.h"
#include "EventRussianRoulette.h"
#include "EventStart.h"
#include "EventTvT.h"
#include "ItemManager.h"
#include "GameMain.h"
#include "GameMaster.h"
#include "Gate.h"
#include "GensSystem.h"
#include "GuardianStatue.h"
#include "Guild.h"
#include "GuildMatching.h"
#include "HackPacketCheck.h"
#include "Helper.h"
#include "IllusionTemple.h"
#include "ImperialGuardian.h"
#include "InvasionManager.h"
#include "InventoryEquipment.h"
#include "IpManager.h"
#include "JewelOfHarmonyOption.h"
#include "JSProtocol.h"
#include "Kalima.h"
#include "Kanturu.h"
#include "LifeStone.h"
#include "Map.h"
#include "MapManager.h"
#include "MapServerManager.h"
#include "MasterSkillTree.h"
#include "MemoryAllocator.h"
#include "Message.h"
#include "MiniMap.h"
#include "Monster.h"
#include "MonsterSkillManager.h"
#include "MossMerchant.h"
#include "Move.h"
#include "MoveSummon.h"
#include "MuRummy.h"
#include "MuunSystem.h"
#include "Notice.h"
#include "ObjectManager.h"
#include "Party.h"
#include "PartyMatching.h"
#include "PcPoint.h"
#include "PentagramSystem.h"
#include "PersonalShop.h"
#include "Quest.h"
#include "QuestWorld.h"
#include "ReiDoMU.h"
#include "Raklion.h"
#include "RaklionBattleUserMng.h"
#include "RaklionUtil.h"
#include "Reconnect.h"
#include "SerialCheck.h"
#include "ServerInfo.h"
#include "SetItemOption.h"
#include "SkillManager.h"
#include "SocketItemOption.h"
#include "Trade.h"
#include "Union.h"
#include "Util.h"
#include "Viewport.h"
#include "Warehouse.h"
#include "LuckyWheel.h"
#include "JewelsBank.h"
#include "FakeOnline.h"
#include "OfflineMode.h"
#include "RageSystem.h"

int gObjCount;
int gObjMonCount;
int gObjBotCount;//MC bot
int gObjCallMonCount;
int gObjTotalUser;
int gObjTotalMonster;
int gObjTotalBot;//mc
int gCloseMsg;
int gCloseMsgTime;
int gGameServerLogOut;
int gGameServerDisconnect;
int gObjOffStore;
int gObjOffAttack;


OBJECTSTRUCT_HEADER gObj;

MESSAGE_STATE_MACHINE_HEADER gSMMsg;

MESSAGE_STATE_ATTACK_MACHINE_HEADER gSMAttackProcMsg;

DWORD gCheckSum[MAX_CHECKSUM_KEY];

//경험치
//DWORD gLevelExperience[MAX_CHARACTER_LEVEL+1];
QWORD gLevelExperience[MAX_CHARACTER_LEVEL+1];

//**************************************************************************//
// OBJECT MAIN FUNCTIONS ***************************************************//
//**************************************************************************//
void gObjEventRunProc() // OK
{
	gBloodCastle.MainProc();

	gReiDoMU.MainProc();

	gEventQuickly.MainProc();

	gEventRussianRoulette.MainProc();

	gEventStart.MainProc();

	gEventHideAndSeek.MainProc();

	gEventRunAndCatch.MainProc();

	gEventPvP.MainProc();

	gEventKillAll.MainProc();
	
	gBonusManager.MainProc();

	gCastleDeep.MainProc();

	#if(GAMESERVER_TYPE==1)

	gCastleSiege.MainProc();

	#endif

	gCastleSiegeWeapon.MainProc();

	gChaosCastle.MainProc();

	#if(GAMESERVER_TYPE==1)

	gCrywolf.MainProc();

	#endif

	gCustomArena.MainProc();

	gTvTEvent.MainProc();

	gCustomEventDrop.MainProc();

	gCustomOnlineLottery.MainProc();

	gCustomQuiz.MainProc();

	gDevilSquare.MainProc();

	#if(GAMESERVER_UPDATE>=501)

	gDoubleGoer.MainProc();

	#endif

	#if(GAMESERVER_UPDATE>=402)

	gDuel.MainProc();

	#endif

	gIllusionTemple.MainProc();

	#if(GAMESERVER_UPDATE>=501)

	gImperialGuardian.MainProc();

	#endif

	gInvasionManager.MainProc();

	gKanturu.MainProc();

	#if(GAMESERVER_UPDATE>=402)

	gMossMerchant.MainProc();

	#endif

	gRaklion.MainProc();
}

void gObjViewportProc() // OK
{
	for(int n=0;n < MAX_OBJECT;n++)
	{
		gObjectManager.ObjectSetStateCreate(n);
	}

	for(int n=0;n < MAX_OBJECT;n++)
	{
		gObjViewportListDestroy(n);
	}

	for(int n=0;n < MAX_OBJECT;n++)
	{
		gObjViewportListCreate(n);
	}

	for(int n=0;n < MAX_OBJECT;n++)
	{
		gObjViewportListProtocol(n);
	}

	for(int n=OBJECT_START_USER;n < MAX_OBJECT;n++)
	{
		gPersonalShop.GCPShopViewportSend(n);
	}

	for(int n=OBJECT_START_USER;n < MAX_OBJECT;n++)
	{
		gObj[n].PShopItemChange = 0;
	}

	for(int n=OBJECT_START_USER;n < MAX_OBJECT;n++)
	{
		gObjUnionUpdateProc(n);
	}

	gObjectManager.ObjectSetStateProc();
}

void gObjFirstProc() // OK
{
	for(int n=0;n < MAX_MAP;n++)
	{
		gMap[n].WeatherVariationProcess();
	}

	gObjSecondProc();

	#if(GAMESERVER_UPDATE>=501)

	gCashShop.MainProc();

	#endif

	gCommandManager.MainProc();

	gDuel.CheckDuelUser();

	gEffectManager.MainProc();

	#if(GAMESERVER_UPDATE>=603)

	gHelper.MainProc();

	#endif

	#if(GAMESERVER_UPDATE>=501)

	gInventoryEquipment.MainProc();

	#endif

	#if(GAMESERVER_UPDATE>=803)

	gMuunSystem.MainProc();

	#endif

	gNotice.MainProc();

	#if(GAMESERVER_UPDATE<=402)

	gPcPoint.MainProc();

	#endif

	gReconnect.MainProc();

	gCastleSiegeSync.AdjustTributeMoney();

	#if(GAMESERVER_TYPE==1)

	gCrywolf.CrywolfSecondAct();

	#endif

	#if(GAMESERVER_TYPE==1)

	if(gCastleSiege.GetDataLoadState() == CASTLESIEGE_DATALOAD_2)
	{
		gCastleSiege.DataRequest();
	}

	gCastleSiege.SendCastleStateSync();

	#endif
}

void gObjCloseProc() // OK
{
	if(gCloseMsg != 0)
	{
		if((--gCloseMsgTime) <= 1)
		{
			if(gCloseMsgTime == 1)
			{
				gNotice.GCNoticeSendToAll(0,0,0,0,0,0,gMessage.GetMessage(480));
				LogAdd(LOG_RED,gMessage.GetMessage(480));
			}
		}
		else
		{
			if((gCloseMsgTime%10) == 0)
			{
				gNotice.GCNoticeSendToAll(0,0,0,0,0,0,gMessage.GetMessage(481),gCloseMsgTime);
				LogAdd(LOG_RED,gMessage.GetMessage(481),gCloseMsgTime);
			}
		}

		if(gCloseMsgTime < 0)
		{
			gCloseMsg = 0;
			gCloseMsgTime = 0;
			gObjAllLogOut();
		}
	}
}

void gObjCountProc() // OK
{
	int TotalUser = 0;
	int TotalBot = 0;
	int TotalMonster = 0;
	int TotalOffStore = 0;
	int TotalOffAttack = 0;

	for(int n=0;n < MAX_OBJECT;n++)
	{
		if(gObj[n].Connected != OBJECT_OFFLINE)
		{
			if(gObj[n].Type == OBJECT_BOTS)
			{
				TotalBot++;
			}
			if(gObj[n].Type == OBJECT_USER)
			{
				TotalUser++;
				if(gObj[n].PShopCustomOffline == 1)
				{
					TotalOffStore++;
				}
				if(gObj[n].AttackCustomOffline == 1)
				{
					TotalOffAttack++;
				}
			}
			else
			{
				TotalMonster++;
			}
		}
	}
	
	gObjTotalBot = TotalBot;//mc
	gObjTotalUser = TotalUser;
	gObjOffStore = TotalOffStore;
	gObjOffAttack = TotalOffAttack;

	gObjTotalMonster = TotalMonster;
}


void gObjAccountLevelProc() // OK
{
	LPOBJ lpObj;

	for(int n=OBJECT_START_USER;n < MAX_OBJECT;n++)
	{
		if(gObjIsConnectedGP(n) != 0)
		{
			GJAccountLevelSend(n);
		}

		lpObj = &gObj[n];

		if(lpObj->Connected >= OBJECT_LOGGED && lpObj->Type == OBJECT_USER && lpObj->CloseCount <= 0)
		{
			if(gServerInfo.m_ServerMinLevel != 0 && lpObj->Level < gServerInfo.m_ServerMinLevel)
			{
				lpObj->CloseCount = 6;
				lpObj->CloseType = 3;
				return;
			}

			if(gServerInfo.m_ServerMinReset != 0 && lpObj->Reset < gServerInfo.m_ServerMinReset)
			{
				lpObj->CloseCount = 6;
				lpObj->CloseType = 3;
				return;
			}

			if(gServerInfo.m_ServerMinMasterReset != 0 && lpObj->MasterReset < gServerInfo.m_ServerMinMasterReset)
			{
				lpObj->CloseCount = 6;
				lpObj->CloseType = 3;
				return;
			}

			if(gServerInfo.m_ServerMaxLevel != 0 && lpObj->Level > gServerInfo.m_ServerMaxLevel)
			{
				lpObj->CloseCount = 6;
				lpObj->CloseType = 4;
				return;
			}

			if(gServerInfo.m_ServerMaxReset != 0 && lpObj->Reset > gServerInfo.m_ServerMaxReset)
			{
				lpObj->CloseCount = 6;
				lpObj->CloseType = 4;
				return;
			}

			if(gServerInfo.m_ServerMaxMasterReset != 0 && lpObj->MasterReset > gServerInfo.m_ServerMaxMasterReset)
			{
				lpObj->CloseCount = 6;
				lpObj->CloseType = 4;
				return;
			}
		}
	}
}

void gObjPickProc() // OK
{
	for(int n=OBJECT_START_USER;n < MAX_OBJECT;n++)
	{
		if(gObjIsConnectedGP(n) != 0)
		{
			gCustomPick.PickProc(&gObj[n]);
		}
	}
}

void gObjMathAuthenticatorProc() // OK
{
	#if(GAMESERVER_UPDATE>=701)

	for(int n=OBJECT_START_USER;n < MAX_OBJECT;n++)
	{
		if(gObjIsConnectedGP(n) != 0)
		{
			GCMathAuthenticatorSend(n);
		}
	}

	#endif
}
//**************************************************************************//
// OBJECT BASE FUNCTIONS ***************************************************//
//**************************************************************************//
void gObjInit() // OK
{
	gObjCount = OBJECT_START_USER;

	gObjMonCount = OBJECT_START_MONSTER;

	gObjCallMonCount = MAX_OBJECT_MONSTER;

	memset(gObj.CommonStruct,0,sizeof(OBJECTSTRUCT));

	gMemoryAllocator.m_TempMemoryAllocatorInfo.Alloc();

	gMemoryAllocator.BindMemoryAllocatorInfo(OBJECT_START_USER,gMemoryAllocator.m_TempMemoryAllocatorInfo);
}

void gObjAllLogOut() // OK
{
	gGameServerLogOut = 1;

	for(int n=OBJECT_START_USER;n < MAX_OBJECT;n++)
	{
		if(gObj[n].Connected != OBJECT_OFFLINE && gObj[n].Type == OBJECT_USER)
		{
			CloseClient(n);

			gCustomAttack.OnAttackAlreadyConnected(&gObj[n]);

			g_OfflineMode.OnHelperpAlreadyConnected(&gObj[n]);

			gCustomStore.OnPShopAlreadyConnected(&gObj[n]);

#if USE_FAKE_ONLINE	== TRUE
			s_FakeOnline.OnAttackAlreadyConnected(&gObj[n]);
#endif
		}
	}
}


void gObjAllDisconnect() // OK
{
	gGameServerDisconnect = 1;

	for(int n=OBJECT_START_USER;n < MAX_OBJECT;n++)
	{
		if(gObj[n].Connected != OBJECT_OFFLINE && gObj[n].Type == OBJECT_USER)
		{
			CloseClient(n);

			gCustomAttack.OnAttackAlreadyConnected(&gObj[n]);

			gCustomStore.OnPShopAlreadyConnected(&gObj[n]);

			g_OfflineMode.OnHelperpAlreadyConnected(&gObj[n]);

#if USE_FAKE_ONLINE	== TRUE
			s_FakeOnline.OnAttackAlreadyConnected(&gObj[n]);
#endif
		}
	}
}
void gObjSetExperienceTable() // OK
{
	gLevelExperience[0] = 0;

	//경험치
	//DWORD over = 1;
	QWORD over = 1;

	for (int n = 1; n <= MAX_CHARACTER_LEVEL + 1; n++)
	{
		gLevelExperience[n] = (((n + 9) * n) * n) * 10;

		if (n > 255)
		{
			gLevelExperience[n] += (((over + 9) * over) * over) * 1000;
			over++;
		}
	}
}

void gObjCharZeroSet(int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	lpObj->CloseCount = -1;
	lpObj->CloseType = -1;
	lpObj->EnableDelCharacter = 1;
	lpObj->TimeCount = 0;
	lpObj->PKTickCount = 0;
	lpObj->CheckSumTableNum = -1;
	lpObj->CheckSumTime = 0;
	lpObj->Live = 0;

	memset(lpObj->Name,0,sizeof(lpObj->Name));

	lpObj->Level = 0;
	lpObj->LevelUpPoint = 0;
	lpObj->FruitAddPoint = 0;
	lpObj->FruitSubPoint = 0;
	lpObj->Money = 0;
	lpObj->Strength = 0;
	lpObj->Dexterity = 0;
	lpObj->Vitality = 0;
	lpObj->Energy = 0;
	lpObj->Leadership = 0;
	lpObj->AddStrength = 0;
	lpObj->AddDexterity = 0;
	lpObj->AddVitality = 0;
	lpObj->AddEnergy = 0;
	lpObj->AddLeadership = 0;
	lpObj->Life = 0;
	lpObj->MaxLife = 0;
	lpObj->AddLife = 0;
	lpObj->ScriptMaxLife = 0;
	lpObj->Mana = 0;
	lpObj->MaxMana = 0;
	lpObj->AddMana = 0;
	lpObj->BP;
	lpObj->MaxBP = 0;
	lpObj->AddBP = 0;
	lpObj->Shield = 0;
	lpObj->MaxShield = 0;
	lpObj->AddShield = 0;
	lpObj->ChatLimitTime = 0;
	lpObj->ChatLimitTimeSec = 0;
	lpObj->PKCount = 0;
	lpObj->PKLevel = 0;
	lpObj->PKTime = GetTickCount();
	lpObj->X = 0;
	lpObj->Y = 0;
	lpObj->TX = 0;
	lpObj->TY = 0;
	lpObj->MTX = 0;
	lpObj->MTY = 0;
	lpObj->OldX = 0;
	lpObj->OldY = 0;
	lpObj->StartX = 0;
	lpObj->StartY = 0;
	lpObj->Dir = 0;
	lpObj->Map = 0;
	lpObj->PathCount = 0;
	lpObj->PathCur = 0;
	lpObj->PathStartEnd = 0;
	lpObj->Authority = 0;
	lpObj->AuthorityCode = 0;
	lpObj->Penalty = 0;
	lpObj->State = OBJECT_EMPTY;
	lpObj->Rest = 0;
	lpObj->ViewState = 0;
	lpObj->DieRegen = 0;
	lpObj->RegenOk = 0;
	lpObj->RegenMapNumber = 0;
	lpObj->RegenMapX = 0;
	lpObj->RegenMapY = 0;
	lpObj->RegenTime = 0;
	lpObj->PosNum = -1;
	lpObj->DelayLevel = 0;
	lpObj->DrinkSpeed = 0;
	lpObj->DrinkLastTime = 0;
	lpObj->MonsterDeleteTime = 0;
	lpObj->KalimaGateExist = 0;
	lpObj->KalimaGateIndex = -1;
	lpObj->KalimaGateEnterCount = 0;
	lpObj->AttackObj = 0;
	lpObj->AttackerKilled = 0;
	lpObj->TeleportSkillTime = 0;

	//rage
	


	for(int n=0;n < MAX_SELF_DEFENSE;n++)
	{
		lpObj->SelfDefense[n] = -1;
	}

	///Custom Pick

	lpObj->PickupEnable = 0;
	lpObj->PickupExc	= 0;
	lpObj->PickupSocket = 0;
	lpObj->PickupSetItem = 0;

	for (int i = 0; i < MAX_CUSTOMPICK; i++)
	{
		lpObj->Pickup[i] = -1;
	}

	memset(lpObj->SelfDefenseTime,0,sizeof(lpObj->SelfDefenseTime));

	memset(lpObj->GuildName,0,sizeof(lpObj->GuildName));

	lpObj->MySelfDefenseTime = 0;
	lpObj->PartyNumber = -1;
	lpObj->PartyTargetUser = -1;
	lpObj->GuildNumber = 0;
	lpObj->Guild = 0;
	lpObj->GuildStatus = -1;
	lpObj->GuildUnionTimeStamp = 0;
	lpObj->SummonIndex = -1;
	lpObj->Change = -1;
	lpObj->TargetNumber = -1;
	lpObj->TargetShopNumber = -1;
	lpObj->LastAttackerID = -1;
	lpObj->MagicDefense = 0;
	lpObj->Attribute = 0;
	lpObj->MultiSkillIndex = 0;
	lpObj->MultiSkillCount = 0;
	lpObj->RageFighterSkillIndex = 0;
	lpObj->RageFighterSkillCount = 0;
	lpObj->RageFighterSkillTarget = 10000;

	for(int n=0;n < MAX_SKILL_LIST;n++)
	{
		lpObj->Skill[n].Clear();
	}

	memset(lpObj->CharSet,0,sizeof(lpObj->CharSet));

	memset(lpObj->Resistance,0,sizeof(lpObj->Resistance));

	memset(lpObj->AddResistance,0,sizeof(lpObj->AddResistance));

	gObjClearViewport(lpObj);

	gObjMonsterInitHitDamage(lpObj);

	lpObj->Interface.use = 0;
	lpObj->Interface.type = INTERFACE_NONE;
	lpObj->Interface.state = 0;
	lpObj->InterfaceTime = 0;
	lpObj->Transaction = 0;

	gObjSetInventory1Pointer(lpObj);

	gObjSetEventInventory1Pointer(lpObj);

	gObjClearPlayerOption(lpObj);

	lpObj->TradeMoney = 0;
	lpObj->TradeOk = 0;
	lpObj->WarehouseCount = 0;
	lpObj->WarehousePW = 0;
	lpObj->WarehouseLock = -1;
	lpObj->WarehouseMoney = 0;
	lpObj->WarehouseSave = 0;
	lpObj->ChaosMoney = 0;
	lpObj->ChaosSuccessRate = 0;
	lpObj->ChaosLock = 0;
	#if(GAMESERVER_UPDATE>=802)
	lpObj->LoadEventInventory = 0;
	lpObj->MuunItemStatus[0] = 0;
	lpObj->MuunItemStatus[1] = 0;
	lpObj->LoadMuunInventory = 0;
	#endif
	lpObj->Option = 3;
	lpObj->ChaosCastleBlowTime = 0;
	lpObj->DuelUserReserved = -1;
	lpObj->DuelUserRequested = -1;
	lpObj->DuelUser = -1;
	lpObj->DuelScore = 0;
	lpObj->DuelTickCount = 0;

	memset(lpObj->PShopText,0,sizeof(lpObj->PShopText));

	memset(lpObj->PShopDealerName,0,sizeof(lpObj->PShopDealerName));

	memset(lpObj->VpPShopPlayer,0,sizeof(lpObj->VpPShopPlayer));

	lpObj->PShopOpen = 0;
	lpObj->PShopTransaction = 0;
	lpObj->PShopItemChange = 0;
	lpObj->PShopRedrawAbs = 0;
	lpObj->PShopWantDeal = 0;
	lpObj->PShopDealerIndex = -1;
	lpObj->PShopCustom = 0;
	lpObj->PShopCustomType = 0;
	lpObj->PShopCustomTime = 0;
	lpObj->PShopCustomOffline = 0;
	lpObj->PShopCustomOfflineTime = 0;
	lpObj->VpPShopPlayerCount = 0;
	lpObj->IsInBattleGround = 0;
	lpObj->UseEventServer = 0;
	lpObj->LoadWarehouse = 0;
	lpObj->LoadGuildWarehouse = 0;

	memset(lpObj->Quest,0xFF,sizeof(lpObj->Quest));

	lpObj->SendQuestInfo = 0;
	lpObj->CheckLifeTime = 0;
	lpObj->LastTeleportTime = 0;
	lpObj->SkillNovaState = 0;
	lpObj->SkillNovaCount = 0;
	lpObj->SkillNovaTime = 0;
	lpObj->ReqWarehouseOpen = 0;
	lpObj->IsFullSetItem = 0;
	lpObj->SkillSummonPartyTime = 0;
	lpObj->SkillSummonPartyMap = 0;
	lpObj->SkillSummonPartyX = 0;
	lpObj->SkillSummonPartyY = 0;
	lpObj->IsChaosMixCompleted = 0;
	lpObj->SkillLongSpearChange = 0;
	lpObj->CharSaveTime = 0;
	lpObj->LoadQuestKillCount = 0;
	lpObj->QuestKillCountIndex = -1;
	lpObj->LoadMasterLevel = 0;
	lpObj->MasterLevel = 0;
	lpObj->MasterPoint = 0;
	lpObj->MasterExperience = 0;
	lpObj->MasterNextExperience = 0;
#if USE_FAKE_ONLINE == TRUE
	//==== Fake ONline
	lpObj->IsFakeOnline = false;
	lpObj->m_OfflineMoveDelay = 0;
	lpObj->IsFakeRegen = false;
	lpObj->IsFakePVPMode = 0;
	lpObj->IsFakePartyMode = 0;
	lpObj->IsFakeMoveRange = 0;
	lpObj->IsFakeTimeLag = 0;
	lpObj->IsFakeSendParty = 0;
#endif

	for(int n=0;n < MAX_EFFECT_LIST;n++)
	{
		lpObj->Effect[n].Clear();
	}

	lpObj->ExtInventory = 0;
	lpObj->WarehouseNumber = 0;
	lpObj->AutoAddPointCount = 0;
	lpObj->AutoResetEnable = 0;

	memset(lpObj->AutoPartyPassword,0,sizeof(lpObj->AutoPartyPassword));

	memset(lpObj->AutoAddPointStats,0,sizeof(lpObj->AutoAddPointStats));

	memset(lpObj->AutoResetStats,0,sizeof(lpObj->AutoResetStats));

	lpObj->AttackCustom = 0;
	lpObj->AttackCustomSkill = 0;
	lpObj->AttackCustomDelay = 0;
	lpObj->AttackCustomZoneX = 0;
	lpObj->AttackCustomZoneY = 0;
	lpObj->AttackCustomZoneMap = 0;
	lpObj->AttackCustomOffline = 0;
	lpObj->AttackCustomOfflineTime = 0;
//	lpObj->AttackCustomOfflineMoneyDelay = 0;
	lpObj->AttackCustomAutoBuff = 0;
	lpObj->AttackCustomAutoBuffDelay = 0;
	lpObj->MiniMapState = 0;
	lpObj->MiniMapValue = -1;
	lpObj->MiningStage = 0;
	lpObj->MiningIndex = -1;
	lpObj->UseGuildMatching = 0;
	lpObj->UseGuildMatchingJoin = 0;
	lpObj->UsePartyMatching = 0;
	lpObj->UsePartyMatchingJoin = 0;

	memset(lpObj->CashShopTransaction,0,sizeof(lpObj->CashShopTransaction));

	memset(lpObj->CommandManagerTransaction,0,sizeof(lpObj->CommandManagerTransaction));

	memset(lpObj->LuckyCoinTransaction,0,sizeof(lpObj->LuckyCoinTransaction));

	memset(lpObj->PcPointTransaction,0,sizeof(lpObj->PcPointTransaction));

	lpObj->AutoAttackTime = 0;
	lpObj->TradeOkTime = 0;
	lpObj->PotionTime = 0;
	lpObj->ComboTime = 0;
	lpObj->AutoChageTime = 0; //오토환전
	lpObj->HelperDelayTime = 0;
	lpObj->HelperTotalTime = 0;
	lpObj->PcPointPointTime = GetTickCount();
	lpObj->HPAutoRecuperationTime = 0;
	lpObj->MPAutoRecuperationTime = 0;
	lpObj->BPAutoRecuperationTime = 0;
	lpObj->SDAutoRecuperationTime = 0;
	lpObj->CashShopGoblinPointTime = GetTickCount();
	lpObj->Reset = 0;
	lpObj->MasterReset = 0;
	lpObj->ChangeSkin = 0;
	lpObj->LoadQuestWorld = 0;
	lpObj->QuestWorldMonsterClass = -1;
	lpObj->LoadGens = 0;
	lpObj->GensFamily = 0;
	lpObj->GensRank = 0;
	lpObj->GensSymbol = 0;
	lpObj->GensContribution = 0;
	lpObj->GensNextContribution = 0;

	lpObj->m_OfflineSocket = false;
	lpObj->m_OfflineMode = 0;

	memset(&lpObj->EffectOption,0,sizeof(lpObj->EffectOption));

	gObjClearSpecialOption(lpObj);

	lpObj->HPRecoveryCount = 0;
	lpObj->MPRecoveryCount = 0;
	lpObj->BPRecoveryCount = 0;
	lpObj->SDRecoveryCount = 0;
	lpObj->ResurrectionTalismanActive = 0;
	lpObj->ResurrectionTalismanMap = 0;
	lpObj->ResurrectionTalismanX = 0;
	lpObj->ResurrectionTalismanY = 0;
	lpObj->MobilityTalismanActive = 0;
	lpObj->MobilityTalismanMap = 0;
	lpObj->MobilityTalismanX = 0;
	lpObj->MobilityTalismanY = 0;
	lpObj->MapServerMoveQuit = 0;
	#if(GAMESERVER_TYPE==1)
	lpObj->CsNpcExistVal = 0;
	lpObj->CsNpcType = 0;
	lpObj->CsGateOpen = 0;
	lpObj->CsGateLeverLinkIndex = -1;
	lpObj->CsNpcDfLevel = 0;
	lpObj->CsNpcRgLevel = 0;
	lpObj->CsJoinSide = 0;
	lpObj->CsGuildInvolved = 0;
	#endif
	lpObj->IsCastleNPCUpgradeCompleted = 0;
	lpObj->CsSiegeWeaponState = 0;
	lpObj->CsWeaponIndex = -1;
	lpObj->KillCount = 0;
	lpObj->AccumulatedDamage = 0;
	#if(GAMESERVER_TYPE==1)
	lpObj->LifeStoneCount = 0;
	lpObj->CreationState = 0;
	lpObj->CreatedActivationTime = 0;
	#endif

	lpObj->MonsterSkillElementOption.Reset();
	lpObj->Agro.ResetAll();
	lpObj->BasicAI = 0;
	lpObj->CurrentAI = 0;
	lpObj->CurrentAIState = 0;
	lpObj->LastAIRunTime = 0;
	lpObj->GroupNumber = 0;
	lpObj->SubGroupNumber = 0;
	lpObj->GroupMemberGuid = -1;
	lpObj->RegenType = 0;
	lpObj->LastAutomataRuntime = 0;
	lpObj->LastAutomataDelay = 0;
	lpObj->AccumulatedCrownAccessTime = 0;
	lpObj->CrywolfMVPScore = 0;
	lpObj->LastCheckTick = 0;
	lpObj->RenameActive = 0;
	lpObj->RunAndCatch = 0;
	lpObj->CustomQuest = 0;
	lpObj->CustomQuestMonsterIndex = -1;
	lpObj->CustomQuestMonsterQtd = -1;
	lpObj->CustomNpcQuest = -1;
	lpObj->CustomNpcQuestMonsterIndex = -1;
	lpObj->CustomNpcQuestMonsterQtd = -1;
	lpObj->CustomNpcQuestFinished = -1;
	lpObj->RussianRoulette = 0;
	lpObj->Kills = 0;
	lpObj->Deads = 0;
	lpObj->KillStreak = 0; //  연승 초기화 추가
	lpObj->BuyStat = 0;//스텟구매
	lpObj->Login = 0;//로그인
	lpObj->LevelStat = 0;//로그인
	lpObj->BuystatMs = 0;//스텟구매
	lpObj->AutoChange = false; //오토환전
	lpObj->AutoExp = false;
	lpObj->TheGift	= 0;
	lpObj->PAddDamage = 0;
	lpObj->PAddDefence = 0;
	lpObj->PAddLife = 0;
	lpObj->PAddExellent = 0;
	lpObj->PAddCritical = 0;
	lpObj->RuddCount = 0;
	lpObj->BCCount = 0; //캐슬
	lpObj->DSCount = 0;
	lpObj->StatCount  = 0;
	lpObj->MsStatCount  = 0;
	lpObj->RPSMode = 0;
	lpObj->AutoGuildAttack = false; //길드어택
	lpObj->AutoCtrl = false; //길드어택
	lpObj->Coin1 = 0;
	lpObj->Coin2 = 0;
	lpObj->Coin3 = 0;
	lpObj->BuyVip = 0;
	lpObj->LuckySpinTime = 0; //행운룰렛
	lpObj->RenameEnable = 0;
	lpObj->DisablePvp = 0;
	lpObj->PvP = 0;
	lpObj->KillAll = 0;
	lpObj->MapMoveDisable = 0;
	lpObj->SpeedHackDelay = 0;
	lpObj->SpeedHackCount = 0;
	lpObj->SpeedHackSkill = 0;
	lpObj->SpeedHackDialog = 0;
	lpObj->ShopDelay = 0;
	//lpObj->ItemshopDelay = 0;


	lpObj->showhpbar = 0;
	lpObj->timeshow = 0;
	lpObj->sendhpbartarget = 0;

	lpObj->JewelBlessCount = 0;
	lpObj->JewelSoulCount = 0;
	lpObj->JewelLifeCount = 0;
	lpObj->JewelCreationCount = 0;
	lpObj->JewelGuardianCount = 0;
	lpObj->JewelGemStoneCount = 0;
	lpObj->JewelHarmonyCount = 0;
	lpObj->JewelChaosCount = 0;
	lpObj->JewelLowStoneCount = 0;
	lpObj->JewelHighStoneCount = 0;

	lpObj->removebuff = 0;

	for(int n=0;n < 100;n++)
	{
		lpObj->CommandDelay[n] = 0;
		lpObj->CommandNotice[n] = 0;
	}

	for(int n=0;n < MAX_MONSTER_SEND_MSG;n++)
	{
		gSMMsg[aIndex][n].Clear();
	}

	for(int n=0;n < MAX_MONSTER_SEND_ATTACK_MSG;n++)
	{
		gSMAttackProcMsg[aIndex][n].Clear();
	}

	gSystemOfRage.CharacterZero(lpObj->Index);

}

void gObjClearPlayerOption(LPOBJ lpObj) // OK
{
	if(lpObj->Type != OBJECT_USER)
	{
		return;
	}

	for(int n=0;n < INVENTORY_SIZE;n++)
	{
		lpObj->Inventory[n].Clear();
	}

	for(int n=0;n < INVENTORY_SIZE;n++)
	{
		lpObj->Inventory1[n].Clear();
	}

	for(int n=0;n < INVENTORY_SIZE;n++)
	{
		lpObj->Inventory2[n].Clear();
	}

	for(int n=0;n < WAREHOUSE_SIZE;n++)
	{
		lpObj->Warehouse[n].Clear();
	}

	#if(GAMESERVER_UPDATE>=802)

	for(int n=0;n < EVENT_INVENTORY_SIZE;n++)
	{
		lpObj->EventInventory[n].Clear();
	}

	for(int n=0;n < EVENT_INVENTORY_SIZE;n++)
	{
		lpObj->EventInventory1[n].Clear();
	}

	for(int n=0;n < EVENT_INVENTORY_SIZE;n++)
	{
		lpObj->EventInventory2[n].Clear();
	}

	#endif

	#if(GAMESERVER_UPDATE>=803)

	for(int n=0;n < MUUN_INVENTORY_SIZE;n++)
	{
		lpObj->MuunInventory[n].Clear();
	}

	#endif

	#if(GAMESERVER_UPDATE>=802)

	lpObj->MuRummyInfo->Clear();

	#endif

	gTrade.ClearTrade(lpObj);

	memset(lpObj->InventoryMap,0xFF,INVENTORY_SIZE);

	memset(lpObj->InventoryMap1,0xFF,INVENTORY_SIZE);

	memset(lpObj->InventoryMap2,0xFF,INVENTORY_SIZE);

	memset(lpObj->WarehouseMap,0xFF,WAREHOUSE_SIZE);

	#if(GAMESERVER_UPDATE>=802)

	memset(lpObj->EventInventoryMap,0xFF,EVENT_INVENTORY_SIZE);

	memset(lpObj->EventInventoryMap1,0xFF,EVENT_INVENTORY_SIZE);

	memset(lpObj->EventInventoryMap2,0xFF,EVENT_INVENTORY_SIZE);

	memset(lpObj->MuunInventoryMap,0xFF,MUUN_INVENTORY_SIZE);

	#endif

	for(int n=0;n < MAX_MASTER_SKILL_LIST;n++)
	{
		lpObj->MasterSkill[n].Clear();
	}

	for(int n=0;n < MAX_QUEST_KILL_COUNT;n++)
	{
		lpObj->QuestKillCount[n].Clear();
	}

	for(int n=0;n < MAX_QUEST_WORLD_LIST;n++)
	{
		memset(&lpObj->QuestWorldList[n],0xFF,sizeof(lpObj->QuestWorldList[n]));
	}

	for(int n=0;n < MAX_GENS_SYSTEM_VICTIM;n++)
	{
		lpObj->GensVictimList[n].Reset();
	}

	#if(GAMESERVER_UPDATE>=701)

	for(int n=0;n < MAX_PENTAGRAM_JEWEL_INFO;n++)
	{
		lpObj->PentagramJewelInfo_Inventory[n].Clear();
	}

	for(int n=0;n < MAX_PENTAGRAM_JEWEL_INFO;n++)
	{
		lpObj->PentagramJewelInfo_Warehouse[n].Clear();
	}

	#endif

	for(int n=0;n < MAX_SKILL;n++)
	{
		memset(&lpObj->SkillDelay[n],0,sizeof(lpObj->SkillDelay[n]));
	}

	for(int n=0;n < MAX_HACK_PACKET_INFO;n++)
	{
		memset(&lpObj->HackPacketDelay[n],0,sizeof(lpObj->HackPacketDelay[n]));
	}

	for(int n=0;n < MAX_HACK_PACKET_INFO;n++)
	{
		memset(&lpObj->HackPacketCount[n],0,sizeof(lpObj->HackPacketCount[n]));
	}
}

void gObjClearSpecialOption(LPOBJ lpObj) // OK
{
	#if(GAMESERVER_UPDATE>=701)

	memset(&lpObj->PentagramOption,0,sizeof(lpObj->PentagramOption));

	memset(&lpObj->PentagramJewelOption,0,sizeof(lpObj->PentagramJewelOption));

	#endif

	lpObj->ArmorSetBonus = 0;
	lpObj->SkillDamageBonus = 0;
	lpObj->DoubleDamageRate = 0;
	lpObj->TripleDamageRate = 0;
	lpObj->IgnoreDefenseRate = 0;
	lpObj->IgnoreShieldGaugeRate = 0;
	lpObj->CriticalDamageRate = 0;
	lpObj->CriticalDamage = 0;
	lpObj->ExcellentDamageRate = 0;
	lpObj->ExcellentDamage = 0;
	lpObj->ResistDoubleDamageRate = 0;
	lpObj->ResistIgnoreDefenseRate = 0;
	lpObj->ResistIgnoreShieldGaugeRate = 0;
	lpObj->ResistCriticalDamageRate = 0;
	lpObj->ResistExcellentDamageRate = 0;
	lpObj->ResistStunRate = 0;
	lpObj->ExperienceRate = 100;
	lpObj->MasterExperienceRate = 100;
	lpObj->ItemDropRate = 100;
	lpObj->MoneyAmountDropRate = 100;
	lpObj->HPRecovery = 0;
	lpObj->MPRecovery = 0;
	lpObj->BPRecovery = 2;
	lpObj->SDRecovery = 0;
	lpObj->HPRecoveryRate = 0;
	lpObj->MPRecoveryRate = 0;
	lpObj->BPRecoveryRate = 0;
	lpObj->SDRecoveryRate = 0;
	lpObj->SDRecoveryType = 0;
	lpObj->MPConsumptionRate = 100;
	lpObj->BPConsumptionRate = 100;
	lpObj->ShieldGaugeRate = gServerInfo.m_ShieldGaugeRate;
	lpObj->DecreaseShieldGaugeRate = 0;
	lpObj->DamagePvP = 0;
	lpObj->DefensePvP = 0;
	lpObj->AttackSuccessRatePvP = 0;
	lpObj->DefenseSuccessRatePvP = 0;
	lpObj->ShieldDamageReduction = gServerInfo.m_DefenseConstA;
	lpObj->ShieldDamageReductionTime = 0;

	memset(lpObj->DamageReduction,0,sizeof(lpObj->DamageReduction));

	lpObj->DamageReflect = 0;
	lpObj->HuntHP = 0;
	lpObj->HuntMP = 0;
	lpObj->HuntBP = 0;
	lpObj->HuntSD = 0;
	lpObj->WeaponDurabilityRate = 100;
	lpObj->ArmorDurabilityRate = 100;
	lpObj->WingDurabilityRate = 100;
	lpObj->GuardianDurabilityRate = 100;
	lpObj->PendantDurabilityRate = 100;
	lpObj->RingDurabilityRate = 100;
	lpObj->PetDurabilityRate = 100;
	lpObj->FullDamageReflectRate = 0;
	lpObj->DefensiveFullHPRestoreRate = 0;
	lpObj->DefensiveFullMPRestoreRate = 0;
	lpObj->DefensiveFullSDRestoreRate = 0;
	lpObj->DefensiveFullBPRestoreRate = 0;
	lpObj->OffensiveFullHPRestoreRate = 0;
	lpObj->OffensiveFullMPRestoreRate = 0;
	lpObj->OffensiveFullSDRestoreRate = 0;
	lpObj->OffensiveFullBPRestoreRate = 0;
}

void gObjCalcExperience(LPOBJ lpObj) // OK
{
	lpObj->Experience = ((lpObj->Experience<gLevelExperience[(lpObj->Level-1)])?gLevelExperience[(lpObj->Level-1)]:lpObj->Experience);

	lpObj->NextExperience = gLevelExperience[((lpObj->Level>=MAX_CHARACTER_LEVEL)?MAX_CHARACTER_LEVEL:lpObj->Level)];

	gMasterSkillTree.CalcMasterLevelNextExperience(lpObj);

}

bool gObjGetRandomFreeLocation(int map,int* ox,int* oy,int tx,int ty,int count) // OK
{
	int x = (*ox);
	int y = (*oy);

	tx = ((tx<1)?1:tx);
	ty = ((ty<1)?1:ty);

	for(int n=0;n < count;n++)
	{
		(*ox) = ((GetLargeRand()%(tx+1))*((GetLargeRand()%2==0)?-1:1))+x;
		(*oy) = ((GetLargeRand()%(ty+1))*((GetLargeRand()%2==0)?-1:1))+y;

		if(gMap[map].CheckAttr((*ox),(*oy),255) == 0)
		{
			return 1;
		}
	}

	return 0;
}

bool gObjAllocData(int aIndex) // OK
{
	CMemoryAllocatorInfo MemoryAllocatorInfo;

	if(gMemoryAllocator.GetMemoryAllocatorInfo(&MemoryAllocatorInfo,aIndex) == 0)
	{
		gObj.ObjectStruct[aIndex] = new OBJECTSTRUCT;

		memset(gObj.ObjectStruct[aIndex],0,sizeof(OBJECTSTRUCT));

		InitializeCriticalSection(&gObj.ObjectStruct[aIndex]->PShopTrade);

		MemoryAllocatorInfo.m_Index = aIndex;

		MemoryAllocatorInfo.m_Active = 1;

		MemoryAllocatorInfo.m_ActiveTime = GetTickCount();

		MemoryAllocatorInfo.Alloc();

		gMemoryAllocator.InsertMemoryAllocatorInfo(MemoryAllocatorInfo);

		gMemoryAllocator.BindMemoryAllocatorInfo(aIndex,MemoryAllocatorInfo);

		if(OBJECT_MONSTER_RANGE(aIndex) != 0){gObjMonCount = (((++gObjMonCount)>=MAX_OBJECT_MONSTER)?OBJECT_START_MONSTER:gObjMonCount);}

		if(OBJECT_BOTS_RANGE(aIndex) != 0){gObjBotCount = (((++gObjBotCount)>=MAX_OBJECT_BOTS)?OBJECT_START_BOTS:gObjBotCount);}

		if(OBJECT_SUMMON_RANGE(aIndex) != 0){gObjCallMonCount = (((++gObjCallMonCount)>=OBJECT_START_USER)?MAX_OBJECT_MONSTER:gObjCallMonCount);}

		if(OBJECT_USER_RANGE(aIndex) != 0){gObjCount = (((++gObjCount)>=MAX_OBJECT)?OBJECT_START_USER:gObjCount);}
	}
	else
	{
		MemoryAllocatorInfo.m_Index = aIndex;

		MemoryAllocatorInfo.m_Active = 1;

		MemoryAllocatorInfo.m_ActiveTime = GetTickCount();

		gMemoryAllocator.InsertMemoryAllocatorInfo(MemoryAllocatorInfo);

		gMemoryAllocator.BindMemoryAllocatorInfo(aIndex,MemoryAllocatorInfo);
	}

	return 1;
}

void gObjFreeData(int aIndex) // OK
{
	CMemoryAllocatorInfo MemoryAllocatorInfo;

	if(gMemoryAllocator.GetMemoryAllocatorInfo(&MemoryAllocatorInfo,aIndex) != 0)
	{
		MemoryAllocatorInfo.m_Index = aIndex;

		MemoryAllocatorInfo.m_Active = 0;

		MemoryAllocatorInfo.m_ActiveTime = GetTickCount();

		gMemoryAllocator.InsertMemoryAllocatorInfo(MemoryAllocatorInfo);
	}
}

short gObjAddSearch(SOCKET socket,char* IpAddress) // OK
{
	int index = -1;
	int count = gObjCount;

	if(gGameServerLogOut != 0)
	{
		GCConnectAccountSend(0,2,socket);
		return -1;
	}

	if(gGameServerDisconnect != 0)
	{
		GCConnectAccountSend(0,2,socket);
		return -1;
	}

	if(gObjTotalUser >= gServerInfo.m_ServerMaxUserNumber)
	{
		GCConnectAccountSend(0,4,socket);
		return -1;
	}

	if(gMemoryAllocator.GetMemoryAllocatorFree(&index,OBJECT_START_USER,MAX_OBJECT,10000) != 0)
	{
		return index;
	}

	for(int n=OBJECT_START_USER;n < MAX_OBJECT;n++)
	{
		if(gObj[count].Connected == OBJECT_OFFLINE)
		{
			return count;
		}
		else
		{
			count = (((++count)>=MAX_OBJECT)?OBJECT_START_USER:count);
		}
	}

	return -1;
}

short gObjAdd(SOCKET socket,char* IpAddress,int aIndex) // OK
{
	if(OBJECT_RANGE(aIndex) == 0)
	{
		return -1;
	}

	if(gObj[aIndex].Connected != OBJECT_OFFLINE)
	{
		return -1;
	}

	if(gObjAllocData(aIndex) == 0)
	{
		return -1;
	}

	LPOBJ lpObj = &gObj[aIndex];

	gObjCharZeroSet(aIndex);

	lpObj->Index = aIndex;
	lpObj->Connected = OBJECT_CONNECTED;
	lpObj->LoginMessageSend = 0;
	lpObj->LoginMessageCount = 0;
	lpObj->Socket = socket;

	strcpy_s(lpObj->IpAddr,IpAddress);

	lpObj->AutoSaveTime = GetTickCount();
	lpObj->ConnectTickCount = GetTickCount();
	lpObj->Type = OBJECT_USER;
	lpObj->ExtWarehouse = 0;

	memset(lpObj->Account,0,sizeof(lpObj->Account));

	gSerialCheck[aIndex].Init();

	gIpManager.InsertIpAddress(lpObj->IpAddr);

	LogAddConnect(LOG_GREEN,"[Obj][%d] AddClient (%s)",aIndex,lpObj->IpAddr);

	return aIndex;
}

short gObjDel(int aIndex) // OK
{
	if(OBJECT_RANGE(aIndex) == 0)
	{
		return -1;
	}

	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Connected == OBJECT_OFFLINE)
	{
		return -1;
	}

	if(MAP_RANGE(lpObj->Map) != 0)
	{
		gMap[lpObj->Map].DelStandAttr(lpObj->X,lpObj->Y);
		gMap[lpObj->Map].DelStandAttr(lpObj->OldX,lpObj->OldY);
	}

	if(lpObj->Type == OBJECT_USER)
	{
		if(lpObj->MapServerMoveQuit == 0)
		{
			
			gObjectManager.CharacterGameClose(aIndex);
			GJDisconnectAccountSend(aIndex,lpObj->Account,lpObj->IpAddr);
		}

		if(lpObj->Account[0] != 0){LogAddConnect(LOG_ALERT,"[Obj][%d] DelAccount (%s)",aIndex,lpObj->Account);}

		LogAddConnect(LOG_ALERT,"[Obj][%d] DelClient (%s)",aIndex,lpObj->IpAddr);

		memset(lpObj->Account,0,sizeof(lpObj->Account));

		memset(lpObj->PersonalCode,0,sizeof(lpObj->PersonalCode));

		gIpManager.RemoveIpAddress(lpObj->IpAddr); //아이피

	}

	lpObj->Connected = OBJECT_OFFLINE;

	gObjFreeData(aIndex);

	return aIndex;
}

LPOBJ gObjFind(char* name) // OK
{
	for(int n=OBJECT_START_USER;n < MAX_OBJECT;n++)
	{
		if(gObjIsConnectedGP(n) != 0 && strcmp(gObj[n].Name,name) == 0)
		{
			return &gObj[n];
		}
	}

	return 0;
}

int gObjCalcDistance(LPOBJ lpObj,LPOBJ lpTarget) // OK
{
	return (int)sqrt(pow(((float)lpObj->X-(float)lpTarget->X),2)+pow(((float)lpObj->Y-(float)lpTarget->Y),2));
}
//**************************************************************************//
// OBJECT CHECK FUNCTIONS **************************************************//
//**************************************************************************//
bool gObjIsConnected(int aIndex) // OK
{
	if(OBJECT_RANGE(aIndex) == 0)
	{
		return 0;
	}

	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Connected != OBJECT_ONLINE)
	{
		return 0;
	}

	return 1;
}

bool gObjIsConnectedGP(int aIndex) // OK
{
	if(OBJECT_RANGE(aIndex) == 0)
	{
		return 0;
	}

	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Connected != OBJECT_ONLINE)
	{
		return 0;
	}

	if(lpObj->Type != OBJECT_USER  && lpObj->Type != OBJECT_BOTS  || (lpObj->CloseCount > 0 || lpObj->MapServerMoveQuit != 0))
	{
		return 0;
	}

	return 1;
}

bool gObjIsConnectedGS(int aIndex) // OK
{
	if(OBJECT_RANGE(aIndex) == 0)
	{
		return 0;
	}

	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Connected != OBJECT_ONLINE)
	{
		return 0;
	}

	if(lpObj->Type == OBJECT_USER && lpObj->Type != OBJECT_BOTS && (lpObj->CloseCount > 0 || lpObj->MapServerMoveQuit != 0))
	{
		return 0;
	}

	return 1;
}

bool gObjIsNameValid(int aIndex,char* name) // OK
{
	if(OBJECT_RANGE(aIndex) == 0)
	{
		return 0;
	}

	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Connected == OBJECT_OFFLINE)
	{
		return 0;
	}

	if(strcmp(name,"") == 0)
	{
		return 0;
	}

	if(strcmp(lpObj->Name,name) != 0)
	{
		return 0;
	}

	return 1;
}

bool gObjIsAccountValid(int aIndex,char* account) // OK
{
	if(OBJECT_RANGE(aIndex) == 0)
	{
		return 0;
	}

	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Connected == OBJECT_OFFLINE)
	{
		return 0;
	}

	if(strcmp(account,"") == 0)
	{
		return 0;
	}

	if(strcmp(lpObj->Account,account) != 0)
	{
		return 0;
	}

	return 1;
}

bool gObjIsChangeSkin(int aIndex) // OK
{
	if(gObj[aIndex].Change < 0)
	{
		return 0;
	}

	if(gObj[aIndex].Change == gServerInfo.m_TransformationRing1 || gObj[aIndex].Change == gServerInfo.m_TransformationRing2 || gObj[aIndex].Change == gServerInfo.m_TransformationRing3 || gObj[aIndex].Change == gServerInfo.m_TransformationRing4 || gObj[aIndex].Change == gServerInfo.m_TransformationRing5 || gObj[aIndex].Change == gServerInfo.m_TransformationRing6)
	{
		return ((gObj[aIndex].ChangeSkin==0)?1:0);
	}

	if(gObj[aIndex].Change == 372 || gObj[aIndex].Change == 373 || gObj[aIndex].Change == 374 || gObj[aIndex].Change == 378 || gObj[aIndex].Change == 477 || gObj[aIndex].Change == 503 || gObj[aIndex].Change == 548 || gObj[aIndex].Change == 616 || gObj[aIndex].Change == 617 || gObj[aIndex].Change == 625 || gObj[aIndex].Change == 626 || gObj[aIndex].Change == 642)
	{
		return ((gObj[aIndex].ChangeSkin==0)?1:0);
	}

	return 1;
}

bool gObjCheckMaxMoney(int aIndex,DWORD AddMoney) // OK
{
	if(OBJECT_RANGE(aIndex) == 0)
	{
		return 0;
	}

	if(((QWORD)gObj[aIndex].Money+(QWORD)AddMoney) > (QWORD)MAX_MONEY)
	{
		return 0;
	}

	return 1;
}

bool gObjCheckPersonalCode(int aIndex,char* PersonalCode) // OK
{
	if(gServerInfo.m_PersonalCodeCheck == 0)
	{
		return 1;
	}

	if(strncmp(PersonalCode,&gObj[aIndex].PersonalCode[6],7) == 0)
	{
		return 1;
	}

	return 0;
}

bool gObjCheckResistance(LPOBJ lpObj,int type) // OK
{
	BYTE resist = lpObj->Resistance[type];

	if(resist == 0xFF)
	{
		return 1;
	}

	if((lpObj->Authority & 32) != 0 && (lpObj->Inventory[10].m_Index == GET_ITEM(13,42) || lpObj->Inventory[11].m_Index == GET_ITEM(13,42)))
	{
		return 1;
	}

	if(gEffectManager.CheckEffect(lpObj,EFFECT_IRON_DEFENSE) != 0 || gEffectManager.CheckEffect(lpObj,EFFECT_IRON_DEFENSE_IMPROVED) != 0)
	{
		return 1;
	}

	if((type == 0 || type == 2) && gEffectManager.CheckEffect(lpObj,EFFECT_SOUL_POTION) != 0)
	{
		resist += (resist*50)/100;
	}

	if((GetLargeRand()%(resist+1)) == 0)
	{
		return 0;
	}

	return 1;
}

bool gObjCheckTeleportArea(int aIndex,int x,int y) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Live == 0 || lpObj->Teleport != 0)
	{
		return 0;
	}

	if(x < (lpObj->X-8) || x > (lpObj->X+8) || y < (lpObj->Y-8) || y > (lpObj->Y+8))
	{
		return 0;
	}

	if(gMap[lpObj->Map].CheckAttr(lpObj->X,lpObj->Y,1) != 0 || gMap[lpObj->Map].CheckAttr(x,y,1) != 0)
	{
		return 0;
	}

	return 1;
}

bool gObjCheckMapTile(LPOBJ lpObj,int type) // OK
{
	if(lpObj->Type != OBJECT_USER)
	{
		return 0;
	}

	if(CC_MAP_RANGE(lpObj->Map) != 0 && gChaosCastle.GetState(GET_CC_LEVEL(lpObj->Map)) == CC_STATE_START)
	{
		return 0;
	}

	for(int x=0;x < 3;x++)
	{
		for(int y=0;y < 3;y++)
		{
			if(gMap[lpObj->Map].CheckAttr((lpObj->X+x),(lpObj->Y+y),4) == 0 && gMap[lpObj->Map].CheckAttr((lpObj->X+x),(lpObj->Y+y),8) == 0)
			{
				return 0;
			}
		}
	}

	switch(lpObj->Class)
	{
		case CLASS_DW:
			gObjMoveGate(lpObj->Index,17);
			break;
		case CLASS_DK:
			gObjMoveGate(lpObj->Index,17);
			break;
		case CLASS_FE:
			gObjMoveGate(lpObj->Index,17);
			break;
		case CLASS_MG:
			gObjMoveGate(lpObj->Index,17);
			break;
		case CLASS_DL:
			gObjMoveGate(lpObj->Index,17);
			break;
		case CLASS_SU:
			gObjMoveGate(lpObj->Index,17);
			break;
		case CLASS_RF:
			gObjMoveGate(lpObj->Index,17);
			break;
	}

	return 1;
}
//**************************************************************************//
// ITEM TRANSACTION FUNCTIONS **********************************************//
//**************************************************************************//
bool gObjFixInventoryPointer(int aIndex) // OK
{
	if(OBJECT_RANGE(aIndex) == 0)
	{
		return 0;
	}

	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Inventory == lpObj->Inventory1)
	{
		return 1;
	}

	if(lpObj->Inventory == lpObj->Inventory2)
	{
		if(lpObj->Transaction == 1)
		{
			return 0;
		}
		else
		{
			for(int n=0;n < INVENTORY_SIZE;n++)
			{
				lpObj->Inventory2[n].Clear();
			}
		}
	}

	gObjSetInventory1Pointer(lpObj);
	return 0;
}

void gObjSetInventory1Pointer(LPOBJ lpObj) // OK
{
	lpObj->Inventory = lpObj->Inventory1;
	lpObj->InventoryMap = lpObj->InventoryMap1;
}

void gObjSetInventory2Pointer(LPOBJ lpObj) // OK
{
	lpObj->Inventory = lpObj->Inventory2;
	lpObj->InventoryMap = lpObj->InventoryMap2;
}

bool gObjFixEventInventoryPointer(int aIndex) // OK
{
	#if(GAMESERVER_UPDATE>=802)

	if(OBJECT_RANGE(aIndex) == 0)
	{
		return 0;
	}

	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->EventInventory == lpObj->EventInventory1)
	{
		return 1;
	}

	if(lpObj->EventInventory == lpObj->EventInventory2)
	{
		if(lpObj->Transaction == 1)
		{
			return 0;
		}
		else
		{
			for(int n=0;n < EVENT_INVENTORY_SIZE;n++)
			{
				lpObj->EventInventory2[n].Clear();
			}
		}
	}

	gObjSetEventInventory1Pointer(lpObj);
	return 0;

	#else

	return 1;

	#endif
}

void gObjSetEventInventory1Pointer(LPOBJ lpObj) // OK
{
	#if(GAMESERVER_UPDATE>=802)

	lpObj->EventInventory = lpObj->EventInventory1;
	lpObj->EventInventoryMap = lpObj->EventInventoryMap1;

	#endif
}

void gObjSetEventInventory2Pointer(LPOBJ lpObj) // OK
{
	#if(GAMESERVER_UPDATE>=802)

	lpObj->EventInventory = lpObj->EventInventory2;
	lpObj->EventInventoryMap = lpObj->EventInventoryMap2;

	#endif
}

bool gObjInventoryTransaction(int aIndex) // OK
{
	if(OBJECT_RANGE(aIndex) == 0)
	{
		return 0;
	}

	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Transaction == 1)
	{
		return 0;
	}

	for(int n=0;n < MAX_SKILL_LIST;n++)
	{
		lpObj->SkillBackup[n] = lpObj->Skill[n];
	}

	for(int n=0;n < INVENTORY_SIZE;n++)
	{
		lpObj->Inventory2[n] = lpObj->Inventory1[n];
	}

	#if(GAMESERVER_UPDATE>=802)

	for(int n=0;n < EVENT_INVENTORY_SIZE;n++)
	{
		lpObj->EventInventory2[n] = lpObj->EventInventory1[n];
	}

	#endif

	memcpy(lpObj->InventoryMap2,lpObj->InventoryMap1,INVENTORY_SIZE);

	#if(GAMESERVER_UPDATE>=802)

	memcpy(lpObj->EventInventoryMap2,lpObj->EventInventoryMap1,EVENT_INVENTORY_SIZE);

	#endif

	gObjSetInventory2Pointer(lpObj);

	gObjSetEventInventory2Pointer(lpObj);

	lpObj->Transaction = 1;
	return 1;
}

bool gObjInventoryCommit(int aIndex) // OK
{
	if(OBJECT_RANGE(aIndex) == 0)
	{
		return 0;
	}

	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Transaction != 1)
	{
		return 0;
	}

	for(int n=0;n < INVENTORY_SIZE;n++)
	{
		lpObj->Inventory1[n] = lpObj->Inventory2[n];
	}

	#if(GAMESERVER_UPDATE>=802)

	for(int n=0;n < EVENT_INVENTORY_SIZE;n++)
	{
		lpObj->EventInventory1[n] = lpObj->EventInventory2[n];
	}

	#endif

	memcpy(lpObj->InventoryMap1,lpObj->InventoryMap2,INVENTORY_SIZE);

	#if(GAMESERVER_UPDATE>=802)

	memcpy(lpObj->EventInventoryMap1,lpObj->EventInventoryMap2,EVENT_INVENTORY_SIZE);

	#endif

	gObjSetInventory1Pointer(lpObj);

	gObjSetEventInventory1Pointer(lpObj);

	lpObj->Transaction = 2;
	return 1;
}

bool gObjInventoryRollback(int aIndex) // OK
{
	if(OBJECT_RANGE(aIndex) == 0)
	{
		return 0;
	}

	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Transaction != 1)
	{
		return 0;
	}

	for(int n=0;n < MAX_SKILL_LIST;n++)
	{
		lpObj->Skill[n] = lpObj->SkillBackup[n];
	}

	for(int n=0;n < INVENTORY_SIZE;n++)
	{
		lpObj->Inventory2[n].Clear();
	}

	#if(GAMESERVER_UPDATE>=802)

	for(int n=0;n < EVENT_INVENTORY_SIZE;n++)
	{
		lpObj->EventInventory2[n].Clear();
	}

	#endif

	gObjSetInventory1Pointer(lpObj);

	gObjSetEventInventory1Pointer(lpObj);

	lpObj->Transaction = 3;
	return 1;
}
//**************************************************************************//
// VIEWPORT FUNCTIONS ******************************************************//
//**************************************************************************//
void gObjSetViewport(int aIndex,int state) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	for(int n=0;n < MAX_VIEWPORT;n++)
	{
		if(lpObj->VpPlayer[n].state == state)
		{
			switch(state)
			{
				case VIEWPORT_SEND:
					lpObj->VpPlayer[n].state = VIEWPORT_WAIT;
					break;
				case VIEWPORT_DESTROY:
					lpObj->VpPlayer[n].state = VIEWPORT_NONE;
					lpObj->VpPlayer[n].index = -1;
					lpObj->VPCount--;
					break;
			}
		}

		if(lpObj->VpPlayerItem[n].state == state)
		{
			switch(state)
			{
				case VIEWPORT_SEND:
					lpObj->VpPlayerItem[n].state = VIEWPORT_WAIT;
					break;
				case VIEWPORT_DESTROY:
					lpObj->VpPlayerItem[n].state = VIEWPORT_NONE;
					lpObj->VpPlayerItem[n].index = -1;
					lpObj->VPCountItem--;
					break;
			}
		}
	}
}


void gObjClearViewport(LPOBJ lpObj) // OK
{
	for (int n = 0; n < MAX_VIEWPORT; n++)
	{
		lpObj->VpPlayer[n].state = VIEWPORT_NONE;
		lpObj->VpPlayer[n].index = -1;
		lpObj->VpPlayer2[n].state = VIEWPORT_NONE;
		lpObj->VpPlayer2[n].index = -1;
		lpObj->VpPlayerItem[n].state = VIEWPORT_NONE;
		lpObj->VpPlayerItem[n].index = -1;
	}

	lpObj->VPCount = 0;
	lpObj->VPCount2 = 0;
	lpObj->VPCountItem = 0;
}

void gObjViewportListProtocolDestroy(LPOBJ lpObj) // OK
{
	gViewport.GCViewportSimpleDestroySend(lpObj);
}

void gObjViewportListProtocolCreate(LPOBJ lpObj) // OK
{
	if(lpObj->Type == OBJECT_USER || lpObj->Type == OBJECT_BOTS) //MC
	{
		gViewport.GCViewportSimplePlayerSend(lpObj);
		gViewport.GCViewportSimpleChangeSend(lpObj);
		gViewport.GCViewportSimpleGuildSend(lpObj);
		gViewport.GCViewportSimpleGensSystemSend(lpObj);
	}
	else
	{
		gViewport.GCViewportSimpleMonsterSend(lpObj);
		gViewport.GCViewportSimpleSummonSend(lpObj);
	}
}

void gObjViewportListProtocol(int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Connected != OBJECT_ONLINE)
	{
		return;
	}

	if(lpObj->Type == OBJECT_USER || lpObj->Type == OBJECT_BOTS) //MC
	{
		gViewport.GCViewportDestroySend(aIndex);
		gViewport.GCViewportDestroyItemSend(aIndex);
	}

	gObjSetViewport(aIndex,VIEWPORT_DESTROY);

	if(lpObj->Type == OBJECT_USER)
	{
		gViewport.GCViewportPlayerSend(aIndex);
		gViewport.GCViewportMonsterSend(aIndex);
		gViewport.GCViewportSummonSend(aIndex);
		gViewport.GCViewportItemSend(aIndex);
		gViewport.GCViewportChangeSend(aIndex);
		gViewport.GCViewportGuildSend(aIndex);
		gViewport.GCViewportGensSystemSend(aIndex);
	}

	gObjSetViewport(aIndex,VIEWPORT_SEND);
}

void gObjViewportListDestroy(int aIndex) // OK
{
	if(gObjIsConnected(aIndex) == 0)
	{
		return;
	}

	gViewport.DestroyViewportPlayer1(aIndex);

	gViewport.DestroyViewportPlayer2(aIndex);

	gViewport.DestroyViewportMonster1(aIndex);

	gViewport.DestroyViewportMonster2(aIndex);

	gViewport.DestroyViewportItem(aIndex);
}

void gObjViewportListCreate(int aIndex) // OK
{
	if(gObjIsConnected(aIndex) == 0)
	{
		return;
	}

	if(gObj[aIndex].RegenOk > 0)
	{
		return;
	}

	gViewport.CreateViewportPlayer(aIndex);

	gViewport.CreateViewportMonster(aIndex);

	gViewport.CreateViewportItem(aIndex);
}
//**************************************************************************//
// USER FUNCTIONS **********************************************************//
//**************************************************************************//
void gObjSetKillCount(int aIndex,int type) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(type == 0)
	{
		lpObj->KillCount = 0;
	}

	if(type == 1 && lpObj->KillCount < 255)
	{
		lpObj->KillCount++;
	}

	if(type == 2 && lpObj->KillCount > 0)
	{
		lpObj->KillCount--;
	}

	PMSG_KILL_COUNT_SEND pMsg;

	pMsg.header.set(0xB8,0x01,sizeof(pMsg));

	pMsg.count = lpObj->KillCount;

	DataSend(aIndex,(BYTE*)&pMsg,pMsg.header.size);
}

void gObjTeleportMagicUse(int aIndex,int x,int y) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->Teleport != 0)
	{
		return;
	}

	lpObj->TeleportTime = GetTickCount();
	lpObj->PathCount = 0;
	lpObj->Teleport = 1;
	lpObj->ViewState = 1;
	lpObj->X = x;
	lpObj->Y = y;
	lpObj->TX = x;
	lpObj->TY = y;

	gMap[lpObj->Map].DelStandAttr(lpObj->OldX,lpObj->OldY);
	gMap[lpObj->Map].SetStandAttr(lpObj->TX,lpObj->TY);

	lpObj->OldX = lpObj->TX;
	lpObj->OldY = lpObj->TY;

	gObjViewportListProtocolDestroy(lpObj);
}

void gObjInterfaceCheckTime(LPOBJ lpObj) // OK
{
	if(lpObj->Interface.use == 0)
	{
		return;
	}

	if((GetTickCount()-lpObj->InterfaceTime) < 5000)
	{
		return;
	}

	if(lpObj->Interface.type == INTERFACE_TRADE)
	{
		if(lpObj->Interface.state == 0)
		{
			if(OBJECT_RANGE(lpObj->TargetNumber) != 0)
			{
				gObj[lpObj->TargetNumber].Interface.use = 0;
				gObj[lpObj->TargetNumber].Interface.type = INTERFACE_NONE;
				gObj[lpObj->TargetNumber].Interface.state = 0;
				gObj[lpObj->TargetNumber].TargetNumber = -1;

				gTrade.GCTradeResultSend(lpObj->TargetNumber,3);
			}

			lpObj->Interface.use = 0;
			lpObj->Interface.type = INTERFACE_NONE;
			lpObj->Interface.state = 0;
			lpObj->TargetNumber = -1;

			gTrade.GCTradeResultSend(lpObj->Index,3);
		}
	}

	if(lpObj->Interface.type == INTERFACE_PARTY)
	{
		if(lpObj->Interface.state == 0)
		{
			if(OBJECT_RANGE(lpObj->TargetNumber) != 0)
			{
				gObj[lpObj->TargetNumber].Interface.use = 0;
				gObj[lpObj->TargetNumber].Interface.type = INTERFACE_NONE;
				gObj[lpObj->TargetNumber].Interface.state = 0;
				gObj[lpObj->TargetNumber].TargetNumber = -1;
				gObj[lpObj->TargetNumber].PartyTargetUser = -1;

				gParty.GCPartyResultSend(lpObj->TargetNumber,0);
			}

			lpObj->Interface.use = 0;
			lpObj->Interface.type = INTERFACE_NONE;
			lpObj->Interface.state = 0;
			lpObj->TargetNumber = -1;
			lpObj->PartyTargetUser = -1;

			gParty.GCPartyResultSend(lpObj->Index,0);
		}
	}

	lpObj->InterfaceTime = GetTickCount();
}

void gObjSkillNovaCheckTime(LPOBJ lpObj) // OK
{
	if(lpObj->SkillNovaState == 0)
	{
		return;
	}

	if((GetTickCount()-lpObj->SkillNovaTime) < 500)
	{
		return;
	}

	lpObj->SkillNovaTime = GetTickCount();

	if((++lpObj->SkillNovaCount) == 12)
	{
		CSkill* lpSkill = gSkillManager.GetSkill(lpObj,SKILL_NOVA);

		if(lpSkill != 0)
		{
			gSkillManager.RunningSkill(lpObj->Index,0,lpSkill,0,0,0,0);
		}
	}
	else
	{
		PMSG_SKILL_NOVA_SEND pMsg;

		pMsg.header.set(0xBA,sizeof(pMsg));

		pMsg.index[0] = SET_NUMBERHB(lpObj->Index);

		pMsg.index[1] = SET_NUMBERLB(lpObj->Index);

		pMsg.type = SKILL_NOVA;

		pMsg.count = lpObj->SkillNovaCount;

		DataSend(lpObj->Index,(BYTE*)&pMsg,pMsg.header.size);
		MsgSendV2(lpObj,(BYTE*)&pMsg,pMsg.header.size);
	}
}

void gObjPKDownCheckTime(LPOBJ lpObj,int TargetLevel) // OK
{
	if(lpObj->PKLevel == 3)
	{
		return;
	}

	lpObj->PKTime += TargetLevel;

	if(lpObj->PKLevel < 3)
	{
		if(lpObj->PKTime > gServerInfo.m_PKDownTime1)
		{
			if(lpObj->PKCount < 100)
			{
				lpObj->PKCount++;
			}

			lpObj->PKLevel++;

			lpObj->PKTime = 0;

			//GCPKLevelSend(lpObj->Index,lpObj->PKLevel);
		}
	}
	else
	{
		if(lpObj->PKTime > gServerInfo.m_PKDownTime2)
		{
			if(lpObj->PKCount > 0)
			{
				lpObj->PKCount--;
			}

			if(lpObj->PKCount == 0)
			{
				lpObj->PKLevel = 3;
			}
			else if(lpObj->PKCount == 1)
			{
				lpObj->PKLevel = 4;
			}
			else if(lpObj->PKCount == 2)
			{
				lpObj->PKLevel = 5;
			}

			lpObj->PKTime = 0;

			//GCPKLevelSend(lpObj->Index,lpObj->PKLevel);
		}
	}
}

//
void gObjSetPKLevel(LPOBJ lpObj, int PKLevel)
{
    if (lpObj == NULL)
    {
        return;
    }

    // PK 레벨 설정
    lpObj->PKLevel = PKLevel;

    // PK 레벨 변경 알림
  //  GCPKLevelSend(lpObj->Index, lpObj->PKLevel);
}

void gObjUserDie(LPOBJ lpObj, LPOBJ lpTarget) // OK
{
    // 캐릭터가 죽었을 때 정당방위 상태 초기화
    for (int n = 0; n < MAX_SELF_DEFENSE; n++)
    {
        lpObj->SelfDefense[n] = -1;
        lpObj->SelfDefenseTime[n] = 0;
    }

    // lpObj: 죽은 플레이어, lpTarget: 죽인 플레이어
    if (lpObj == NULL || lpTarget == NULL || lpObj->Type != OBJECT_USER || lpTarget->Type != OBJECT_USER)
    {
        return;
    }

    // 🔥 연승 시스템 및 채팅창 출력
    if (gServerInfo.m_DieUserSwitch == 1)
    {
        // 2. 서버 공지 (기존 코드 유지, 필요 시 제거 가능)
        if (gServerInfo.m_DieUserSwitch != 0)
        {
            gNotice.GCNoticeSendToAll(0, 0, 0, 0, 0, 0, gMessage.GetMessage(901), lpObj->Name, lpTarget->Name);
        }

        // 3. 연승 업데이트
        lpTarget->KillStreak++;    // 죽인 플레이어 연승 증가
        int prevStreak = lpObj->KillStreak; // 죽은 플레이어의 기존 연승 저장
        lpObj->KillStreak = 0;     // 죽은 플레이어 연승 초기화

        // 4. 3연승부터 10연승까지 메시지 출력
        if (lpTarget->KillStreak >= 3)
        {
            char streakMsg[256];
            if (lpTarget->KillStreak == 3)
            {
                wsprintf(streakMsg, "[트리플 킬] %s님이 학살을 시작합니다. (3연승)", lpTarget->Name);
            }
            else if (lpTarget->KillStreak == 4)
            {
                wsprintf(streakMsg, "[쿼드라 킬] %s님이 미쳐 날뛰고 있습니다. (4연승)", lpTarget->Name);
            }
            else if (lpTarget->KillStreak == 5)
            {
                wsprintf(streakMsg, "[펜타 킬] %s님을 도저히 막을 수 없습니다. (5연승)", lpTarget->Name);
            }
            else if (lpTarget->KillStreak == 6)
            {
                wsprintf(streakMsg, "[헥사 킬] %s님이 전장을 지배하고 있습니다. (6연승)", lpTarget->Name);
            }
            else if (lpTarget->KillStreak == 7)
            {
                wsprintf(streakMsg, "[헵타 킬] %s님이 죽음조차 피해갑니다. (7연승)", lpTarget->Name);
            }
            else if (lpTarget->KillStreak == 8)
            {
                wsprintf(streakMsg, "[옥타 킬] %s님께서 인간의 경지를 초월합니다. (8연승)", lpTarget->Name);
            }
            else if (lpTarget->KillStreak == 9)
            {
                wsprintf(streakMsg, "[노나 킬] %s님이 숨쉬는 모든 것을 멸하고 있습니다. (9연승)", lpTarget->Name);
            }
            else if (lpTarget->KillStreak == 10)
            {
                wsprintf(streakMsg, "[데카 킬] %s님이 전설에 도전합니다. (10연승)", lpTarget->Name);
            }
            else if (lpTarget->KillStreak > 10)
            {
                wsprintf(streakMsg, "[레전드 킬] %s (%d연승)", lpTarget->Name, lpTarget->KillStreak);
            }

            // 메시지 출력
            if (streakMsg[0] != '\0') // 메시지가 포맷팅된 경우에만 출력
            {
                PostMessagePK(lpTarget->Name, "%s", streakMsg); // 노란색 (~)으로 통일
            }
        }

        // 5. 죽은 플레이어가 5연승 이상이었을 경우, "5연승을 저지했습니다." 메시지 출력
        if (prevStreak >= 5)
        {
            char stopStreakMsg[256];
            wsprintf(stopStreakMsg, "[연승 컷!] %s님이 %s님의 %d연승을 저지했습니다!", lpTarget->Name, lpObj->Name, prevStreak);
            PostMessagePK(lpTarget->Name, "%s", stopStreakMsg); // 노란색 (~)으로 통일
        }

        // 6. 연승에 따른 PK 레벨 조정
        if (lpTarget->KillStreak == 10)
        {
            lpTarget->PKLevel = 1; // 10연승 달성 시 PK 레벨 1로 설정
           // gNotice.GCNoticeSendToAll(0, 0, 0, 0, 0, 0, "[%s]님이 10연승을 달성하여 PK 레벨이 1로 설정되었습니다.", lpTarget->Name);
        }
        else if (lpTarget->KillStreak == 20)
        {
            lpTarget->PKLevel = 2; // 20연승 달성 시 PK 레벨 2로 설정
           // gNotice.GCNoticeSendToAll(0, 0, 0, 0, 0, 0, "[%s]님이 20연승을 달성하여 PK 레벨이 2로 설정되었습니다.", lpTarget->Name);
        }
    }

    // 기존 코드 생략...






//	lpObj->hpbarvirwer = 0;
//	lpTarget->hpbarvirwer = 0;

#if USE_FAKE_ONLINE == TRUE
	if (lpTarget->Type == OBJECT_USER && lpObj->IsFakeOnline == true) //Neu bi nguoi kill
	{
		lpObj->IsFakeRegen = false;
		s_FakeOnline.PostChatMSG(lpObj);

	}
#endif

	gObjSetKillCount(lpObj->Index,0);

	if(CA_MAP_RANGE(lpObj->Map) != 0)
	{
		gCustomArena.UserDieProc(lpObj,lpTarget);
		return;
	}
	else if(DS_MAP_RANGE(lpObj->Map) != 0)
	{
		gDevilSquare.UserDieProc(lpObj,lpTarget);
		return;
	}
	else if(BC_MAP_RANGE(lpObj->Map) != 0)
	{
		gBloodCastle.UserDieProc(lpObj,lpTarget);
		return;
	}
	else if(CC_MAP_RANGE(lpObj->Map) != 0)
	{
		gChaosCastle.UserDieProc(lpObj,lpTarget);
		return;
	}
	else if(IT_MAP_RANGE(lpObj->Map) != 0)
	{
		gIllusionTemple.UserDieProc(lpObj,lpTarget);
		return;
	}
	else if(DG_MAP_RANGE(lpObj->Map) != 0)
	{
		gDoubleGoer.UserDieProc(lpObj,lpTarget);
		return;
	}
	else if(IG_MAP_RANGE(lpObj->Map) != 0)
	{
		gImperialGuardian.UserDieProc(lpObj,lpTarget);
		return;
	}

	if(gObjTargetGuildWarCheck(lpObj,lpTarget) != 0)
	{
		return;
	}

	if (lpObj->PvP == 1 && lpTarget->PvP == 1)
	{
		gEventPvP.EventPvPDead(lpObj->Index,lpTarget->Index);
		return;
	}

	if (lpObj->KillAll == 1 && lpTarget->KillAll == 1)
	{
		gEventKillAll.UserDieProc(lpObj,lpTarget);
		return;
	}

	if (gTvTEvent.CheckPlayerTarget(lpObj))
	{
		gTvTEvent.UserDieProc(lpObj,lpTarget);
	}

	if(lpObj->Type == OBJECT_USER && lpTarget->Type == OBJECT_USER)
	{

		lpTarget->Kills++;
		lpObj->Deads++;

		gCustomRankUser.GCReqRankLevelUser(lpObj->Index, lpObj->Index);
		gCustomRankUser.GCReqRankLevelUser(lpTarget->Index, lpTarget->Index);

		if (gServerInfo.m_CustomRankUserType == 0)
		{
			gCustomRankUser.CheckUpdate(lpTarget);
		}

		LogAdd(LOG_BLACK,"[%s][%s] Kill [%s][%s]",lpTarget->Account,lpTarget->Name,lpObj->Account,lpObj->Name);

	}

	//다이 이펙트
	if(lpObj->Type == OBJECT_USER && lpTarget->Type == OBJECT_USER)
	{
		
		GCEffectInfoSend(lpObj->Index,17);
		gObjBackSpring2(lpObj,lpTarget, 4); // 넉백
	}


	if (lpObj->Map == 0 || lpObj->Map == 1 || lpObj->Map == 2|| lpObj->Map == 3 || lpObj->Map == 4 || lpObj->Map == 6 || lpObj->Map == 7 || lpObj->Map == 8 || lpObj->Map == 10 ||
		lpObj->Map == 33 || lpObj->Map == 37 || lpObj->Map == 38 || lpObj->Map == 41 || lpObj->Map == 42 || lpObj->Map == 51 || lpObj->Map == 56 || lpObj->Map == 57 || lpObj->Map == 58 || lpObj->Map == 63 ||
		lpObj->Map == 80 || lpObj->Map == 81 || lpObj->Map == 82 || lpObj->Map == 91 || lpObj->Map == 95 ||lpObj->Map == 24 || lpObj->Map == 25 || lpObj->Map == 26 || lpObj->Map == 27 || lpObj->Map == 28 || lpObj->Map == 29 || lpObj->Map == 30 || lpObj->Map == 83 || lpObj->Map == 84 || lpObj->Map == 85 ||
		lpObj->Map == 86)
	{

	//킬 데스 메세지 시스템 채팅창
	//if(gServerInfo.m_DieUserSwitch == 1 && lpObj->Type == OBJECT_USER && lpTarget->Type == OBJECT_USER)
	{
	//	char fulltext[256]; 
	//	wsprintf(fulltext,"%s]에게 죽음! 맵:%s",lpTarget->Name, gMessage.GetMap(lpObj->Map));
	//	GDGlobalPostSend(gMapServerManager.GetMapServerGroup(),5,lpObj->Name,fulltext);
	//if(gServerInfo.m_DieUserSwitch != 0){gNotice.GCNoticeSendToAll(0,0,0,0,0,0,gMessage.GetMessage(901),lpObj->Name,lpTarget->Name);}
		//gNotice.GCNoticeSendToAll(0,0,0,0,0,0,gMessage.GetMessage(901),(lpObj->Name,lpTarget->Name));
	

	}
	//Die System Monster
	if(gServerInfo.m_DieMonsterSwitch == 1 && lpObj->Type == OBJECT_USER && lpTarget->Type == OBJECT_MONSTER)
	{
		MONSTER_INFO * MAttr = gMonsterManager.GetInfo(lpTarget->Class);
		char fulltext[256];
		wsprintf(fulltext,"%s]에게 죽음! 맵:%s",MAttr->Name, gMessage.GetMap(lpObj->Map));
		GDGlobalPostSend(gMapServerManager.GetMapServerGroup(),5,lpObj->Name,fulltext);
		//gNotice.GCNoticeSendToAll(0,0,0,0,0,0,gMessage.GetMessage(901),(lpObj->Map+1));
	}
}

	int itemdrop = 1;
	int count = 24;
	int number = 0;
	int dropresult = 0;

	//Drop item system
	// 수정된 코드 - 확률 체크 부분 제거
if(gServerInfo.m_PkItemDropSwitch == 1 && 
   gServerInfo.m_PkItemDropEnable[lpObj->AccountLevel] == 1)  // 확률 체크 제거
		if(lpObj->PKLevel >= 4)
		{
			count = 24;

			while(count-- != 0)
			{
				number = rand()%12;

				if(lpObj->Inventory[number].IsItem()==1)
				{
						PMSG_ITEM_DROP_RECV lpMsg;
						lpMsg.slot = number;
						lpMsg.x = (BYTE)lpObj->X;
						lpMsg.y = (BYTE)lpObj->Y;

						if(gItemManager.CGPkDrop(&lpMsg,lpObj->Index) == 1)
						{
							LogAdd(LOG_USER,"[%s][%s] PK Drop, ItemName: %s",lpObj->Account,lpObj->Name,gItemManager.GetItemName(lpObj->Inventory[number].m_Index));
							dropresult = 1;
							break;
						}
				}
			}
		

		int dropresult = 0;
    
    // 확률 체크 없이 무조건 드롭하도록 수정
    if(gServerInfo.m_PkItemDropSwitch == 1 && 
       gServerInfo.m_PkItemDropEnable[lpObj->AccountLevel] == 1)
    {
        if(lpObj->PKLevel >= 0)
        {
            count = 24;
            
            while(count-- != 0)
            {
                number = rand()%12;
                
                if(lpObj->Inventory[number].IsItem()==1)
                {
                    PMSG_ITEM_DROP_RECV lpMsg;
                    lpMsg.slot = number;
                    lpMsg.x = (BYTE)lpObj->X;
                    lpMsg.y = (BYTE)lpObj->Y;
                    
                    if(gItemManager.CGPkDrop(&lpMsg,lpObj->Index) == 1)
                    {
                        LogAdd(LOG_USER,"[%s][%s] PK Drop, ItemName: %s",
                            lpObj->Account,lpObj->Name,
                            gItemManager.GetItemName(lpObj->Inventory[number].m_Index));
                        dropresult = 1;
                        break;
                    }
                }
            }
            
            if(dropresult == 0)
            {
                // 인벤토리 아이템 드롭 시도
                count = INVENTORY_MAIN_SIZE;
                
                while(count-- != 0)
                {
                    number = rand()%INVENTORY_MAIN_SIZE + 12;
                    
                    if(lpObj->Inventory[number].IsItem()==1)
                    {
                        if(lpObj->Inventory[number].m_Index >= GET_ITEM(13,20) && 
                           (lpObj->Inventory[number].m_Level >= 1 && 
                            lpObj->Inventory[number].m_Level <= 2))
                        {
                            continue;
                        }
                        
                        PMSG_ITEM_DROP_RECV lpMsg;
                        lpMsg.slot = number;
                        lpMsg.x = (BYTE)lpObj->X;
                        lpMsg.y = (BYTE)lpObj->Y;
                        
                        if(gItemManager.CGPkDrop(&lpMsg,lpObj->Index) == 1)
                        {
                            dropresult = 1;
                            LogAdd(LOG_USER,"[%s][%s] Pk Drop, ItemName: %s",
                                lpObj->Account, lpObj->Name,
                                gItemManager.GetItemName(lpObj->Inventory[number].m_Index));
                            break;
                        }
                    }
                }
            }
        }
    }

	gDuel.UserDieProc(lpObj,lpTarget);

	gGensSystem.UserDieProc(lpObj,lpTarget);
}
		}
void gObjPlayerKiller(LPOBJ lpObj,LPOBJ lpTarget) // OK
{
	if(lpObj->Type != OBJECT_USER || lpTarget->Type != OBJECT_USER)
	{
		return;
	}


//	lpObj->hpbarvirwer = 0;
//	lpTarget->hpbarvirwer = 0;

	if(lpObj->Authority == 32 || lpTarget->Authority == 32)
	{
		return;
	}

	if(gDuel.CheckDuel(lpObj,lpTarget) != 0)
	{
		return;
	}

	if(lpObj->PvP != 0 && lpTarget->PvP != 0)
	{
		return;
	}

	if(lpObj->KillAll != 0 && lpTarget->KillAll != 0)
	{
		return;
	}

	if(gObjGetRelationShip(lpObj,lpTarget) == 2)
	{
		return;
	}

	if(gObjTargetGuildWarCheck(lpObj,lpTarget) != 0)
	{
		return;
	}

	if(gGensSystem.CheckGens(lpObj,lpTarget) != 0)
	{
		return;
	}

	if (gTvTEvent.CheckPlayerTarget(lpObj) && gTvTEvent.CheckPlayerTarget(lpTarget))
	{
		return;
	}

	#if(GAMESERVER_TYPE==1)

	if(lpObj->Map == MAP_CASTLE_SIEGE)
	{
		if(gCastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE && lpObj->CsJoinSide != 0)
		{
			return;
		}
		else if(lpObj->Y > 113)
		{
			if(gCastleSiege.CheckCastleOwnerUnionMember(lpObj->Index) != 0)
			{
				return;
			}
		}

		if(lpTarget->PKLevel >= 6)
		{
			return;
		}
	}

	#endif

	if(CA_MAP_RANGE(lpObj->Map) != 0 && CA_MAP_RANGE(lpTarget->Map) != 0)
	{
		return;
	}

	if(CC_MAP_RANGE(lpObj->Map) != 0 && CC_MAP_RANGE(lpTarget->Map) != 0)
	{
		return;
	}

	if(IT_MAP_RANGE(lpObj->Map) != 0 && IT_MAP_RANGE(lpTarget->Map) != 0)
	{
		return;
	}

	if(gMapManager.GetMapNonOutlaw(lpObj->Map) != 0)
	{
		return;
	}

	//정당방위
	for(int n=0;n < MAX_SELF_DEFENSE;n++)
	{
		if(OBJECT_RANGE(lpTarget->SelfDefense[n]) != 0)
		{
			if(lpObj->Index == lpTarget->SelfDefense[n])
			{
				return;
			}
		}
	}

	if(lpObj->PKLevel > 3)
	{
		if(lpTarget->PKLevel > 4)
		{
			return;
		}

		if(lpObj->PKCount < 100)
		{
			lpObj->PKCount++;
		}
	}
	else
	{
		if(lpTarget->PKLevel < 5)
		{
			lpObj->PKCount = 1;
		}
		else //if(lpObj->PKCount > -3)
		{
			lpObj->PKCount--;
		}
	}

	if(lpObj->PKCount <= -3)
	{
		lpObj->PKLevel = 1;
	}
	else if(lpObj->PKCount == 0)
	{
		lpObj->PKLevel = 3;
	}
	else if(lpObj->PKCount == 1)
	{
		lpObj->PKLevel = 4;
	}
	else if(lpObj->PKCount == 2)
	{
		lpObj->PKLevel = 5;
	}
	else if(lpObj->PKCount >= 3)
	{
		lpObj->PKLevel = 6;
	}
	/*
	lpObj->hpbarvirwer = 0;
	lpTarget->hpbarvirwer = 0;*/

	lpObj->PKTime = 0;
	
	//GCPKLevelSend(lpObj->Index,lpObj->PKLevel);

}

BOOL gObjMoveGate(int aIndex,int gate) // OK
{
	LPOBJ lpObj = &gObj[aIndex];
	 // 정당방위 상태인지 확인
    for (int n = 0; n < MAX_SELF_DEFENSE; n++)
    {
        if (lpObj->SelfDefense[n] >= 0) // 정당방위 상태인 경우
        {
            gNotice.GCNoticeSend(lpObj->Index, 1, 0, 0, 0, 0, 0, "정당방위 상태 중에는 맵 이동이 10초간 불가능합니다.");
            return 0; // 맵 이동 차단
        }
    }


	if(lpObj->Type == OBJECT_USER)
	{
		gDarkSpirit[aIndex].SetMode(DARK_SPIRIT_MODE_NORMAL,-1);
	}

	if(lpObj->SkillSummonPartyTime != 0)
	{
		lpObj->SkillSummonPartyTime = 0;
		gNotice.GCNoticeSend(lpObj->Index,1,0,0,0,0,0,gMessage.GetMessage(272));
	}

	if(BC_MAP_RANGE(lpObj->Map) != 0)
	{
		if(gBloodCastle.GetState(GET_BC_LEVEL(lpObj->Map)) == BC_STATE_START)
		{
			gBloodCastle.SearchUserDropEventItem(aIndex);
		}
		else
		{
			gBloodCastle.SearchUserDeleteEventItem(aIndex);
		}
	}

	if(IT_MAP_RANGE(lpObj->Map) != 0)
	{
		if(gIllusionTemple.GetState(GET_IT_LEVEL(lpObj->Map)) == IT_STATE_START)
		{
			gIllusionTemple.SearchUserDropEventItem(aIndex);
		}
		else
		{
			gIllusionTemple.SearchUserDeleteEventItem(aIndex);
		}
	}


	if(lpObj->RegenOk != 0 || gGate.IsGate(gate) == 0)
	{
		goto ERROR_JUMP;
	}

	int TargetGate,map,x,y,dir,level;

	if(gGate.GetGate(gate,&TargetGate,&map,&x,&y,&dir,&level) == 0)
	{
		goto ERROR_JUMP;
	}

	if(lpObj->PShopOpen != 0 && ((lpObj->Map == MAP_CASTLE_SIEGE && map == MAP_LORENCIA) || (lpObj->Map == MAP_LORENCIA && map == MAP_CASTLE_SIEGE)))
	{
		goto ERROR_JUMP;
	}

	if(lpObj->GensFamily == 0 && gMapManager.GetMapGensBattle(map) != 0)
	{
		gNotice.GCNoticeSend(lpObj->Index,1,0,0,0,0,0,gMessage.GetMessage(229));
		goto ERROR_JUMP;
	}

	if(BC_MAP_RANGE(map) != 0 || CC_MAP_RANGE(map) != 0 || DS_MAP_RANGE(map) != 0 || IT_MAP_RANGE(map) != 0 || DG_MAP_RANGE(map) != 0 || IG_MAP_RANGE(map) != 0)
	{
		gEffectManager.DelEffect(lpObj,EFFECT_ELF_BUFFER);
	}

	#if(GAMESERVER_TYPE==1)

	if(TargetGate == 97)
	{
		if(gCastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)
		{
			if(lpObj->CsJoinSide != 1 && gCastleSiege.GetCastleTowerAccessable() == 0)
			{
				goto ERROR_JUMP;
			}

			if(lpObj->CsJoinSide == 0)
			{
				goto ERROR_JUMP;
			}
		}
		else
		{
			if(gCastleSiege.CheckCastleOwnerMember(lpObj->Index) == 0 && gCastleSiege.CheckCastleOwnerUnionMember(lpObj->Index) == 0)
			{
				goto ERROR_JUMP;
			}
		}
	}

	#endif

	if(map == MAP_ATLANS && lpObj->Inventory[8].IsItem() != 0 && (lpObj->Inventory[8].m_Index == GET_ITEM(13,2) || lpObj->Inventory[8].m_Index == GET_ITEM(13,3))) // Uniria,Dinorant
	{
		gNotice.GCNoticeSend(aIndex,1,0,0,0,0,0,gMessage.GetMessage(274));
		goto ERROR_JUMP;
	}

	if((map == MAP_ICARUS || map == MAP_KANTURU3) && lpObj->Inventory[7].IsItem() == 0 && lpObj->Inventory[8].m_Index != GET_ITEM(13,3) && lpObj->Inventory[8].m_Index != GET_ITEM(13,37))
	{
		gNotice.GCNoticeSend(aIndex,1,0,0,0,0,0,gMessage.GetMessage(275));
		goto ERROR_JUMP;
	}

	if(KALIMA_MAP_RANGE(lpObj->Map) == 0 && lpObj->Map != map)
	{
		gKalima.DeleteKalimaGate(aIndex);
	}

	if(KALIMA_MAP_RANGE(lpObj->Map) != 0 && lpObj->Map != map)
	{
		gKalima.DeleteKalimaGate(aIndex);
	}

	if(map == MAP_RAKLION2)
	{
		if(gRaklion.GetRaklionState() == RAKLION_STATE_CLOSE_DOOR || gRaklion.GetRaklionState() == RAKLION_STATE_ALL_USER_DIE || gRaklion.GetRaklionState() == RAKLION_STATE_NOTIFY4 || gRaklion.GetRaklionState() == RAKLION_STATE_END)
		{
			gNotice.GCNoticeSend(aIndex,1,0,0,0,0,0,gMessage.GetMessage(325));
			goto ERROR_JUMP;
		}
		else
		{
			if(gate == 290)
			{
				gRaklionBattleUserMng.AddUserData(aIndex);
			}
		}
	}

	if(map == MAP_RAKLION1)
	{
		if(gate == 292)
		{
			if(gRaklion.GetRaklionState() == RAKLION_STATE_CLOSE_DOOR || gRaklion.GetRaklionState() == RAKLION_STATE_ALL_USER_DIE || gRaklion.GetRaklionState() == RAKLION_STATE_NOTIFY4 || gRaklion.GetRaklionState() == RAKLION_STATE_END)
			{
				goto ERROR_JUMP;
			}
			else
			{
				gRaklionBattleUserMng.DelUserData(aIndex);
			}
		}
		else
		{
			gRaklionUtil.NotifyRaklionState(aIndex,gRaklion.GetRaklionState(),gRaklion.GetRaklionDetailState());
		}
	}

	if(lpObj->Interface.use != 0 || lpObj->DieRegen != 0)
	{
		lpObj->State = OBJECT_DELCMD;
		lpObj->RegenOk = 1;
		gMove.GCTeleportSend(aIndex,gate,lpObj->Map,(BYTE)lpObj->X,(BYTE)lpObj->Y,lpObj->Dir);
		return 0;
	}

	if (lpObj->IsFakeOnline == false) {
		lpObj->State = OBJECT_DELCMD;
	}

	if(lpObj->Map != map)
	{
		short NextServerCode = gMapServerManager.CheckMapServerMove(aIndex,map,lpObj->LastServerCode);

		if(NextServerCode != gServerInfo.m_ServerCode)
		{
			if(NextServerCode == -1)
			{
				return 0;
			}

			GJMapServerMoveSend(aIndex,NextServerCode,map,x,y);
			return 1;
		}
	}

	lpObj->X = x;
	lpObj->Y = y;
	lpObj->TX = x;
	lpObj->TY = y;
	lpObj->Map = map;
	lpObj->Dir = dir;
	lpObj->PathCount = 0;
	lpObj->Teleport = 0;
	lpObj->ViewState = 0;
	lpObj->MiniMapState = 0;
	lpObj->MiniMapValue = -1;

	gObjViewportListProtocolDestroy(lpObj);

	gMove.GCTeleportSend(aIndex, gate, lpObj->Map, (BYTE)lpObj->X, (BYTE)lpObj->Y, lpObj->Dir);

	gObjViewportListProtocolCreate(lpObj);

	gObjClearViewport(lpObj);

	gHelper.DisableHelper(lpObj);

	gObjectManager.CharacterUpdateMapEffect(lpObj);

	if (lpObj->IsFakeOnline == false) {
		lpObj->RegenMapNumber = lpObj->Map;
		lpObj->RegenMapX = (BYTE)lpObj->X;
		lpObj->RegenMapY = (BYTE)lpObj->Y;
		lpObj->RegenOk = 1;
	}

	if(lpObj->Type == OBJECT_USER)
	{
		lpObj->LastTeleportTime = 10;
	}

	return 1;

	ERROR_JUMP:

	gObjClearViewport(lpObj);

	gMove.GCTeleportSend(aIndex,gate,lpObj->Map,(BYTE)lpObj->X,(BYTE)lpObj->Y,lpObj->Dir);

	gObjViewportListProtocolCreate(lpObj);

	gObjectManager.CharacterUpdateMapEffect(lpObj);
	if (lpObj->IsFakeOnline == false) {
		lpObj->RegenMapNumber = lpObj->Map;
		lpObj->RegenMapX = (BYTE)lpObj->X;
		lpObj->RegenMapY = (BYTE)lpObj->Y;
		lpObj->RegenOk = 1;
	}

	return 0;

}

void gObjTeleport(int aIndex,int map,int x,int y) // OK
{
	if(OBJECT_RANGE(aIndex) == 0)
	{
		return;
	}

	if(MAP_RANGE(map) == 0)
	{
		return;
	}

	LPOBJ lpObj = &gObj[aIndex];


	//정당방위
	//if((GetTickCount()-lpObj->MySelfDefenseTime) < 30000)
	//{
		//gNotice.GCNoticeSend(aIndex,1,0,0,0,0,0,gMessage.GetMessage(265));
		//return;
//	}
	///

	lpObj->State = OBJECT_DELCMD;

	if(lpObj->Map != map)
	{
		short NextServerCode = gMapServerManager.CheckMapServerMove(aIndex,map,lpObj->LastServerCode);

		if(NextServerCode != gServerInfo.m_ServerCode)
		{
			if(NextServerCode == -1)
			{
				return;
			}

			GJMapServerMoveSend(aIndex,NextServerCode,map,x,y);
			return;
		}
	}

	if(lpObj->Interface.use != 0 && lpObj->Interface.type == INTERFACE_TRADE)
	{
		gTrade.CGTradeCancelButtonRecv(aIndex);
	}

	if(lpObj->Interface.use != 0 && lpObj->Interface.type == INTERFACE_WAREHOUSE)
	{
		gWarehouse.CGWarehouseClose(aIndex);
	}

	lpObj->X = x;
	lpObj->Y = y;
	lpObj->TX = x;
	lpObj->TY = y;
	lpObj->Map = map;
	lpObj->PathCount = 0;
	lpObj->Teleport = 0;
	lpObj->ViewState = 0;
	lpObj->MiniMapState = 0;
	lpObj->MiniMapValue = -1;

	gHelper.DisableHelper(lpObj);

	gObjClearViewport(lpObj);

	gMove.GCTeleportSend(aIndex,1,lpObj->Map,(BYTE)lpObj->X,(BYTE)lpObj->Y,lpObj->Dir);

	gObjViewportListProtocolCreate(lpObj);

	gObjectManager.CharacterUpdateMapEffect(lpObj);

	if (lpObj->IsFakeOnline == false) {
		lpObj->RegenMapNumber = lpObj->Map;
		lpObj->RegenMapX = (BYTE)lpObj->X;
		lpObj->RegenMapY = (BYTE)lpObj->Y;
		lpObj->RegenOk = 1;
	}

	lpObj->RegenMapNumber = lpObj->Map;
	lpObj->RegenMapX = (BYTE)lpObj->X;
	lpObj->RegenMapY = (BYTE)lpObj->Y;
	lpObj->RegenOk = 1;
}

void gObjSummonAlly(LPOBJ lpObj,int map,int x,int y) // OK
{
	lpObj->SkillSummonPartyTime = 0;
	lpObj->SkillSummonPartyMap = 0;
	lpObj->SkillSummonPartyX = 0;
	lpObj->SkillSummonPartyY = 0;

	if(lpObj->Map == map)
	{
		gSkillManager.GCSkillAttackSend(lpObj,SKILL_TELEPORT,lpObj->Index,1);
		gObjTeleportMagicUse(lpObj->Index,x,y);
		return;
	}

	lpObj->X = x;
	lpObj->Y = y;
	lpObj->TX = x;
	lpObj->TY = y;
	lpObj->Map = map;
	lpObj->PathCount = 0;
	lpObj->Teleport = 0;
	lpObj->ViewState = 0;
	lpObj->MiniMapState = 0;
	lpObj->MiniMapValue = -1;

	gHelper.DisableHelper(lpObj);

	gObjClearViewport(lpObj);

	gMove.GCTeleportSend(lpObj->Index,-1,lpObj->Map,(BYTE)lpObj->X,(BYTE)lpObj->Y,lpObj->Dir);

	gObjViewportListProtocolCreate(lpObj);

	gObjectManager.CharacterUpdateMapEffect(lpObj);

	if (lpObj->IsFakeOnline == false) {
		lpObj->RegenMapNumber = lpObj->Map;
		lpObj->RegenMapX = (BYTE)lpObj->X;
		lpObj->RegenMapY = (BYTE)lpObj->Y;
		lpObj->RegenOk = 1;
	}

}

void gObjSkillUseProc(LPOBJ lpObj) // OK
{
	CMonsterSkillElementOption::CheckSkillElementOptionProc(lpObj);

	if(lpObj->Type == OBJECT_USER && lpObj->SkillSummonPartyTime > 0)
	{
		if((--lpObj->SkillSummonPartyTime) == 0)
		{
			if(gMoveSummon.CheckMoveSummon(lpObj,lpObj->SkillSummonPartyMap,lpObj->SkillSummonPartyX,lpObj->SkillSummonPartyY) == 0)
			{
				gNotice.GCNoticeSend(lpObj->Index,1,0,0,0,0,0,gMessage.GetMessage(272));
			}
			else
			{
				gObjSummonAlly(lpObj,lpObj->SkillSummonPartyMap,lpObj->SkillSummonPartyX,lpObj->SkillSummonPartyY);
			}
		}
		else
		{
			gNotice.GCNoticeSend(lpObj->Index,1,0,0,0,0,0,gMessage.GetMessage(273),lpObj->SkillSummonPartyTime);
		}
	}

	if(lpObj->Type == OBJECT_USER && lpObj->DrinkSpeed > 0)
	{
		if(GetTickCount() >= lpObj->DrinkLastTime)
		{
			lpObj->DrinkSpeed = 0;
			lpObj->DrinkLastTime = 0;

			gObjectManager.CharacterCalcAttribute(lpObj->Index);
		}
	}
}

void gObjUserKill(int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->CloseCount <= 0)
	{
		lpObj->CloseType = 0;
		lpObj->CloseCount = 1;
	}
}

bool gObjInventorySearchSerialNumber(LPOBJ lpObj,DWORD serial) // OK
{
	int count = 0;

	for(int n=0;n < INVENTORY_SIZE;n++)
	{
		if(lpObj->Inventory[n].m_Serial != 0 && lpObj->Inventory[n].m_Serial == serial && (count++) > 0)
		{
			gNotice.GCNoticeSend(lpObj->Index,1,0,0,0,0,0,gMessage.GetMessage(482));
			gObjUserKill(lpObj->Index);
			return 0;
		}
	}

	return 1;
}

bool gObjWarehouseSearchSerialNumber(LPOBJ lpObj,DWORD serial) // OK
{
	int count = 0;

	for(int n=0;n < WAREHOUSE_SIZE;n++)
	{
		if(lpObj->Warehouse[n].m_Serial != 0 && lpObj->Warehouse[n].m_Serial == serial && (count++) > 0)
		{
			gNotice.GCNoticeSend(lpObj->Index,1,0,0,0,0,0,gMessage.GetMessage(482));
			gObjUserKill(lpObj->Index);
			return 0;
		}
	}

	return 1;
}

void gObjAddMsgSend(LPOBJ lpObj,int MsgCode,int SendUser,int SubCode) // OK
{
	for(int n=0;n < MAX_MONSTER_SEND_MSG;n++)
	{
		if(gSMMsg[lpObj->Index][n].MsgCode == -1)
		{
			if(gSMMsg.ObjectStruct[lpObj->Index] == gSMMsg.CommonStruct){gSMMsg.ObjectStruct[lpObj->Index] = new MESSAGE_STATE_MACHINE_COMMON;}

			if(gSMMsg.ObjectStruct[lpObj->Index]->ObjectStruct[n] == gSMMsg.ObjectStruct[lpObj->Index]->CommonStruct){gSMMsg.ObjectStruct[lpObj->Index]->ObjectStruct[n] = new MESSAGE_STATE_MACHINE;}

			gSMMsg[lpObj->Index][n].MsgCode = MsgCode;
			gSMMsg[lpObj->Index][n].MsgTime = GetTickCount();
			gSMMsg[lpObj->Index][n].SendUser = SendUser;
			gSMMsg[lpObj->Index][n].SubCode = SubCode;
			return;
		}
	}
}

void gObjAddMsgSendDelay(LPOBJ lpObj,int MsgCode,int SendUser,int MsgTimeDelay,int SubCode) // OK
{
	for(int n=0;n < MAX_MONSTER_SEND_MSG;n++)
	{
		if(gSMMsg[lpObj->Index][n].MsgCode == -1)
		{
			if(gSMMsg.ObjectStruct[lpObj->Index] == gSMMsg.CommonStruct){gSMMsg.ObjectStruct[lpObj->Index] = new MESSAGE_STATE_MACHINE_COMMON;}

			if(gSMMsg.ObjectStruct[lpObj->Index]->ObjectStruct[n] == gSMMsg.ObjectStruct[lpObj->Index]->CommonStruct){gSMMsg.ObjectStruct[lpObj->Index]->ObjectStruct[n] = new MESSAGE_STATE_MACHINE;}

			gSMMsg[lpObj->Index][n].MsgCode = MsgCode;
			gSMMsg[lpObj->Index][n].MsgTime = GetTickCount()+MsgTimeDelay;
			gSMMsg[lpObj->Index][n].SendUser = SendUser;
			gSMMsg[lpObj->Index][n].SubCode = SubCode;
			return;
		}
	}
}

void gObjAddAttackProcMsgSendDelay(LPOBJ lpObj,int MsgCode,int SendUser,int MsgTimeDelay,int SubCode,int SubCode2) // OK
{
	for(int n=0;n < MAX_MONSTER_SEND_ATTACK_MSG;n++)
	{
		if(gSMAttackProcMsg[lpObj->Index][n].MsgCode == -1)
		{
			if(gSMAttackProcMsg.ObjectStruct[lpObj->Index] == gSMAttackProcMsg.CommonStruct){gSMAttackProcMsg.ObjectStruct[lpObj->Index] = new MESSAGE_STATE_ATTACK_MACHINE_COMMON;}

			if(gSMAttackProcMsg.ObjectStruct[lpObj->Index]->ObjectStruct[n] == gSMAttackProcMsg.ObjectStruct[lpObj->Index]->CommonStruct){gSMAttackProcMsg.ObjectStruct[lpObj->Index]->ObjectStruct[n] = new MESSAGE_STATE_ATTACK_MACHINE;}

			gSMAttackProcMsg[lpObj->Index][n].MsgCode = MsgCode;
			gSMAttackProcMsg[lpObj->Index][n].MsgTime = GetTickCount()+MsgTimeDelay;
			gSMAttackProcMsg[lpObj->Index][n].SendUser = SendUser;
			gSMAttackProcMsg[lpObj->Index][n].SubCode = SubCode;
			gSMAttackProcMsg[lpObj->Index][n].SubCode2 = SubCode2;
			return;
		}
	}
}

//**************************************************************************//
// RAW FUNCTIONS ***********************************************************//
//**************************************************************************//

void gObjSecondProc()
{
	int n;
	LPOBJ lpObj; 

	for(n = 0; n < MAX_OBJECT;n++)
	{
		lpObj = &gObj[n];

		if(lpObj->Connected > OBJECT_LOGGED)
		{
			if(lpObj->MapServerMoveQuit == 1)
			{
				if(GetTickCount() - lpObj->MapServerMoveQuitTickCount > 30000)
				{
					gObjDel(lpObj->Index);
					continue;
				}
			}

			gObjSkillUseProc(lpObj);

			if(lpObj->Type == OBJECT_MONSTER)
			{
				#if(GAMESERVER_TYPE==1)
				if(lpObj->Class == 283)
				{
					gGuardianStatue.GuardianStatueAct(lpObj->Index);
					continue;
				}
				
				if(lpObj->Class == 278)
				{
					gLifeStone.LifeStoneAct(lpObj->Index);
					continue;
				}

				if(lpObj->Class == 288)
				{
					gCannonTower.CannonTowerAct(lpObj->Index);
					continue;
				}

				gCrywolf.CrywolfMonsterAct(lpObj->Index);
				#endif
				if(lpObj->MonsterDeleteTime != 0 && GetTickCount() >= lpObj->MonsterDeleteTime)
				{
					gObjDel(lpObj->Index);
					continue;
				}
			}
			if(lpObj->Type == OBJECT_NPC)
			{
				#if(GAMESERVER_TYPE==1)
				if( (lpObj->Class < 204)?FALSE:(lpObj->Class > 209)?FALSE:TRUE)
				{
					gCrywolf.CrywolfNpcAct(lpObj->Index);
				}
				
				if(lpObj->Class == 216)
				{
					gCastleSiegeCrown.CastleSiegeCrownAct(lpObj->Index);
					continue;
				}
				
				if(lpObj->Class == 217 || lpObj->Class == 218)
				{
					gCastleSiegeCrownSwitch.CastleSiegeCrownSwitchAct(lpObj->Index);
					continue;
				}
				#endif
				if(lpObj->Class == 221 || lpObj->Class == 222)
				{
					gCastleSiegeWeapon.CastleSiegeWeaponAct(lpObj->Index);
				}
			}

			if(lpObj->Type == OBJECT_USER)
			{
				gCustomAttack.OnAttackSecondProc(lpObj);

				gCustomStore.OnPShopSecondProc(lpObj);

				g_OfflineMode.OnAttackSecondProcHelper(lpObj);

				gObjCheckMapTile(lpObj,3);

				GCNewHealthBarSend(lpObj);

				s_FakeOnline.FakeAttackProc(lpObj); //Attack, Di Chuyen, Move
				

				if(lpObj->ChatLimitTime > 0 && gServerInfo.m_CommandBanChatSwitch != 0)
				{
					lpObj->ChatLimitTimeSec++;

					if(lpObj->ChatLimitTimeSec > 60)
					{
						lpObj->ChatLimitTimeSec = 0;
						lpObj->ChatLimitTime--;

						if(lpObj->ChatLimitTime < 1)
						{
							lpObj->ChatLimitTime = 0;
							gNotice.GCNoticeSend(lpObj->Index,1,0,0,0,0,0,gMessage.GetMessage(483));
						}
					}
				}

				//룰렛
				if (lpObj->LuckySpinTime > 0 && GetTickCount() - lpObj->LuckySpinTime > 5000)
				{
					lpObj->LuckySpinTime = 0;
					gLuckySpin.MakeItem(lpObj->Index);
					GC_LuckySpinUpdateData pMsg;
					pMsg.header.set(0xFB, 0x25, sizeof(pMsg));
					pMsg.RollNumber = gLuckySpin.number;
					DataSend(lpObj->Index, (BYTE*)&pMsg, pMsg.header.size);
				}
				//

				#if(GAMESERVER_TYPE==1)

				if(lpObj->Map == MAP_CASTLE_SIEGE && gCastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)
				{
					if((lpObj->X < 150 || lpObj->X > 200) || (lpObj->Y < 175 || lpObj->Y > 225))
					{
						if(lpObj->AccumulatedCrownAccessTime > 0)
						{
							lpObj->AccumulatedCrownAccessTime = (((lpObj->AccumulatedCrownAccessTime-gServerInfo.m_CastleSiegeDecayAccumulatedTimeValue)<0)?0:(lpObj->AccumulatedCrownAccessTime-gServerInfo.m_CastleSiegeDecayAccumulatedTimeValue));
						}
					}
				}

				#endif

				gObjectManager.CharacterAutoRecuperation(lpObj);
	
				if(lpObj->Type == OBJECT_USER && lpObj->LastTeleportTime > 0)
				{
					lpObj->LastTeleportTime--;
				}
	
				gObjDelayLifeCheck(n);

				//내구력
				gObjectManager.CharacterItemDurationDown(lpObj);

				if(lpObj->PartyNumber >= 0)
				{
					gParty.GCPartyLifeSend(lpObj->PartyNumber);

					#if(GAMESERVER_UPDATE>=802)

					gMiniMap.GCMiniMapPartyInfoSend(lpObj->Index);

					#endif
				}

				#if(GAMESERVER_UPDATE>=801)

				gGuildMatching.GDGuildMatchingInsertSaveSend(lpObj->Index);

				gPartyMatching.GDPartyMatchingInsertSaveSend(lpObj->Index);

				#endif

				int BattleGround = 1;
				int m_BattleTimer = gCheckBattleGroundTimer();
	
				if((lpObj->Authority & 2) == 2)
				{
					BattleGround = 0;
					GCTimeViewSend(lpObj->Index,m_BattleTimer);
				}
	
				//경기장 배틀사커 제거
				if(lpObj->Map == MAP_ARENA && BattleGround == 1)
				{
					BattleGround = 1;
	
					if(lpObj->Guild != 0)
					{
						if(lpObj->Guild->WarState != 0)
						{
							int CheckBattleGround = gCheckBattleGround(lpObj);
	
							if(CheckBattleGround != lpObj->Guild->BattleGroundIndex)
							{
								if(lpObj->Guild->WarType == 1)
								{
									BattleGround = 0;
								}
								else
								{
									BattleGround = 0;
								}
							}
							else
							{
								BattleGround = 0;
							}
						}
					}
					else
					{
						BattleGround = 1;
					}
	
					if(BattleGround != 0)
					{
						int CheckBattleGround = gCheckBattleGround(lpObj);
		
						if(CheckBattleGround >= 0)
						{
							gObjMoveGate(lpObj->Index,17);
						}
					}
				}



			}
		}

		if(lpObj->Connected >= OBJECT_LOGGED && lpObj->Type == OBJECT_USER &&	lpObj->CloseCount > 0)
		{

			if(lpObj->CloseCount == 1)
			{
				if(lpObj->CloseType == 1)
				{
					if(gObjectManager.CharacterGameClose(lpObj->Index) == 1)
					{
						GCCloseClientSend(lpObj->Index,1);
					}
				}
				else if(lpObj->CloseType == 3)
				{
					if(gObjectManager.CharacterGameClose(lpObj->Index) == 1)
					{
						GCCloseClientSend(lpObj->Index,1);
					}
				}
				else if(lpObj->CloseType == 4)
				{
					if(gObjectManager.CharacterGameClose(lpObj->Index) == 1)
					{
						GCCloseClientSend(lpObj->Index,1);
					}
				}
				else if(lpObj->CloseType == 0)
				{
					GCCloseClientSend(lpObj->Index,0);
				}
				else if(lpObj->CloseType == 2)
				{
					GCCloseClientSend(lpObj->Index,2);
				}
			}
			else
			{
				if(lpObj->CloseType == 3)
				{
					gNotice.GCNoticeSend(lpObj->Index,1,0,0,0,0,0,gMessage.GetMessage(859),(lpObj->CloseCount-1));
				}
				else if(lpObj->CloseType == 4)
				{
					gNotice.GCNoticeSend(lpObj->Index,1,0,0,0,0,0,gMessage.GetMessage(858),(lpObj->CloseCount-1));
				}
				else
				{
					gNotice.GCNoticeSend(lpObj->Index,1,0,0,0,0,0,gMessage.GetMessage(484),(lpObj->CloseCount-1));
				}
			}

			lpObj->CloseCount--;
		}

		if(lpObj->Connected > OBJECT_LOGGED &&	lpObj->Type == OBJECT_USER)
		{

			if(gServerInfo.m_InfoSaveSend == 1)
			{
				if(GetTickCount() - lpObj->AutoSaveTime > 600000)
				{
					GDCharacterInfoSaveSend(lpObj->Index);
					lpObj->AutoSaveTime = GetTickCount();
				}


#if USE_FAKE_ONLINE == TRUE

			if(lpObj->CheckSumTime > 0 && GetTickCount() - lpObj->CheckSumTime > 5000 && lpObj->IsFakeOnline != true)
			{
				LogAdd(LOG_BLACK,"[%s][%s] CheckSumTime Error",lpObj->Account, lpObj->Name);
				GCCloseClientSend(n,0);
			}

#endif

			gObjPKDownCheckTime(lpObj,1);
			gObjInterfaceCheckTime(lpObj);
			gObjTimeCheckSelfDefense(lpObj);
		}

		if(lpObj->Connected == OBJECT_CONNECTED ||	lpObj->Connected == OBJECT_LOGGED || lpObj->Connected == OBJECT_ONLINE)
		{
			if(lpObj->Type == OBJECT_USER)
			{
				if(lpObj->Connected >= OBJECT_LOGGED)
				{

				if (lpObj->m_OfflineMode == 1)
				{
					lpObj->ConnectTickCount = GetTickCount();
					continue;
				}

				if (lpObj->IsFakeOnline == 1)
						{
							lpObj->ConnectTickCount = GetTickCount();
							continue;
					}

					if(GetTickCount() - lpObj->ConnectTickCount > 60000)//60000
					{
						CloseClient(n);
						//LogAdd(LOG_BLACK,"Game response error causes conclusion [%d][%s][%s][%s]",lpObj->Index,lpObj->Account,lpObj->Name,lpObj->IpAddr);
					}
				}
				else
				{
					if(GetTickCount() - lpObj->ConnectTickCount > 30000)//60000
					{
						CloseClient(n);
						//LogAdd(LOG_BLACK,"Response error after connection causes conclusion [%d][%s][%s][%s]",lpObj->Index,lpObj->Account,lpObj->Name,lpObj->IpAddr);
						// 
					}
				}
			}
		}
	}
		}
		}


void gObjDelayLifeCheck(int aIndex)
{
	LPOBJ lpObj = &gObj[aIndex];

	if(lpObj->CheckLifeTime > 0)
	{
		lpObj->CheckLifeTime--;

		if(lpObj->CheckLifeTime <= 0)
		{
			lpObj->CheckLifeTime = 0;

			if(lpObj->Life < 0)
			{
				lpObj->Life = 0;
			}

			if(lpObj->AttackObj != 0)
			{
				gObjectManager.CharacterLifeCheck(lpObj->AttackObj,lpObj,0,1,0,0,0,0);
			}
		}
	}
}

BOOL gObjBackSpring(LPOBJ lpObj,LPOBJ lpTarget) // OK
{
	LPOBJ lpTargetObj = lpTarget;
	int tdir;

	if (MAP_RANGE(lpObj->Map) == FALSE )
	{
		return FALSE;
	}

	if ( lpObj->Type == OBJECT_USER )
	{
		if (lpObj->Teleport != 0)
		{
			return FALSE;
		}
	}

#if(GAMESERVER_TYPE==1)
	if( lpObj->Type == OBJECT_USER)
	{
		if((lpObj->Authority &0x02) == 2)
		{
			return FALSE;
		}
	}
#endif

	if ( lpObj->Class >= 131 && lpObj->Class <= 134 )
	{
		return FALSE;
	}

#if(GAMESERVER_TYPE==1)
	if( lpObj->Class == 277 ||
		lpObj->Class == 283 ||
		lpObj->Class == 288 ||
		lpObj->Class == 278 ||
		lpObj->Class == 215 ||
		lpObj->Class == 216 ||
		lpObj->Class == 217 ||
		lpObj->Class == 218 ||
		lpObj->Class == 219 )
	{
		return FALSE;
	}
	
	if(gCastleSiege.GetCrownUserIndex() == lpObj->Index)
	{
		if(lpObj->Inventory[8].m_Index == GET_ITEM(13,4))
		{
			return FALSE;
		}
	}
	
	if(gCrywolf.GetCrywolfState() == 4 || gCrywolf.GetCrywolfState() == 3)
	{
		if(lpObj->Type == OBJECT_USER)
		{
			for(int i=205;i<=209;i++)
			{
				int iAltarIndex = gCrywolfAltar.GetAltarUserIndex(i);
				
				if(iAltarIndex != -1)
				{
					if(iAltarIndex == lpObj->Index)
					{
						return FALSE;
					}
				}
			}
		}
	}

	if(lpObj->Class >= 204 && lpObj->Class <= 209)
	{
		return FALSE;
	}
	if(lpObj->Class == 348)
	{
		return FALSE;
	}
#endif

	if(lpObj->Class == 275)
	{
		return FALSE;
	}

	if(lpObj->Class == 459 ||
		lpObj->Class == 460 ||
		lpObj->Class == 461 ||
		lpObj->Class == 462)
	{
		return FALSE;
	}

	if(lpObj->Class == 524 || lpObj->Class == 525 || lpObj->Class == 527 || lpObj->Class == 528)
	{
		return FALSE;
	}
	
	if ( (GetLargeRand()%3) == 0 )
	{
		if ( lpTargetObj->Dir < 4 )
		{
			tdir = lpTargetObj->Dir + 4;
		}
		else
		{
			tdir = lpTargetObj->Dir - 4;
		}

		tdir *= 2;
	}
	else
	{
		tdir = lpTargetObj->Dir * 2;
	}

	int x;
	int y;
	BYTE attr;

	x = lpObj->X;
	y = lpObj->Y;
	x += RoadPathTable[tdir];
	y += RoadPathTable[1+tdir];
	attr = gMap[lpObj->Map].GetAttr(x, y);

	if ( (attr&1)==1 ||
		(attr&2)==2 || 
		(attr&4)== 4 || 
		(attr&8)== 8 
		||(attr&16)== 16 
		)
	{
		return FALSE;
	}

	PMSG_POSITION_RECV pMsg;

	pMsg.header.set(PROTOCOL_CODE3,sizeof(pMsg));

	pMsg.x = x;
	
	pMsg.y = y;

	lpObj->Rest = 0;
	gMap[lpObj->Map].DelStandAttr(lpObj->OldX, lpObj->OldY);
	gMap[lpObj->Map].SetStandAttr(x, y);
	lpObj->OldX = x;
	lpObj->OldY = y;
	CGPositionRecv(&pMsg,lpObj->Index);

	if ( lpObj->Type == OBJECT_USER )
	{
		lpObj->PathCount = 0;
	}

	return TRUE;
}

BOOL BackSpringCheck(int & x, int & y, int & dir, BYTE map)
{
	BYTE attr;
	int tx = x;
	int ty = y;
	int tdir = dir/2;

	tx = tx + RoadPathTable[dir];
	ty = ty + RoadPathTable[1+dir];

	attr = gMap[map].GetAttr(tx, ty);

	if	(  (attr&1)==1 || 
		(attr&4)== 4 || 
		(attr&8)== 8
		||(attr&16)== 16 
		)
	{
		tdir += 4;
		
		if ( tdir > 7 )
		{
			tdir -= 8;
		}
		
		dir = tdir * 2;
		return FALSE;
	}

	x = tx;
	y = ty;

	return TRUE;
}

BOOL gObjBackSpring2(LPOBJ lpObj, LPOBJ lpTargetObj, int count)
{
	int tdir;

	if ( MAP_RANGE(lpObj->Map) == FALSE )
	{
		return FALSE;
	}

	if ( lpObj->Type == OBJECT_USER )
	{
		if (lpObj->Teleport != 0)
		{
			return FALSE;
		}
	}

#if(GAMESERVER_TYPE==1)
	if( lpObj->Type == OBJECT_USER)
	{
		if((lpObj->Authority &0x02) == 2)
		{
			return FALSE;
		}
	}
#endif

	if ( lpObj->Class == 287 || lpObj->Class == 286 )
	{
		return FALSE;
	}

#if(GAMESERVER_TYPE==1)
	if ( lpObj->Class == 278 )
	{
		return FALSE;
	}
#endif

	if ( lpObj->Class >= 131 && lpObj->Class <= 134 )
	{
		return FALSE;
	}

#if(GAMESERVER_TYPE==1)
	if( lpObj->Class == 277 ||
		lpObj->Class == 283 ||
		lpObj->Class == 288 ||
		lpObj->Class == 278 ||
		lpObj->Class == 215 ||
		lpObj->Class == 216 ||
		lpObj->Class == 217 ||
		lpObj->Class == 218 ||
		lpObj->Class == 219 )
	{
		return FALSE;
	}
	
	if(gCastleSiege.GetCrownUserIndex() == lpObj->Index)
	{
		if(lpObj->Inventory[8].m_Index == GET_ITEM(13,4))
		{
			return FALSE;
		}
	}
	
	if(gCrywolf.GetCrywolfState() == 4 || gCrywolf.GetCrywolfState() == 3)
	{
		if(lpObj->Type == OBJECT_USER)
		{
			for(int i=205;i<=209;i++)
			{
				int iAltarIndex = gCrywolfAltar.GetAltarUserIndex(i);
				
				if(iAltarIndex != -1)
				{
					if(iAltarIndex == lpObj->Index)
					{
						return FALSE;
					}
				}
			}
		}
	}
	
	if(lpObj->Class >= 204 && lpObj->Class <= 209)
	{
		return FALSE;
	}
	if(lpObj->Class == 348)
	{
		return FALSE;
	}
#endif
	
	if(lpObj->Class == 275)
	{
		return FALSE;
	}

	if(lpObj->Class == 459 ||
		lpObj->Class == 460 ||
		lpObj->Class == 461 ||
		lpObj->Class == 462)
	{
		return FALSE;
	}

	if(lpObj->Class == 524 || lpObj->Class == 525 || lpObj->Class == 527 || lpObj->Class == 528)
	{
		return FALSE;
	}


#if(GAMESERVER_TYPE==1)
	tdir = GetPathPacketDirPos(lpObj->X - lpTargetObj->X, lpObj->Y - lpTargetObj->Y) * 2;
#else
	tdir = GetPathPacketDirPos(lpObj->X - lpTargetObj->X, lpObj->Y - lpTargetObj->Y) * 2;
#endif

	int x = lpObj->X;
	int y = lpObj->Y;

	for ( int n=0;n<count;n++)
	{
		if ( n >= 2 )
		{
			if ( lpObj->Class == 4 || lpObj->Class == 3 || lpObj->Class == 1 )
			{
				BackSpringCheck(x, y, tdir, lpObj->Map);
			}
		}
		else
		{
			BackSpringCheck(x, y, tdir, lpObj->Map);
		}
	}

	PMSG_POSITION_RECV pMsg;

	pMsg.header.set(PROTOCOL_CODE3,sizeof(pMsg));

	pMsg.x = x;
	
	pMsg.y = y;

	lpObj->Rest = 0;
	gMap[lpObj->Map].DelStandAttr(lpObj->OldX, lpObj->OldY);
	gMap[lpObj->Map].SetStandAttr(x, y);
	lpObj->OldX = x;
	lpObj->OldY = y;
	CGPositionRecv(&pMsg,lpObj->Index);

	return TRUE;
}

bool gObjIsSelfDefense(LPOBJ lpObj, int aTargetIndex)
{
    if (!OBJECT_RANGE(aTargetIndex))
    {
        return false;
    }

    for (int n=0; n<MAX_SELF_DEFENSE; n++)
    {
        if (lpObj->SelfDefense[n] >= 0)
        {
            if (lpObj->SelfDefense[n] == aTargetIndex)
            {
                return true;
            }
        }
    }

    return false;
}

void gObjCheckSelfDefense(LPOBJ lpObj, int aTargetIndex)
{
    int n;

    if(!OBJECT_RANGE(aTargetIndex))
    {
        return;
    }
	 if(lpObj->Guild != 0 && gObj[aTargetIndex].Guild != 0)
    {
        if(lpObj->Guild->Number == gObj[aTargetIndex].Guild->Number)
        {
            return; // 같은 길드원이면 정당방위 적용하지 않음
        }
    }
	// 공격자와 피해자 모두 정당방위 상태로 설정
    for (int n = 0; n < MAX_SELF_DEFENSE; n++)
    {
        if (lpObj->SelfDefense[n] == -1) // 빈 슬롯 찾기
        {
            lpObj->SelfDefense[n] = aTargetIndex;
            lpObj->SelfDefenseTime[n] = GetTickCount() + 10000; // 10초 동안 유지
            break;
        }
    }
	for (int n = 0; n < MAX_SELF_DEFENSE; n++)
    {
        if (gObj[aTargetIndex].SelfDefense[n] == -1) // 빈 슬롯 찾기
        {
            gObj[aTargetIndex].SelfDefense[n] = lpObj->Index;
            gObj[aTargetIndex].SelfDefenseTime[n] = GetTickCount() + 10000; // 10초 동안 유지
            break;
        }
    }

    // 정당방위 상태가 활성화되었음을 알림
    //gNotice.GCNoticeSend(lpObj->Index, 1, 0, 0, 0, 0, 0, "정당방위 상태가 활성화되었습니다. 10초 동안 맵 이동이 불가능합니다.");
 
    if(gObj[aTargetIndex].PKLevel > 4)
    {
        return;
    }

    int iPartyNumber = lpObj->PartyNumber;

    for(n = 0; n < MAX_SELF_DEFENSE; n++)
    {
        if(gObj[aTargetIndex].SelfDefense[n] >= 0)
        {
            if(gObj[aTargetIndex].SelfDefense[n] == lpObj->Index)
            {
                return;
            }

            if(iPartyNumber >= 0)
            {
                if(gObj[gObj[aTargetIndex].SelfDefense[n]].PartyNumber == iPartyNumber)
                {
                    return;
                }
            }
        }
    }

    int blank = -1;

    for(n = 0; n < MAX_SELF_DEFENSE; n++)
    {
        if(lpObj->SelfDefense[n] >= 0)
        {
            if(lpObj->SelfDefense[n] == aTargetIndex)
            {
                lpObj->SelfDefenseTime[n] = GetTickCount() + gServerInfo.m_SelfDefenseTime;
                return;
            }
        }
        else
        {
            blank = n;
        }
    }

    if(blank < 0)
    {
        return;
    }

    lpObj->SelfDefense[blank] = aTargetIndex;
}

void gObjTimeCheckSelfDefense(LPOBJ lpObj)
{
    for (int n = 0; n < MAX_SELF_DEFENSE; n++)
    {
        if (lpObj->SelfDefense[n] >= 0) // 정당방위 상태인 경우
        {
            if (GetTickCount() > lpObj->SelfDefenseTime[n]) // 시간이 지났는지 확인
            {
                lpObj->SelfDefense[n] = -1; // 정당방위 상태 해제
                //gNotice.GCNoticeSend(lpObj->Index, 1, 0, 0, 0, 0, 0, "정당방위 상태가 해제되었습니다.");
            }
        }
    }
}

BOOL gObjTargetGuildWarCheck(LPOBJ lpObj, LPOBJ lpTargetObj)
{
	if (lpObj->Type != OBJECT_USER)
	{
		return false;
	}

	if (lpTargetObj->Type != OBJECT_USER)
	{
		return false;
	}

	if (lpObj->GuildNumber < 1 || lpTargetObj->GuildNumber < 1)
	{
		return false;
	}

	if (lpObj->Guild->WarState != 1 || lpTargetObj->Guild->WarState != 1)
	{
		return false;
	}

	if (strcmp(lpObj->Guild->TargetGuildName, lpTargetObj->Guild->Name))
	{
		return false;
	}
	return true;
}

void gObjGuildWarEndSend(LPOBJ lpObj, BYTE Result1, BYTE Result2)
{
	if(lpObj == 0)
	{
		return;
	}

	if(lpObj->Guild == 0)
	{
		return;
	}

	if(lpObj->Guild->WarState != 1)
	{
		return;
	}

	if(lpObj->Guild->TargetGuildNode == 0)
	{
		return;
	}

	if(Result1 == 1)
	{
		gObjGuildWarItemGive(lpObj->Guild,lpObj->Guild->TargetGuildNode);
	}
	else if(Result1 == 3)
	{
		gObjGuildWarItemGive(lpObj->Guild->TargetGuildNode,lpObj->Guild);
	}
	else if(Result1 == 1)
	{
		gObjGuildWarItemGive(lpObj->Guild->TargetGuildNode,lpObj->Guild);
	}

	for(int n = 0; n < MAX_GUILD_USER;n++)
	{
		if(lpObj->Guild->Use[n] && lpObj->Guild->Index[n] >= 0)
		{
			gObj[lpObj->Guild->Index[n]].IsInBattleGround = 0;
			gGuild.GCGuildWarEndSend(lpObj->Guild->Index[n],Result1,lpObj->Guild->TargetGuildNode->Name);
		}
	}

	for(int n = 0; n < MAX_GUILD_USER;n++)
	{
		if(lpObj->Guild->TargetGuildNode->Use[n] && lpObj->Guild->TargetGuildNode->Index[n] >= 0)
		{
			gObj[lpObj->Guild->TargetGuildNode->Index[n]].IsInBattleGround = 0;
			gGuild.GCGuildWarEndSend(lpObj->Guild->TargetGuildNode->Index[n],Result2,lpObj->Guild->Name);
		}
	}
}

void gObjGuildWarEndSend(GUILD_INFO_STRUCT * lpGuild1, GUILD_INFO_STRUCT * lpGuild2, BYTE Result1, BYTE Result2)
{
	if(lpGuild1 == 0 || lpGuild2 == 0)
	{
		return;
	}

	if(lpGuild1->WarState != 1 || lpGuild2->WarState != 1)
	{
		return;
	}

	for(int n = 0; n < MAX_GUILD_USER;n++)
	{
		if(lpGuild1->Use[n] && lpGuild1->Index[n] >= 0)
		{
			gObj[lpGuild1->Index[n]].IsInBattleGround = 0;
			gGuild.GCGuildWarEndSend(lpGuild1->Index[n],Result1,lpGuild2->Name);
		}
	}

	for(int n = 0; n < MAX_GUILD_USER;n++)
	{
		if(lpGuild2->Use[n] && lpGuild2->Index[n] >= 0)
		{
			gObj[lpGuild2->Index[n]].IsInBattleGround = 0;
			gGuild.GCGuildWarEndSend(lpGuild2->Index[n],Result2,lpGuild1->Name);
		}
	}
}

void gObjGuildWarEnd(GUILD_INFO_STRUCT * lpGuild, GUILD_INFO_STRUCT * lpTargetGuild)
{
	if(lpGuild == 0 || lpTargetGuild == 0)
	{
		return;
	}

	lpGuild->WarDeclareState = 0;
	lpGuild->WarState = 0;

	if(lpTargetGuild != 0)
	{
		lpTargetGuild->WarDeclareState = 0;
		lpTargetGuild->WarState = 0;

		if(lpGuild->TargetGuildNode != 0)
		{
			GUILD_INFO_STRUCT * lpTguild = lpGuild->TargetGuildNode;

			lpGuild->TargetGuildNode = 0;
			lpTguild->TargetGuildNode = 0;
		}
	}
	else
	{
		lpGuild->TargetGuildNode = 0;
	}
}

BOOL gObjGuildWarProc(GUILD_INFO_STRUCT * lpGuild1, GUILD_INFO_STRUCT * lpGuild2, int score)
{
	int totalscore;
	int n;
	int maxscore;
	char szTemp[0x100];

	if(lpGuild1 == 0 || lpGuild2 == 0)
	{
		return false;
	}

	totalscore = 1;
	maxscore = 20;

	lpGuild1->PlayScore += score;

	wsprintf(szTemp,"%s ( %d ) VS %s ( %d )",lpGuild1->Name,lpGuild1->PlayScore,lpGuild2->Name,lpGuild2->PlayScore);
	LogAdd(LOG_BLACK,szTemp);

	if(lpGuild1->WarType == 1)
	{
		SetBattleTeamScore(lpGuild1->BattleGroundIndex,lpGuild1->BattleTeamCode,lpGuild1->PlayScore);
		maxscore = 100;
	}
	else
	{
		maxscore = 20;
	}

	if(lpGuild1->PlayScore >= maxscore)
	{
		if(lpGuild1->PlayScore > maxscore && lpGuild2->PlayScore == 0)
		{
			totalscore = 3;
		}
		else if(lpGuild1->PlayScore > maxscore && lpGuild2->PlayScore <= 10)
		{
			totalscore = 2;
		}

		lpGuild1->TotalScore += totalscore;

		DGGuildScoreUpdate(lpGuild1->Name,lpGuild1->TotalScore);

		DGGuildScoreUpdate(lpGuild2->Name,lpGuild2->TotalScore);

		return true;
	}

	for(n = 0; n < MAX_GUILD_USER; n++)
	{
		if(lpGuild1->Use[n] && lpGuild1->Index[n] >= 0)
		{
			gGuild.GCGuildWarScoreSend(lpGuild1->Index[n]);
		}
	}

	for(n = 0; n < MAX_GUILD_USER; n++)
	{
		if(lpGuild2->Use[n] && lpGuild2->Index[n] >= 0)
		{
			gGuild.GCGuildWarScoreSend(lpGuild2->Index[n]);
		}
	}
	return false;
}

BOOL gObjGuildWarCheck(LPOBJ lpObj, LPOBJ lpTargetObj)
{
	int score = 1;

	if(gObjTargetGuildWarCheck(lpObj,lpTargetObj)==0)
	{
		return false;
	}

	if(strcmp(lpTargetObj->Name,lpTargetObj->Guild->Names[0])==0)
	{
		score = 2;
	}

	GUILD_INFO_STRUCT * lpGuild = lpObj->Guild;
	GUILD_INFO_STRUCT * lpTargetGuild = lpTargetObj->Guild;

	if(gObjGuildWarProc(lpGuild,lpTargetGuild,score)==1)
	{
		if(lpGuild->WarType == 1)
		{
			gObjGuildWarEndSend(lpGuild,lpTargetGuild,1,0);
			gBattleGroundEnable(lpGuild->BattleGroundIndex,0);
			gObjGuildWarEnd(lpGuild,lpTargetGuild);
		}
		else
		{
			gObjGuildWarEndSend(lpObj,1,0);
			gObjAddMsgSendDelay(lpObj,4,lpObj->Index,2000,0);
		}
	}
	return true;
}

BOOL gObjGuildWarMasterClose(LPOBJ lpObj)
{
	if(lpObj->GuildNumber < 1)
	{
		return false;
	}

	if(strcmp(lpObj->Guild->Names[0],lpObj->Name))
	{
		return false;
	}

	gObjGuildWarEndSend(lpObj,3,2);

	if(lpObj->Guild->WarType == 1 && lpObj->Guild->BattleGroundIndex < 1)
	{
		gBattleGroundEnable(lpObj->Guild->BattleGroundIndex,0);
	}
	gObjGuildWarEnd(lpObj->Guild,lpObj->Guild->TargetGuildNode);
	return true;
}

int gObjGuildWarItemGive(GUILD_INFO_STRUCT * lpWinGuild, GUILD_INFO_STRUCT * lpLoseGuild)
{
	return true;
	int n;
	int r_userindex[MAX_GUILD_USER];
	int r_usercount;

	for(n = 0; n < MAX_GUILD_USER; n++)
	{
		if(lpLoseGuild->Use[n] > 0)
		{
			r_userindex[r_usercount] = lpLoseGuild->Index[n];
			r_usercount++;
		}
	}

	if(r_usercount < 1)
	{
		return false;
	}

	int lose_user = r_userindex[GetLargeRand()%r_usercount];

	if(lose_user < 0)
	{
		return false;
	}

	if(gObj[lose_user].Connected < OBJECT_ONLINE)
	{
		return false;
	}

	r_usercount = 0;

	for(n = 0; n < MAX_GUILD_USER;n++)
	{
		if(lpWinGuild->Use[n] > 0)
		{
			r_userindex[r_usercount] = lpWinGuild->Index[n];
			r_usercount++;
		}
	}

	if(r_usercount < 1)
	{
		return false;
	}

	int win_user = r_userindex[GetLargeRand()%r_usercount];

	if(win_user < 0)
	{
		return false;
	}

	if(gObj[win_user].Connected < OBJECT_ONLINE)
	{
		return false;
	}

	LPOBJ lpObj = &gObj[lose_user];

	int count = 24;

	int number;

	while(count--)
	{
		number = GetLargeRand()%12;

		if(lpObj->Inventory[number].IsItem()==1)
		{
			if(gItemManager.InventoryInsertItem(win_user,lpObj->Inventory[number]) != 0xFF)
			{
				return true;
			}
			break;
		}
	}

	count = 64;

	while(count--)
	{
		number = GetLargeRand()%64+12;

		if(lpObj->Inventory[number].IsItem()==1)
		{
			if(gItemManager.InventoryInsertItem(win_user,lpObj->Inventory[number]) != 0xFF)
			{
				return true;
			}
			break;
		}
	}
	return true;
}

void gObjSetPosition(int aIndex, int x, int y)
{
	LPOBJ lpObj = &gObj[aIndex];

	PMSG_POSITION_RECV pMove;

	pMove.header.set(PROTOCOL_CODE3, sizeof(pMove));

	pMove.x = x;
	pMove.y = y;

	lpObj->Rest = 0;

	gMap[lpObj->Map].DelStandAttr(lpObj->OldX, lpObj->OldY);
	gMap[lpObj->Map].SetStandAttr(x, y);

	lpObj->OldX = x;
	lpObj->OldY = y;

	CGPositionRecv(&pMove, lpObj->Index);
}
void gObjAuthorityCodeSet(LPOBJ lpObj)
{
	if ( (lpObj->Authority&1) == 1 )
	{
		return;
	}

	if ( (lpObj->Authority&2)== 2 )
	{
		lpObj->AuthorityCode = -1;
		return;
	}

	if ( (lpObj->Authority&4) == 4 )
	{
		return;
	}

	if ( (lpObj->Authority&8) == 8 )
	{
		lpObj->AuthorityCode |= 1;
		lpObj->AuthorityCode |= 2;
		lpObj->AuthorityCode |= 4;
		lpObj->AuthorityCode |= 8;
		lpObj->AuthorityCode |= 16;
		lpObj->AuthorityCode |= 32;

		return;
	}

	if ( (lpObj->Authority&16) == 16 )
	{
		return;
	}

	if ( (lpObj->Authority&32) == 32 )
	{
		lpObj->AuthorityCode |= 1;
		lpObj->AuthorityCode |= 2;
		lpObj->AuthorityCode |= 4;
		lpObj->AuthorityCode |= 8;
		lpObj->AuthorityCode |= 16;
		lpObj->AuthorityCode |= 32;

		return;
	}

}

int gObjGetGuildUnionNumber(LPOBJ lpObj)
{
	int iUnion=0;

	if ( lpObj->Guild != NULL )
	{
		iUnion = (lpObj->Guild->GuildUnion == 0)? lpObj->Guild->Number : lpObj->Guild->GuildUnion;
	}

	return iUnion;
}

void gObjGetGuildUnionName(LPOBJ lpObj, char* szUnionName, int iUnionNameLen)
{
	szUnionName[0] = 0;
	
	if ( lpObj->Guild == NULL )
	{
		return;
	}

	if ( lpObj->Guild->GuildUnion == 0 )
	{
		return;
	}

	CUnionInfo * pUnionInfo = gUnionManager.SearchUnion(lpObj->Guild->GuildUnion);

	if ( pUnionInfo != NULL )
	{
		memcpy(szUnionName, pUnionInfo->m_szMasterGuild, iUnionNameLen);
	}
}

BOOL gObjCheckRival(LPOBJ lpObj, LPOBJ lpTargetObj)
{
	if (lpTargetObj->Type != OBJECT_USER)
	{
		return false;
	}

	if (lpObj->Type != OBJECT_USER)
	{
		return false;
	}

	if (lpTargetObj->Guild == 0 || lpObj->Guild == 0)
	{
		return false;
	}

	if (lpTargetObj->Guild->GuildRival == 0 || lpObj->Guild->GuildRival == 0)
	{
		return false;
	}

	int iUnion = !lpObj->Guild->GuildUnion ? lpObj->Guild->Number : lpObj->Guild->GuildUnion;

	if (gUnionManager.GetGuildRelationShip(iUnion, lpTargetObj->Guild->Number) == 2)
	{
		return true;
	}
	return false;
}

int gObjGetRelationShip(LPOBJ lpObj, LPOBJ lpTargetObj)
{
	if (lpObj == NULL || lpTargetObj == NULL)
	{
		return false;
	}

	if (lpObj->Guild == NULL || lpTargetObj->Guild == NULL)
	{
		return 0;
	}
	int iUnion = (!lpObj->Guild->GuildUnion) ? lpObj->Guild->Number : lpObj->Guild->GuildUnion;
	int iUnion2 = (!lpTargetObj->Guild->GuildUnion) ? lpTargetObj->Guild->Number : lpTargetObj->Guild->GuildUnion;
	return gUnionManager.GetGuildRelationShip(iUnion, iUnion2);

}

void gObjNotifyUpdateUnionV1(LPOBJ lpObj)
{
	if(lpObj == 0)
	{
		return;
	}

	char cBUFFER_V1[6000];
	int iVp1Count = 0;

	memset(cBUFFER_V1,0x00,sizeof(cBUFFER_V1));

	PMSG_UNION_VIEWPORT_NOTIFY_COUNT * lpMsg = (PMSG_UNION_VIEWPORT_NOTIFY_COUNT *)&cBUFFER_V1;
	PMSG_UNION_VIEWPORT_NOTIFY * lpMsgBody = (PMSG_UNION_VIEWPORT_NOTIFY * )&cBUFFER_V1[sizeof(PMSG_UNION_VIEWPORT_NOTIFY_COUNT)];

	for(int n = 0; n < MAX_VIEWPORT; n++)
	{
		if(!OBJECT_RANGE(lpObj->VpPlayer[n].index))
		{
			continue;
		}

		if(lpObj->VpPlayer[n].state == 2 && lpObj->VpPlayer[n].type == OBJECT_USER)
		{
			LPOBJ lpTargetObj = &gObj[lpObj->VpPlayer[n].index];

			if(lpTargetObj == 0)
			{
				continue;
			}

			if(lpTargetObj->Guild == 0)
			{
				continue;
			}

			gObjGetGuildUnionName(lpTargetObj,lpMsgBody[iVp1Count].szUnionName,sizeof(lpMsgBody[iVp1Count].szUnionName));

			lpMsgBody[iVp1Count].btGuildRelationShip = gObjGetRelationShip(lpObj,lpTargetObj);
			lpMsgBody[iVp1Count].btNumberL = SET_NUMBERLB(WORD(lpTargetObj->Index));
			lpMsgBody[iVp1Count].btNumberH = SET_NUMBERHB(WORD(lpTargetObj->Index));
			lpMsgBody[iVp1Count].iGuildNumber = lpTargetObj->Guild->Number;
			iVp1Count++;
		}
	}

	if(iVp1Count > 0 && iVp1Count <= MAX_VIEWPORT)
	{
		lpMsg->btCount = iVp1Count;

		lpMsg->h.set(0x67,iVp1Count * sizeof(PMSG_UNION_VIEWPORT_NOTIFY) + sizeof(PMSG_UNION_VIEWPORT_NOTIFY_COUNT));

		DataSend(lpObj->Index,(LPBYTE)lpMsg,((lpMsg->h.size[1] & 0xFF) & 0xFF | ((lpMsg->h.size[0] & 0xFF) & 0xFF) << 8) & 0xFFFF);
	}
	else
	{
		if(iVp1Count != 0)
		{
			LogAdd(LOG_BLACK,"[Union ViewPort] ERROR : iVp1Count is OUT of BOUND: %d",iVp1Count);
		}
	}
}

void gObjNotifyUpdateUnionV2(LPOBJ lpObj)
{
	if (lpObj == 0)
	{
		return;
	}

	if (lpObj->Guild == 0)
	{
		return;
	}

	char cBUFFER_V2[100] = { 0 };

	PMSG_UNION_VIEWPORT_NOTIFY_COUNT* lpMsg2 = (PMSG_UNION_VIEWPORT_NOTIFY_COUNT*)&cBUFFER_V2;
	PMSG_UNION_VIEWPORT_NOTIFY* lpMsgBody2 = (PMSG_UNION_VIEWPORT_NOTIFY*)&cBUFFER_V2[sizeof(PMSG_UNION_VIEWPORT_NOTIFY_COUNT)];

	gObjGetGuildUnionName(lpObj, lpMsgBody2->szUnionName, sizeof(lpMsgBody2->szUnionName));
	lpMsgBody2->btNumberL = SET_NUMBERLB(WORD(lpObj->Index));
	lpMsgBody2->btNumberH = SET_NUMBERHB(WORD(lpObj->Index));

	lpMsgBody2->iGuildNumber = lpObj->Guild->Number;
	lpMsgBody2->btGuildRelationShip = 0;
	lpMsg2->btCount = 1;

	lpMsg2->h.set(0x67, sizeof(lpMsg2) + sizeof(lpMsgBody2[0]) + 1);

	DataSend(lpObj->Index, (LPBYTE)lpMsg2, ((lpMsg2->h.size[1] & 0xFF) & 0xFF | ((lpMsg2->h.size[0] & 0xFF) & 0xFF) << 8) & 0xFFFF);

	for (int n = 0; n < MAX_VIEWPORT; n++)
	{
		if (lpObj->VpPlayer2[n].type == OBJECT_USER && lpObj->VpPlayer2[n].state != 0)
		{
			LPOBJ lpTargetObj = &gObj[lpObj->VpPlayer2[n].index];

			if (lpTargetObj->Guild != 0)
			{
				lpMsgBody2->btGuildRelationShip = gObjGetRelationShip(lpTargetObj, lpObj);
			}

			if (lpMsgBody2->btGuildRelationShip != 1)
			{
				DataSend(lpObj->VpPlayer2[n].index, (LPBYTE)lpMsg2, ((lpMsg2->h.size[1] & 0xFF) & 0xFF | ((lpMsg2->h.size[0] & 0xFF) & 0xFF) << 8) & 0xFFFF);
			}
		}
	}
}

void gObjUnionUpdateProc(int iIndex)
{
	if ( gObjIsConnected(iIndex) == FALSE )
	{
		return;
	}

	LPOBJ lpObj = &gObj[iIndex];

	if ( lpObj->Type != OBJECT_USER )
	{
		return;
	}

	if ( lpObj->RegenOk > 0 )
	{
		return;
	}

	if ( lpObj->CloseCount > -1 )
	{
		return;
	}

	if ( lpObj->Guild == NULL )
	{
		return;
	}

	if ( lpObj->Guild->CheckTimeStamp(lpObj->GuildUnionTimeStamp) != FALSE )
	{
		return;
	}

	lpObj->GuildUnionTimeStamp = lpObj->Guild->GetTimeStamp();
	gObjNotifyUpdateUnionV1(lpObj);
	gObjNotifyUpdateUnionV2(lpObj);
}


//마초
bool gObjRebuildMasterSkillTree(LPOBJ lpObj)
{
	if(gMasterSkillTree.CheckMasterLevel(lpObj) == 0)
	{
		return 0;
	}

	if (gServerInfo.m_ReMasterSkillRudd > lpObj->Coin2)
	{
		gNotice.GCNoticeSend(lpObj->Index,1,0,0,0,0,0,"[☎] %d 알씨가 부족 합니다", gServerInfo.m_ReMasterSkillRudd);
		return FALSE;
	}

	if (gServerInfo.m_ReMasterSkillGP > lpObj->Coin3)
	{
		gNotice.GCNoticeSend(lpObj->Index,1,0,0,0,0,0,"[☎] %d 고포가 부족 합니다", gServerInfo.m_ReMasterSkillGP);
		return FALSE;
	}


	for(int n=0;n < MAX_SKILL_LIST;n++)
	{
		if(lpObj->Skill[n].IsMasterSkill() != 0)
		{
			if(lpObj->Skill[n].m_skill >= 300)
			{
				lpObj->Skill[n].Clear();
				continue;
			}

			lpObj->Skill[n].m_level = 0;

			lpObj->Skill[n].m_skill = lpObj->Skill[n].m_skill;

			lpObj->Skill[n].m_index = lpObj->Skill[n].m_skill;

			lpObj->Skill[n].m_DamageMin = gSkillManager.GetSkillDamage(lpObj->Skill[n].m_skill);

			lpObj->Skill[n].m_DamageMax = lpObj->Skill[n].m_DamageMin+(lpObj->Skill[n].m_DamageMin/2);
		}
	}

	#if(GAMESERVER_UPDATE>=602)

	for(int n=0;n < MAX_MASTER_SKILL_LIST;n++)
	{
		lpObj->MasterSkill[n].Clear();
	}

	#endif

	//lpObj->MasterPoint = (lpObj->MasterLevel * gServerInfo.m_MasterSkillTreePoint);

	lpObj->MasterPoint = (lpObj->MasterLevel * gServerInfo.m_MasterSkillTreePoint) + lpObj->BuystatMs;


	#if(GAMESERVER_UPDATE>=602)

	gMasterSkillTree.GCMasterSkillListSend(lpObj->Index);

	#endif

	gSkillManager.GCSkillListSend(lpObj,0);

	gObjectManager.CharacterCalcAttribute(lpObj->Index);

	gMasterSkillTree.GCMasterInfoSend(lpObj);


	gCashShop.GDCashShopSubPointSaveSend(lpObj->Index,0,0,gServerInfo.m_ReMasterSkillRudd,gServerInfo.m_ReMasterSkillGP);
	gCashShop.CGCashShopPointRecv(lpObj->Index);


	return 1;
}

void gObjUseDrink(LPOBJ lpObj,int level)
{
	switch ( level )
	{
	case 2: // Remedy of Love
		GCItemUseSpecialTimeSend(lpObj->Index, 1, 90);
		break;
	case 1: //ALE+1
		GCItemUseSpecialTimeSend(lpObj->Index, 0, 180);
		lpObj->DrinkSpeed = 20;
		lpObj->DrinkLastTime = GetTickCount()+(180*1000);
		gObjectManager.CharacterCalcAttribute(lpObj->Index);
		break;
	default: //ALE+0
		GCItemUseSpecialTimeSend(lpObj->Index, 0, 80);
		lpObj->DrinkSpeed = 20;
		lpObj->DrinkLastTime = GetTickCount()+(80*1000);
		gObjectManager.CharacterCalcAttribute(lpObj->Index);
		break;
  }
}

void gObjCustomLogPlusChaosMix(LPOBJ lpObj,int type,int index)
{
	#if(GAMESERVER_UPDATE>=501)

	if(type != 5)
	{
		return;
	}

	#else

	if(type != 3)
	{
		return;
	}

	#endif

	if(gServerInfo.m_AnnounceChaosMix != 0)
	{
		ITEM_INFO ItemInfo;

		if(gItemManager.GetInfo(index,&ItemInfo) != 0)
		{
			char buff[256];

			wsprintf(buff,gServerInfo.m_AnnounceChaosMixText,lpObj->Name,ItemInfo.Name);

			if(gServerInfo.m_AnnounceChaosMix == 1)
			{
				gNotice.GCNoticeSendToAll(0,0,0,0,0,0,buff);
			}
			else
			{
				GDGlobalNoticeSend(gMapServerManager.GetMapServerGroup(),0,0,0,0,0,0,buff);
			}
		}
	}
}

bool gObjCheckAutoParty(LPOBJ lpObj,LPOBJ lpTarget)
{
	if((lpTarget->Option & 4) == 0)
	{
		return 0;
	}

	if(lpTarget->AutoPartyPassword[0] != 0 && strcmp(lpObj->AutoPartyPassword,lpTarget->AutoPartyPassword) != 0)
	{
		return 0;
	}

	return 1;
}

#if USE_FAKE_ONLINE == TRUE
LPOBJ gObjFindByAcc(char* Account) // OK
{
	for (int n = OBJECT_START_USER; n < MAX_OBJECT; n++)
	{
		if (gObjIsConnectedGP(n) != 0 && strcmp(gObj[n].Account, Account) == 0)
		{
			return &gObj[n];
		}
	}

	return 0;
}
#endif



//////////////////////////////////////////////

//////////////////(SERVER) ATTACK.CPP
// Attack.cpp: implementation of the CAttack class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Attack.h"
#include "BattleSoccerManager.h"
#include "CastleSiege.h"
#include "ChaosCastle.h"
#include "Crywolf.h"
#include "CustomArena.h"
#include "CustomWing.h"
#include "DarkSpirit.h"
#include "Duel.h"
#include "EventKillAll.h"
#include "EventRunAndCatch.h"
#include "EventTvT.h"
#include "EffectManager.h"
#include "GensSystem.h"
#include "Guild.h"
#include "IllusionTemple.h"
#include "Kalima.h"
#include "Map.h"
#include "MapManager.h"
#include "MasterSkillTree.h"
#include "Message.h"
#include "Monster.h"
#include "MuunSystem.h"
#include "Notice.h"
#include "ObjectManager.h"
#include "Party.h"
#include "PentagramSystem.h"
#include "ReiDoMU.h"
#include "ServerInfo.h"
#include "SkillManager.h"
#include "Util.h"
#include "RageSystem.h"
#include "SkillDamage.h"

CAttack gAttack;
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAttack::CAttack() // OK
{

}

CAttack::~CAttack() // OK
{

}

bool CAttack::Attack(LPOBJ lpObj,LPOBJ lpTarget,CSkill* lpSkill,bool send,BYTE flag,int damage,int count,bool combo) // OK
{
	#pragma region ATTACK_CHECK

	if(lpObj->Index == lpTarget->Index)
	{
		return 0;
	}

	if(lpObj->Type == OBJECT_USER && gObjIsConnectedGP(lpObj->Index) == 0)
	{
		return 0;
	}

	if(lpTarget->Type == OBJECT_USER && gObjIsConnectedGP(lpTarget->Index) == 0)
	{
		return 0;
	}

	if(lpObj->Map != lpTarget->Map || lpObj->Teleport == 2)
	{
		return 0;
	}

	if (lpObj->Type == OBJECT_USER && lpTarget->Type == OBJECT_USER )
	{
		lpTarget->showhpbar = 1;
		//lpObj->showhpbar = 1;
		lpTarget->timeshow = GetTickCount();//time hp bar disappear
		lpTarget->sendhpbartarget = lpObj->Index;

		//lpTarget->sendhpbartarget[VpPlayer2] = lpObj->Index;
		

		if(lpObj->DisablePvp == 1 || lpTarget->DisablePvp == 1)
		{

			if (KALIMA_MAP_RANGE(lpObj->Map) != 0 || CA_MAP_RANGE(lpObj->Map) != 0 || DS_MAP_RANGE(lpObj->Map) != 0 || BC_MAP_RANGE(lpObj->Map) != 0 || CC_MAP_RANGE(lpObj->Map) != 0 || IT_MAP_RANGE(lpObj->Map) != 0 || DA_MAP_RANGE(lpObj->Map) != 0 || DG_MAP_RANGE(lpObj->Map) != 0 || IG_MAP_RANGE(lpObj->Map) != 0 || lpObj->Map == MAP_CASTLE_SIEGE || lpObj->Map == MAP_LAND_OF_TRIALS || (gReiDoMU.m_Active == 1 && lpObj->Map == gServerInfo.m_ReiDoMUMap))
			{
				if (lpObj->DisablePvp == 1)
				{
					gNotice.GCNoticeSend(lpObj->Index,1,0,0,0,0,0,gMessage.GetMessage(772));
					lpObj->DisablePvp = 0;
				}
				if (lpTarget->DisablePvp == 1)
				{
					gNotice.GCNoticeSend(lpTarget->Index,1,0,0,0,0,0,gMessage.GetMessage(772));
					lpTarget->DisablePvp = 0;
				}
			}
		}

		#if(GAMESERVER_UPDATE <= 401)
			if (gDuel.CheckDuel(lpObj,lpTarget) == 1)
			{
					if (lpObj->DisablePvp == 1)
					{
						gNotice.GCNoticeSend(lpObj->Index,1,0,0,0,0,0,gMessage.GetMessage(772));
						lpObj->DisablePvp = 0;
					}
					if (lpTarget->DisablePvp == 1)
					{
						gNotice.GCNoticeSend(lpTarget->Index,1,0,0,0,0,0,gMessage.GetMessage(772));
						lpTarget->DisablePvp = 0;
					}
			}
		#endif

		if(lpObj->DisablePvp == 1)
		{
			return 0;
		}

		if(lpTarget->DisablePvp == 1)
		{
			return 0;
		}
	}

	if(gMap[lpObj->Map].CheckAttr(lpObj->X,lpObj->Y,1) != 0 || gMap[lpTarget->Map].CheckAttr(lpTarget->X,lpTarget->Y,1) != 0)
	{
		return 0;
	}

	#if(GAMESERVER_UPDATE>=402)

	if(gDuel.GetDuelArenaBySpectator(lpObj->Index) != 0 || gDuel.GetDuelArenaBySpectator(lpTarget->Index) != 0)
	{
		return 0;
	}

	#endif

	//Event Run And Cacth - Pega Pega
	if (lpTarget->Type == OBJECT_USER && gEventRunAndCatch.m_EventRunAndCatchActive==1)
	{
		gEventRunAndCatch.EventRunAndCatchHit(lpObj->Index,lpTarget->Index);
	}

	#if(GAMESERVER_TYPE==1)

	if(gCastleSiege.GetCastleState() != CASTLESIEGE_STATE_STARTSIEGE)
	{
		if(lpTarget->Type == OBJECT_MONSTER && lpTarget->Map == MAP_CASTLE_SIEGE && (lpTarget->Class == 277 || lpTarget->Class == 283 || lpTarget->Class == 288))
		{
			return 0;
		}
	}

	if(gCrywolf.GetCrywolfState() == CRYWOLF_STATE_READY || gCrywolf.GetCrywolfState() == CRYWOLF_STATE_END)
	{
		if(lpTarget->Type == OBJECT_MONSTER && lpTarget->Map == MAP_CRYWOLF)
		{
			return 0;
		}
	}

	#endif

	if(lpObj->GuildNumber > 0 && lpObj->Guild != 0 && lpObj->Guild->WarState != 0)
	{
		if(lpObj->Guild->WarType == 1 && GetBattleSoccerGoalMove(0) == 0)
		{
			return 1;
		}

		if(lpObj->Guild->WarType == 0 && lpTarget->Type == OBJECT_MONSTER)
		{
			return 0;
		}
	}

	if(lpTarget->Type == OBJECT_NPC || lpTarget->Live == 0 || lpTarget->State != OBJECT_PLAYING || lpTarget->Teleport != 0)
	{
		return 0;
	}

	if(lpTarget->Type == OBJECT_BOTS)
	{
		return 0;
	}

	if(lpTarget->Type == OBJECT_MONSTER)
	{
		if(KALIMA_ATTRIBUTE_RANGE(lpTarget->Attribute) != 0)
		{
			return 0;
		}

		if((lpTarget->Class >= 100 && lpTarget->Class <= 110) || lpTarget->Class == 523) // Trap
		{
			return 0;
		}

		if(lpTarget->Class == 221 || lpTarget->Class == 222) // Siege
		{
			return 0;
		}
	}

	if(lpObj->Type == OBJECT_USER && lpTarget->Type == OBJECT_MONSTER)
	{
		if(OBJECT_RANGE(lpObj->SummonIndex) != 0)
		{
			if(lpObj->SummonIndex == lpTarget->Index)
			{
				return 0;
			}
		}
	}

	if(lpTarget->SummonIndex == lpObj->Index) //help command fix
	{
		return 0;
	}

	if(lpTarget->Index == lpObj->SummonIndex) //help command fix
	{
		return 0;
	}

	if (OBJECT_RANGE(lpObj->SummonIndex) != 0)
	{
		if(lpTarget->SummonIndex == lpObj->SummonIndex) //help command fix
		{
			return 0;
		}
	}

	int SummonIndex = lpObj->Index;

	if(lpObj->Type == OBJECT_MONSTER && OBJECT_RANGE(lpObj->SummonIndex) != 0)
	{
		SummonIndex = lpObj->SummonIndex;
	}

	int SummonTargetIndex = lpTarget->Index;

	if(lpTarget->Type == OBJECT_MONSTER && OBJECT_RANGE(lpTarget->SummonIndex) != 0)
	{
		SummonTargetIndex = lpTarget->SummonIndex;
	}

	if(this->CheckPlayerTarget(&gObj[SummonIndex],&gObj[SummonTargetIndex]) == 0)
	{
		return 0;
	}

	#pragma endregion

	#pragma region ATTACK_RETURN

	int skill = ((lpSkill==0)?SKILL_NONE:lpSkill->m_skill);

	//내구력
	if(damage == 0 && skill != SKILL_PLASMA_STORM && this->DecreaseArrow(lpObj) == 0)
	{
		return 0;
	}

	if(lpObj->Type == OBJECT_USER)
	{
		lpObj->HPAutoRecuperationTime = GetTickCount();
		lpObj->MPAutoRecuperationTime = GetTickCount();
		lpObj->BPAutoRecuperationTime = GetTickCount();
		lpObj->SDAutoRecuperationTime = GetTickCount();
	}

	if(lpTarget->Type == OBJECT_USER)
	{
		lpTarget->HPAutoRecuperationTime = GetTickCount();
		lpTarget->MPAutoRecuperationTime = GetTickCount();
		lpTarget->BPAutoRecuperationTime = GetTickCount();
		lpTarget->SDAutoRecuperationTime = GetTickCount();
	}

	if(OBJECT_RANGE(lpObj->SummonIndex) != 0)
	{
		gObjSummonSetEnemy(lpObj,lpTarget->Index);
	}

	if(lpObj->Type == OBJECT_USER)
	{
		gDarkSpirit[lpObj->Index].SetTarget(lpTarget->Index);
	}

	bool duel = gDuel.CheckDuel(lpObj,lpTarget);

	if(lpObj->Type == OBJECT_USER && duel != 0)
	{
		lpObj->DuelTickCount = GetTickCount();
	}

	if(lpTarget->Type == OBJECT_USER && duel != 0)
	{
		lpTarget->DuelTickCount = GetTickCount();
	}

	gEffectManager.DelEffect(lpObj,EFFECT_INVISIBILITY);

	if(gEffectManager.CheckEffect(lpTarget,EFFECT_ORDER_OF_PROTECTION) != 0 && lpSkill == 0)
	{
		this->MissSend(lpObj,lpTarget,lpSkill,send,count);
		return 1;
	}

	if(gEffectManager.CheckEffect(lpTarget,EFFECT_ORDER_OF_PROTECTION) != 0 && lpSkill != 0)
	{
		this->MissSend(lpObj,lpTarget,lpSkill,send,count);
		return 1;
	}

	if(gEffectManager.CheckEffect(lpTarget,EFFECT_PHYSI_DAMAGE_IMMUNITY) != 0 && lpSkill == 0)
	{
		this->MissSend(lpObj,lpTarget,lpSkill,send,count);
		return 1;
	}

	if(gEffectManager.CheckEffect(lpTarget,EFFECT_MAGIC_DAMAGE_IMMUNITY) != 0 && lpSkill != 0)
	{
		this->MissSend(lpObj,lpTarget,lpSkill,send,count);
		return 1;
	}

	if(lpTarget->Type == OBJECT_MONSTER)
	{
		if(lpTarget->Class == 200 && lpSkill == 0)
		{
			gObjMonsterStateProc(lpTarget,6,lpObj->Index,0);
			this->MissSend(lpObj,lpTarget,lpSkill,send,count);
			return 1;
		}

		if(lpTarget->Class == 200 && lpSkill != 0)
		{
			gObjMonsterStateProc(lpTarget,7,lpObj->Index,0);
			this->MissSend(lpObj,lpTarget,lpSkill,send,count);
			return 1;
		}

		if(gEffectManager.CheckEffect(lpTarget,EFFECT_MONSTER_PHYSI_DAMAGE_IMMUNITY) != 0 && skill == SKILL_NONE)
		{
			this->MissSend(lpObj,lpTarget,lpSkill,send,count);
			return 1;
		}

		if(gEffectManager.CheckEffect(lpTarget,EFFECT_MONSTER_MAGIC_DAMAGE_IMMUNITY) != 0 && skill != SKILL_NONE)
		{
			this->MissSend(lpObj,lpTarget,lpSkill,send,count);
			return 1;
		}

		if(lpTarget->MonsterSkillElementOption.CheckImmuneTime() != 0)
		{
			if(lpTarget->MonsterSkillElementOption.m_SkillElementImmuneNumber == skill)
			{
				this->MissSend(lpObj,lpTarget,lpSkill,send,count);
				return 1;
			}
		}
	}

	#pragma endregion

	#pragma region DAMAGE_CALC

	flag = 0;

	BYTE miss = 0;

	WORD effect = 0;

	if(damage == 0)
	{
		if((lpObj->Type != OBJECT_USER || lpTarget->Type != OBJECT_USER) && this->MissCheck(lpObj,lpTarget,lpSkill,send,count,&miss) == 0)
		{
			#if(GAMESERVER_UPDATE>=701)
			this->AttackElemental(lpObj,lpTarget,lpSkill,send,flag,damage,count,combo);
			#endif
			return 1;
		}

		if((lpObj->Type == OBJECT_USER && lpTarget->Type == OBJECT_USER) && this->MissCheckPvP(lpObj,lpTarget,lpSkill,send,count,&miss) == 0)
		{
			#if(GAMESERVER_UPDATE>=701)
			this->AttackElemental(lpObj,lpTarget,lpSkill,send,flag,damage,count,combo);
			#endif
			return 1;
		}

		int defense = this->GetTargetDefense(lpObj,lpTarget,&effect);

		if(skill == SKILL_PLASMA_STORM)
		{
			damage = this->GetAttackDamageFenrir(lpObj,lpTarget,lpSkill,&effect,defense);
		}
		else if(lpObj->Class == CLASS_SU && (skill == SKILL_SAHAMUTT || skill == SKILL_NEIL || skill == SKILL_GHOST_PHANTOM))
		{
			damage = this->GetAttackDamageCursed(lpObj,lpTarget,lpSkill,&effect,defense);
		}

		//양손
		else if((lpObj->Class == CLASS_DW || lpObj->Class == CLASS_MG || lpObj->Class == CLASS_SU)  && skill != SKILL_NONE && skill != SKILL_FALLING_SLASH && skill != SKILL_LUNGE && skill != SKILL_UPPERCUT && skill != SKILL_CYCLONE && skill != SKILL_SLASH && skill != SKILL_TWISTING_SLASH && skill != SKILL_IMPALE && skill != SKILL_FIRE_SLASH && skill != SKILL_POWER_SLASH && skill != SKILL_SPIRAL_SLASH && skill != SKILL_SWORD_SLASH && skill != SKILL_BLOOD_STORM)
		{
			damage = this->GetAttackDamageWizard(lpObj,lpTarget,lpSkill,&effect,defense);
		}
		else
		{
			damage = this->GetAttackDamage(lpObj,lpTarget,lpSkill,&effect,defense);
		}

		//내구력
		//if(damage > 0)
		//{
		//	this->WeaponDurabilityDown(lpObj,lpTarget);
		//}


		if(miss != 0)
		{
			damage = (damage*30)/100;
		}

		for(int n=0;n < MAX_DAMAGE_REDUCTION;n++)
		{
			damage -= (damage*lpTarget->DamageReduction[n])/100;
		}

		if(lpTarget->EffectOption.AddDamageReduction > 0)
		{
			damage -= (damage*lpTarget->EffectOption.AddDamageReduction)/100;
		}

		if((GetTickCount()-lpTarget->ShieldDamageReductionTime) < ((DWORD)(gServerInfo.m_DefenseTimeConstA*1000)))
		{
			damage -= (damage*lpTarget->ShieldDamageReduction)/100;
		}

		this->WingSprite(lpObj,lpTarget,&damage);

		this->HelperSprite(lpObj,lpTarget,&damage);

		int MinDamage = (lpObj->Level+lpObj->MasterLevel)/10;

		MinDamage = ((MinDamage<1)?1:MinDamage);

		damage = ((damage<MinDamage)?MinDamage:damage);

		this->DamageSprite(lpTarget,damage);

		#if(GAMESERVER_UPDATE>=803)

		gMuunSystem.MuunSprite(lpTarget,damage);

		#endif

		//스킬
	if(skill == SKILL_FALLING_SLASH || skill == SKILL_LUNGE || skill == SKILL_UPPERCUT || skill == SKILL_CYCLONE || skill == SKILL_SLASH)
		{
			if(skill != SKILL_IMPALE || lpObj->Inventory[8].m_Index == GET_ITEM(13,2) || lpObj->Inventory[8].m_Index == GET_ITEM(13,3) || lpObj->Inventory[8].m_Index == GET_ITEM(13,37))
			{
				if(lpObj->Class == CLASS_DK)
				{
					damage = (damage*lpObj->DKDamageMultiplierRate)/100;
				}
				else if(lpObj->Class == CLASS_MG)
				{
					damage = (damage*lpObj->MGDamageMultiplierRate)/100;
				}
				else if(lpObj->Class == CLASS_RF)
				{
					damage = (damage*lpObj->RFDamageMultiplierRate)/100;
				}
				else
				{
					damage = (damage*200)/100;
				}
			}
		}

	if(lpObj->Class == CLASS_MG)
	{
		if(skill == SKILL_POWER_SLASH) //파워슬래쉬
		{
			damage = (damage*gServerInfo.m_MGPowerSlashMultiplierRate)/100;
		}
		else if(skill == SKILL_SPIRAL_SLASH) //나선베기
		{
			damage = (damage*gServerInfo.m_MGSpiralSlashMultiplierRate)/100;
		}
		else if(skill == SKILL_SWORD_SLASH) //플레임스트라이크
		{
			damage = (damage*gServerInfo.m_MGSwordSlashMultiplierRate)/100;
		}
 		else if(skill == SKILL_BLOOD_STORM)
		{
			damage = (damage*gServerInfo.m_MGBloodStormMultiplierRate)/100;
		}
		else if(skill == SKILL_TWISTING_SLASH)
		{
			damage = (damage*gServerInfo.m_MGTwistingSlashMultiplierRate)/100;
		}
		else if(skill == SKILL_IMPALE) //창찌르기
		{
			damage = (damage*gServerInfo.m_MGImPaleMultiplierRate)/100;
		}

		else if (skill == SKILL_FALLING_SLASH) //창찌르기
		{
			damage = (damage * gServerInfo.m_MGFallingSlashMultiplierRateUser) / 100;
			lpObj->MGDamageMultiplierRate = gServerInfo.m_MGFallingSlashMultiplierRateUser;
		}

		else if (skill == SKILL_LUNGE) //창찌르기
		{
			damage = (damage * gServerInfo.m_MGLungeMultiplierRateUser) / 100;
			lpObj->MGDamageMultiplierRate = gServerInfo.m_MGLungeMultiplierRateUser;

		}

		else if (skill == SKILL_CYCLONE) //창찌르기
		{
			damage = (damage * gServerInfo.m_MGCycloneMultiplierRateUser) / 100;
			lpObj->MGDamageMultiplierRate = gServerInfo.m_MGCycloneMultiplierRateUser;

		}

		if (skill == SKILL_DECAY)
		{
			if (lpTarget->Type == OBJECT_USER)
			{
				damage = (damage * gServerInfo.m_MGPoisonMultiplierRateUser) / 100;
			}
			else
			{
				damage = (damage * gServerInfo.m_MGPoisonMultiplierRateUser) / 100;
			}
		}

		//else if (skill == SKILL_DECAY) //창찌르기
		//{
		//	damage = (damage * gServerInfo.m_MGPoisonMultiplierRateUser) / 100;
		//	lpObj->MGDamageMultiplierRate = gServerInfo.m_MGPoisonMultiplierRateUser;

		//}

		if(skill == SKILL_BLAST)
		{
			if(lpTarget->Type == OBJECT_USER)
			{
				damage = (damage*gServerInfo.m_MGBlasTMultiplierRateUser)/100;
			}
			else
			{
				damage = (damage*gServerInfo.m_MGBlasTMultiplierRate)/100;
			}
		}

		if(skill == SKILL_ICE_STORM)
		{
			if(lpTarget->Type == OBJECT_USER)
			{
				damage = (damage*gServerInfo.m_MGIceStormMultiplierRateUser)/100;
			}
			else
			{
				damage = (damage*gServerInfo.m_MGIceStormMultiplierRate)/100;
			}
		}

		if(skill == SKILL_EVIL_SPIRIT)
		{
			if(lpTarget->Type == OBJECT_USER)
			{
				damage = (damage*gServerInfo.m_MGEvilSpiritMultiplierRateUser)/100;
			}
			else
			{
				damage = (damage*gServerInfo.m_MGEvilSpiritMultiplierRate)/100;
			}
		}

		if(skill == SKILL_LIGHTNING_STORM)
		{
			if(lpTarget->Type == OBJECT_USER)
			{
				damage = (damage*gServerInfo.m_MGLightStormMultiplierRateUser)/100;
			}
			else
			{
				damage = (damage*gServerInfo.m_MGLightStormMultiplierRate)/100;
			}
		}

		if(skill == SKILL_MANA_RAYS)
		{
			if(lpTarget->Type == OBJECT_USER)
			{
				damage = (damage*gServerInfo.m_MGManaRaysMultiplierRateUser)/100;
			}
			else
			{
				damage = (damage*gServerInfo.m_MGManaRaysMultiplierRate)/100;
			}
		}

		if(skill == SKILL_FIRE_SLASH)
		{
			if(lpTarget->Type == OBJECT_USER)
			{
				damage = (damage*gServerInfo.m_MGFireSlashMultiplierRateUser)/100;
			}
			else
			{
				damage = (damage*gServerInfo.m_MGFireSlashMultiplierRate)/100;
			}
		}

	}

	if(lpObj->Class == CLASS_FE)
	{
		if(skill == SKILL_ICE_ARROW) //아이스애로우
		{
			damage = (damage*gServerInfo.m_FEIceArrowMultiplierRate)/100;
		}
		else if(skill == SKILL_PENETRATION) //관통
		{
			damage = (damage*gServerInfo.m_FEPenetRationMultiplierRate)/100;
		}
		else if(skill == SKILL_STAR_FALL) //디센트애로우
		{
			damage = (damage*gServerInfo.m_FEStarFallMultiplierRate)/100;
		}
		else if(skill == SKILL_FIVE_SHOT)
		{
			damage = (damage*gServerInfo.m_FEFiveShotMultiplierRate)/100;
		}
	}

	if(lpObj->Class == CLASS_DK)
	{
		if(skill == SKILL_TWISTING_SLASH)
		{
			damage = (damage*gServerInfo.m_DKTwistingSlashMultiplierRate)/100;
		}
		else if(skill == SKILL_RAGEFUL_BLOW)
		{
			damage = (damage*gServerInfo.m_DKRagefFulBlowMultiplierRate)/100;
		}
		else if(skill == SKILL_DEATH_STAB)
		{
			damage = (damage*gServerInfo.m_DKDeathStabMultiplierRate)/100;
		}
		else if(skill == SKILL_FROZEN_STAB)
		{
			damage = (damage*gServerInfo.m_DKFrozenStabMultiplierRate)/100;
		}
 		else if(skill == SKILL_BLOOD_STORM)
		{
			damage = (damage*gServerInfo.m_DKBloodStormMultiplierRate)/100;
		}
		else if(skill == SKILL_SWORD_SLASH) //플레임스트라이크
		{
			damage = (damage*gServerInfo.m_DKSwordSlashMultiplierRate)/100;
		}
		else if(skill == SKILL_IMPALE) //창찌르기
		{
			damage = (damage*gServerInfo.m_DKImPaleMultiplierRate)/100;
		}
		//레이드슛
		else if(skill == SKILL_FIRE_BREATH )
		{
			damage = (damage*gServerInfo.m_DKFireBreAthMultiplierRate)/100;
		}
		//반월베기
		else if(skill == SKILL_CRESCENT_MOON_SLASH)
		{
			damage = (damage*gServerInfo.m_DKCresCentMoonSlashMultiplierRate)/100;
		}
	}


		if(lpObj->Class == CLASS_SU)
		{

		if(skill == SKILL_SAHAMUTT)
		{
			damage = (damage*gServerInfo.m_SUSahamuttMultiplierRate)/100;
		}

		else if(skill == SKILL_NEIL)
		{
			damage = (damage*gServerInfo.m_SUNeilMultiplierRate)/100;
		}

		else if(skill == SKILL_GHOST_PHANTOM)
		{
			damage = (damage*gServerInfo.m_SUGhostPhantomMultiplierRate)/100;
		}

		else if(skill == SKILL_RED_STORM)
		{
			damage = (damage*gServerInfo.m_SURedStormMultiplierRate)/100;
		}

		else if(skill == SKILL_CHAIN_LIGHTNING)
		{
			damage = (damage*gServerInfo.m_SUChainlightningMultiplierRate)/100;
		}

		else if(skill == SKILL_MANA_GLAIVE)
		{
			damage = (damage*gServerInfo.m_SUManaGlaiveMultiplierRate)/100;
		}

		}

		if(lpObj->Class == CLASS_DW)
		{

		if(skill == SKILL_MANA_GLAIVE)
		{
			damage = (damage*gServerInfo.m_DWManaGlaiveMultiplierRate)/100;
		}

		}

		if(lpObj->Class == CLASS_DL)
		{
			if(skill == SKILL_FORCE)
			{
				damage = (damage*lpObj->DLDamageMultiplierRate)/100;
			}
			else if(skill == SKILL_FIRE_SCREAM)
			{
				damage = (damage*gServerInfo.m_DLFireScreamMultiplierRate)/100;
			}
			else if(skill == SKILL_BIRDS)
			{
				damage = (damage*gServerInfo.m_DLChaotickBlrdsMultiplierRate)/100;
			}
			else if(skill == SKILL_EARTHQUAKE)
			{
				damage = (damage*gServerInfo.m_DLEarthQuakeMultiplierRate)/100;
			}
			else if(skill == SKILL_ELECTRIC_SPARK)
			{
				damage = (damage*gServerInfo.m_DLElectricSparkMultiplierRate)/100;
			}
			else if(skill == SKILL_FIRE_BLAST)
			{
				damage = (damage*gServerInfo.m_DLFireBlastMultiplierRate)/100;
			}

			if(skill == SKILL_FIRE_BURST)
			{
				if(lpTarget->Type == OBJECT_USER)
				{
					damage = (damage*gServerInfo.m_DLFireBurstMultiplierRateUser)/100;
				}
				else
				{
					damage = (damage*gServerInfo.m_DLFireBurstMultiplierRate)/100;
				}

			}

		}

		if(lpObj->Class == CLASS_RF)
		{
			if(skill == SKILL_LARGE_RING_BLOWER || skill == SKILL_UPPER_BEAST)
			{
				damage = (damage*gServerInfo.m_RFUpperBeastMultiplierRate)/100;
			}

			else if(skill == SKILL_PHOENIX_SHOT)
			{
				damage = (damage*gServerInfo.m_RFPhoeNixShotMultiplierRate)/100;
			}
			//스킬
			else if(skill == SKILL_CHAIN_DRIVER)
			{
			//	damage = (damage+((lpObj->Strength+lpObj->AddStrength)/gServerInfo.m_RFDamageMultiplierConstA));
				damage = (damage*gServerInfo.m_RFChainDriverMultiplierRate)/100;
			}
			else if(skill == SKILL_DRAGON_LORE)
			{
				//damage = (damage+((lpObj->Energy+lpObj->AddEnergy)/gServerInfo.m_RFDamageMultiplierConstC));
				damage = (damage*gServerInfo.m_RFDraGonLoreMultiplierRate)/100;
			}

			else if(skill == SKILL_DRAGON_SLAYER)
			{
				damage = (damage*lpObj->RFDamageMultiplierRate)/100;
				damage = ((lpTarget->Type==OBJECT_USER)?((damage+100)*3):damage);
			}

			else if(skill == SKILL_CHARGE)
			{
				damage = (damage*gServerInfo.m_RFChargeMultiplierRate)/100;
			}

			 if (skill == SKILL_UPPERCUT)
			{
				if (lpTarget->Type == OBJECT_USER || lpTarget->Type == OBJECT_MONSTER)
				{
					damage = (damage * gServerInfo.m_RFUppercutMultiplierRate) / 100;
					lpObj->MGDamageMultiplierRate = gServerInfo.m_RFUppercutMultiplierRate;
				}
				else

				damage = (damage * gServerInfo.m_RFUppercutMultiplierRate) / 100;
			}

			//다크사이드스킬
			if(skill == SKILL_DARK_SIDE)
			{
				if(lpTarget->Type == OBJECT_USER)
				{
					damage = (damage*gServerInfo.m_RFDarkSideMultiplierRateUser)/100;
				}
				else
				{
					damage = (damage*gServerInfo.m_RFDarkSideMultiplierRate)/100;
				}
			}

		}

		if(skill == SKILL_PLASMA_STORM)
		{
			damage = (damage*(200+(((lpObj->Level>300)?((lpObj->Level-300)+lpObj->MasterLevel):0)/5)))/100;
		}
		else if(skill == SKILL_CHAIN_LIGHTNING)
		{
			damage = (damage*100)/100;
		}
		else if(skill == SKILL_RAKLION_SELUPAN1)
		{
			damage = (damage*200)/100;
		}
		else if(skill == SKILL_RAKLION_SELUPAN2)
		{
			damage = (damage*220)/100;
		}
		else if(skill == SKILL_RAKLION_SELUPAN3)
		{
			damage = (damage*230)/100;
		}
		else if(skill == SKILL_RAKLION_SELUPAN4)
		{
			damage = (damage*250)/100;
		}

		if(count > 0 && (skill == SKILL_UPPER_BEAST || skill == SKILL_DARK_SIDE))
		{
			effect |= (((count%2)==0)?0x20:0x10);
		}

		if(count > 0 && (skill == SKILL_LARGE_RING_BLOWER || skill == SKILL_CHAIN_DRIVER || skill == SKILL_DRAGON_LORE || skill == SKILL_PHOENIX_SHOT))
		{
			effect |= (((count%4)==0)?0x20:0x10);
		}

		if((GetLargeRand()%100) < ((lpObj->DoubleDamageRate)-lpTarget->ResistDoubleDamageRate))
		{
			effect |= 0x40;
			damage += damage;
		}

		if((GetLargeRand()%100) < lpObj->TripleDamageRate) 
		{
			effect |= 0x100;
			damage += damage+damage;
		}

		if(combo != 0)
		{
			effect |= 0x80;
			damage += damage;
			//콤보스킬
	//		damage += (((lpObj->Strength+lpObj->AddStrength)+(lpObj->Dexterity+lpObj->AddDexterity)+(lpObj->Energy+lpObj->AddEnergy))/gServerInfo.m_ComboDamageConstA)*gServerInfo.m_ComboDamageConstB;

			if(lpObj->Class == CLASS_MG)
			{
				damage += (lpObj->Strength+lpObj->AddStrength/gServerInfo.m_ComboMGDamageConstA)*gServerInfo.m_ComboMGDamageConstB;
			}

			else if(lpObj->Class == CLASS_DL)
			{
				damage += (lpObj->Strength+lpObj->AddStrength/gServerInfo.m_ComboDLDamageConstA)*gServerInfo.m_ComboDLDamageConstB;damage *= 0.5;
			}

			else if(lpObj->Class == CLASS_RF)
			{
				damage += (lpObj->Strength+lpObj->AddStrength/gServerInfo.m_ComboRFDamageConstA)*gServerInfo.m_ComboRFDamageConstB;damage *= 0.5;
			}

			else if(lpObj->Class == CLASS_SU)
			{
				damage += (lpObj->Energy+lpObj->AddEnergy/gServerInfo.m_ComboSUDamageConstA)*gServerInfo.m_ComboSUDamageConstB;damage *= 0.5;
			}

			else if(lpObj->Class == CLASS_DW)
			{
				damage += (lpObj->Energy+lpObj->AddEnergy/gServerInfo.m_ComboDWDamageConstA)*gServerInfo.m_ComboDWDamageConstB;damage *= 0.5;
			}

			else if(lpObj->Class == CLASS_FE)
			{
				damage += (lpObj->Dexterity+lpObj->AddDexterity/gServerInfo.m_ComboFEDamageConstA)*gServerInfo.m_ComboFEDamageConstB;damage *= 0.5;

			}

			else if(lpObj->Class == CLASS_DK)
			{
				damage += (lpObj->Strength+lpObj->AddStrength/gServerInfo.m_ComboDKDamageConstA)*gServerInfo.m_ComboDKDamageConstB;	

				#if(GAMESERVER_UPDATE>=602)
				damage += (damage*gMasterSkillTree.GetMasterSkillValue(lpObj,MASTER_SKILL_ADD_COMBO_DAMAGE))/100;
				#endif
			}

    // frozen stab 효과 추가
    if (lpTarget != nullptr)
    {
        // 디버깅 로그
       // LogAdd(LOG_DEBUG, "[Combo] Applying Frozen Stab effect");

        // 직접 frozen stab 효과 적용
        gEffectManager.AddEffect(lpTarget, 0, EFFECT_FROZEN_STAB, 5, 0, 0, 0, 0); // 5초간 얼음 효과
      //  lpTarget->TakeDamage(50); // 추가 데미지 (필요 시)
    }
    else
    {
       // LogAdd(LOG_DEBUG, "[Combo] lpTarget is null");
    }

    skill = SKILL_COMBO;
}
	}
	else
	{
		if(skill != SKILL_EXPLOSION)
		{
			effect = 0x04;
			damage = (damage*((lpObj->Type==OBJECT_USER&&lpTarget->Type==OBJECT_USER)?gServerInfo.m_ReflectDamageRatePvP:gServerInfo.m_ReflectDamageRatePvM))/100;
		}
	}

	#pragma endregion

	#pragma region DAMAGE_CONFIG

	if(lpObj->Type == OBJECT_USER)
	{
		if(lpTarget->Type == OBJECT_USER)
		{
			damage = (damage*gServerInfo.m_GeneralDamageRatePvP)/100;

			damage = (damage*gServerInfo.m_DamageRatePvP[lpObj->Class])/100;

			damage = (damage*gServerInfo.m_DamageRateTo[lpObj->Class][lpTarget->Class])/100;

			if(gDuel.CheckDuel(lpObj,lpTarget) != 0)
			{
				damage = (damage*gServerInfo.m_DuelDamageRate)/100;
			}
			else if(gGensSystem.CheckGens(lpObj,lpTarget) != 0)
			{
				damage = (damage*gServerInfo.m_GensDamageRate)/100;
			}
			else if(CA_MAP_RANGE(lpObj->Map) != 0 && CA_MAP_RANGE(lpTarget->Map) != 0)
			{
				damage = (damage*gServerInfo.m_CustomArenaDamageRate)/100;
			}
			else if(CC_MAP_RANGE(lpObj->Map) != 0 && CC_MAP_RANGE(lpTarget->Map) != 0)
			{
				damage = (damage*gServerInfo.m_ChaosCastleDamageRate)/100;
			}
			else if(IT_MAP_RANGE(lpObj->Map) != 0 && IT_MAP_RANGE(lpTarget->Map) != 0)
			{
				damage = (damage*gServerInfo.m_IllusionTempleDamageRate)/100;
			}
			#if(GAMESERVER_TYPE==1)
			else if(gCastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE && lpObj->Map == MAP_CASTLE_SIEGE && lpTarget->Map == MAP_CASTLE_SIEGE)
			{
				if(lpObj->CsJoinSide == 0 || lpTarget->CsJoinSide == 0 || lpObj->CsJoinSide != lpTarget->CsJoinSide)
				{
					damage = (damage*gServerInfo.m_CastleSiegeDamageRate1)/100;
				}
				else
				{
					damage = (damage*gServerInfo.m_CastleSiegeDamageRate2)/100;
				}
			}
			#endif
		}
		else
		{
			damage = (damage*gServerInfo.m_GeneralDamageRatePvM)/100;

			damage = (damage*gServerInfo.m_DamageRatePvM[lpObj->Class])/100;
		}
	}

	#pragma endregion

	#pragma region DAMAGE_FINISH

	if(lpObj->Type == OBJECT_USER && lpTarget->Type == OBJECT_MONSTER)
	{
		if(lpTarget->Class == 277 || lpTarget->Class == 283) // Castle Gate,Guardian Statue
		{
			if(gEffectManager.CheckEffect(lpObj,EFFECT_BLESS_POTION) != 0)
			{
				damage += (damage*20)/100;
			}

			damage = (damage*gServerInfo.m_CastleSiegeDamageRate3)/100;

			lpObj->AccumulatedDamage = ((lpObj->AccumulatedDamage>100)?0:(lpObj->AccumulatedDamage+damage));
		}
	}

	damage = ((damage<0)?0:damage);

	#pragma endregion

	#pragma region APPLY_EFFECT

	if(lpObj->Type == OBJECT_USER && effect != 4)
	{
		if((GetLargeRand()%100) < lpObj->OffensiveFullHPRestoreRate)
		{
			lpObj->Life = lpObj->MaxLife+lpObj->AddLife;
			GCLifeSend(lpObj->Index,0xFF,(int)lpObj->Life,lpObj->Shield);
		}

		if((GetLargeRand()%100) < lpObj->OffensiveFullSDRestoreRate)
		{
			lpObj->Shield = lpObj->MaxShield+lpObj->AddShield;
			GCLifeSend(lpObj->Index,0xFF,(int)lpObj->Life,lpObj->Shield);
		}

		if((GetLargeRand()%100) < lpObj->OffensiveFullMPRestoreRate)
		{
			lpObj->Mana = lpObj->MaxMana+lpObj->AddMana;
			GCManaSend(lpObj->Index,0xFF,(int)lpObj->Mana,lpObj->BP);
		}

		if((GetLargeRand()%100) < lpObj->OffensiveFullBPRestoreRate)
		{
			lpObj->BP = lpObj->MaxBP+lpObj->AddBP;
			GCManaSend(lpObj->Index,0xFF,(int)lpObj->Mana,lpObj->BP);
		}

		#if(GAMESERVER_UPDATE>=602)

		if(lpObj->Inventory[0].m_Index >= GET_ITEM(2,0) && lpObj->Inventory[0].m_Index < GET_ITEM(3,0))
		{
			if((GetLargeRand()%100) < (gMasterSkillTree.GetMasterSkillValue(lpObj,MASTER_SKILL_ADD_MACE_MASTERY)-lpTarget->ResistStunRate))
			{
				if(gEffectManager.CheckEffect(lpTarget,EFFECT_IRON_DEFENSE) == 0 && gEffectManager.CheckEffect(lpTarget,EFFECT_IRON_DEFENSE_IMPROVED) == 0)
				{
					gEffectManager.AddEffect(lpTarget,0,EFFECT_STERN,2,0,0,0,0);
				}
			}
		}

		if(lpObj->Inventory[1].m_Index >= GET_ITEM(2,0) && lpObj->Inventory[1].m_Index < GET_ITEM(3,0))
		{
			if((GetLargeRand()%100) < (gMasterSkillTree.GetMasterSkillValue(lpObj,MASTER_SKILL_ADD_MACE_MASTERY)-lpTarget->ResistStunRate))
			{
				if(gEffectManager.CheckEffect(lpTarget,EFFECT_IRON_DEFENSE) == 0 && gEffectManager.CheckEffect(lpTarget,EFFECT_IRON_DEFENSE_IMPROVED) == 0)
				{
					gEffectManager.AddEffect(lpTarget,0,EFFECT_STERN,2,0,0,0,0);
				}
			}
		}

		if(gEffectManager.CheckEffect(lpObj,EFFECT_BLOOD_HOWLING) != 0 || gEffectManager.CheckEffect(lpObj,EFFECT_BLOOD_HOWLING_IMPROVED) != 0)
		{
			int rate = gServerInfo.m_BloodHowlingConstA;

			rate += gMasterSkillTree.GetMasterSkillValue(lpObj,MASTER_SKILL_ADD_BLOOD_HOWLING_IMPROVED);

			if((GetLargeRand()%100) < rate)
			{
				if(gEffectManager.CheckEffect(lpTarget,EFFECT_IRON_DEFENSE) == 0 && gEffectManager.CheckEffect(lpTarget,EFFECT_IRON_DEFENSE_IMPROVED) == 0)
				{
					int damage = gServerInfo.m_BloodHowlingConstB;

					gEffectManager.AddEffect(lpTarget,0,EFFECT_DEATH_STAB_ENHANCED,10,lpObj->Index,1,SET_NUMBERHW(damage),SET_NUMBERLW(damage));
				}
			}
		}

		#endif
	}

	if(lpSkill != 0 && count <= 1)
	{
		if(this->ApplySkillEffect(lpObj,lpTarget,lpSkill,damage) == 0)
		{
			if(send != 0)
			{
				gSkillManager.GCSkillAttackSend(lpObj,lpSkill->m_index,lpTarget->Index,0);
			}
		}
		else
		{
			if(send != 0)
			{
				gSkillManager.GCSkillAttackSend(lpObj,lpSkill->m_index,lpTarget->Index,1);
			}
		}
	}

	#pragma endregion

	#pragma region DAMAGE_APPLY

	int ShieldDamage = 0;

	if(lpObj->Type == OBJECT_USER && lpTarget->Type == OBJECT_USER)
	{
		ShieldDamage = this->GetShieldDamage(lpObj,lpTarget,damage);

		if(lpTarget->Life < (damage-ShieldDamage))
		{
			lpTarget->Life = 0;
		}
		else
		{
			lpTarget->Life -= damage-ShieldDamage;
		}

		if(lpTarget->Shield < ShieldDamage)
		{
			lpTarget->Shield = 0;
		}
		else
		{
			lpTarget->Shield -= ShieldDamage;
		}
	}
	else
	{
		if(lpTarget->Life < damage)
		{
			lpTarget->Life = 0;
		}
		else
		{
			lpTarget->Life -= damage;
		}
	}

	if(lpTarget->Type == OBJECT_MONSTER)
	{
		lpTarget->LastAttackerID = lpObj->Index;

		gObjAddMsgSendDelay(lpTarget,0,lpObj->Index,100,0);

		if(lpTarget->CurrentAI != 0)
		{
			lpTarget->Agro.IncAgro(lpObj->Index,(damage/50));
		}
	}

	#pragma endregion

	#pragma region CHECK_SELF_DEFENSE

	if(damage > 0)
	{
		if(lpObj->Type == OBJECT_USER && lpTarget->Type == OBJECT_USER && lpObj->Index != lpTarget->Index)
		{
			bool CheckSelfDefense = 1;

			//윽윽이
			if(effect == 4)
			{
				CheckSelfDefense = 0;
			}

			if(gDuel.CheckDuel(lpObj,lpTarget) != 0)
			{
				CheckSelfDefense = 0;
			}

			if(gObjGetRelationShip(lpObj,lpTarget) == 2)
			{
				CheckSelfDefense = 0;
			}

			if(gObjTargetGuildWarCheck(lpObj,lpTarget) != 0)
			{
				CheckSelfDefense = 0;
			}

			if(gGensSystem.CheckGens(lpObj,lpTarget) != 0)
			{
				CheckSelfDefense = 0;
			}

			//팀배틀
			if (gTvTEvent.CheckPlayerTarget(lpObj) && gTvTEvent.CheckPlayerTarget(lpTarget))
			{
				CheckSelfDefense = 0;
			}

			//if (gTvTEvent.CheckPlayerTarget(lpObj))
			//{
			//	CheckSelfDefense = 0;
			//}
			//if (gTvTEvent.CheckPlayerTarget(lpTarget))
			//{
			//	CheckSelfDefense = 0;
			//}


			#if(GAMESERVER_TYPE==1)

			if(lpObj->Map == MAP_CASTLE_SIEGE && gCastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE && lpObj->CsJoinSide != 0)
			{
				CheckSelfDefense = 0;
			}

			#endif

			if(CA_MAP_RANGE(lpObj->Map) != 0 && CA_MAP_RANGE(lpTarget->Map) != 0)
			{
				CheckSelfDefense = 0;
			}

			if(CC_MAP_RANGE(lpObj->Map) != 0 && CC_MAP_RANGE(lpTarget->Map) != 0)
			{
				CheckSelfDefense = 0;
			}

			if(IT_MAP_RANGE(lpObj->Map) != 0 && IT_MAP_RANGE(lpTarget->Map) != 0)
			{
				CheckSelfDefense = 0;
			}

			if(lpObj->PvP != 0 && lpTarget->PvP != 0)
			{
				CheckSelfDefense = 0;
			}

			if(lpObj->KillAll != 0 && lpTarget->KillAll != 0)
			{
				CheckSelfDefense = 0;
			}

			if(gMapManager.GetMapNonOutlaw(lpObj->Map) != 0)
			{
				CheckSelfDefense = 0;
			}

			if(CheckSelfDefense != 0)
			{
				gObjCheckSelfDefense(lpObj,lpTarget->Index);
			}
		}

		//내구력
		//this->ArmorDurabilityDown(lpObj,lpTarget);
	}

	lpObj->Rest = 0;

	#pragma endregion

	#pragma region ATTACK_FINISH

	if(damage > 0)
	{
		gEffectManager.DelEffect(lpTarget,EFFECT_SLEEP);

		if(effect != 4 && lpTarget->Type == OBJECT_USER)
		{
			if((GetLargeRand()%100) < lpTarget->FullDamageReflectRate)
			{
				gObjAddMsgSendDelay(lpTarget,10,lpObj->Index,10,damage);
			}
			else if((lpTarget->DamageReflect+lpTarget->EffectOption.AddDamageReflect) > 0)
			{
				gObjAddMsgSendDelay(lpTarget,10,lpObj->Index,10,((damage*(lpTarget->DamageReflect+lpTarget->EffectOption.AddDamageReflect))/100));
			}

			if((GetLargeRand()%100) < lpTarget->DefensiveFullHPRestoreRate)
			{
				lpTarget->Life = lpTarget->MaxLife+lpTarget->AddLife;
				GCLifeSend(lpTarget->Index,0xFF,(int)lpTarget->Life,lpTarget->Shield);
			}

			if((GetLargeRand()%100) < lpTarget->DefensiveFullSDRestoreRate)
			{
				lpTarget->Shield = lpTarget->MaxShield+lpTarget->AddShield;
				GCLifeSend(lpTarget->Index,0xFF,(int)lpTarget->Life,lpTarget->Shield);
			}

			if((GetLargeRand()%100) < lpTarget->DefensiveFullMPRestoreRate)
			{
				lpTarget->Mana = lpTarget->MaxMana+lpTarget->AddMana;
				GCManaSend(lpTarget->Index,0xFF,(int)lpTarget->Mana,lpTarget->BP);
			}

			if((GetLargeRand()%100) < lpTarget->DefensiveFullBPRestoreRate)
			{
				lpTarget->BP = lpTarget->MaxBP+lpTarget->AddBP;
				GCManaSend(lpTarget->Index,0xFF,(int)lpTarget->Mana,lpTarget->BP);
			}

		}

		//윽윽이
		else if(effect == 4 && lpTarget->Type == OBJECT_USER)
		{
			if(lpTarget->Inventory[8].IsItem() == 0 || (lpTarget->Inventory[8].m_Index != GET_ITEM(13,2) && lpTarget->Inventory[8].m_Index != GET_ITEM(13,3) && lpTarget->Inventory[8].m_Index != GET_ITEM(13,4) && lpTarget->Inventory[8].m_Index != GET_ITEM(13,37)))
			{
				if((GetLargeRand()%100) < gServerInfo.m_DamageStuckRate[lpTarget->Class])
				{
					flag = 1;
				}
			}
		}


		gObjectManager.CharacterLifeCheck(lpObj,lpTarget,(damage-ShieldDamage),0,flag,effect,((lpSkill==0)?0:lpSkill->m_index),ShieldDamage);
		//gObjectManager.CharacterLifeCheck(lpObj, lpTarget, (damage - ShieldDamage), 0, flag, effect, skill, ShieldDamage);//original combo push effect

		#if(GAMESERVER_UPDATE>=701)

		this->AttackElemental(lpObj,lpTarget,lpSkill,send,flag,damage,count,combo);

		#endif
	}
	else
	{
		GCDamageSend(lpObj->Index,lpTarget->Index,0,0,effect,0);

		#if(GAMESERVER_UPDATE>=701)

		this->AttackElemental(lpObj,lpTarget,lpSkill,send,flag,damage,count,combo);

		#endif
	}

	if(lpObj->Type == OBJECT_USER && lpObj->Life <= 0 && lpObj->CheckLifeTime <= 0)
	{
		lpObj->AttackObj = lpTarget;
		lpObj->AttackerKilled = ((lpTarget->Type==OBJECT_USER)?1:0);
		lpObj->CheckLifeTime = 3;
	}


	#pragma endregion

	return 1;
}

bool CAttack::AttackElemental(LPOBJ lpObj,LPOBJ lpTarget,CSkill* lpSkill,bool send,BYTE flag,int damage,int count,bool combo) // OK
{
	#if(GAMESERVER_UPDATE>=701)

	#pragma region ATTACK_CHECK

	if(lpObj->ElementalAttribute == 0)
	{
		return 0;
	}

	if(lpObj->Type == OBJECT_USER && lpSkill == 0)
	{
		return 0;
	}

	if(lpObj->Type == OBJECT_USER && (lpObj->Inventory[236].IsItem() == 0 || lpObj->Inventory[236].IsPentagramItem() == 0 || lpObj->Inventory[236].m_IsValidItem == 0))
	{
		return 0;
	}

	#pragma endregion

	#pragma region DAMAGE_CALC

	flag = 0;

	BYTE miss = 0;

	WORD effect = lpObj->ElementalAttribute;

	if(this->MissCheckElemental(lpObj,lpTarget,lpSkill,send,count,&miss) == 0)
	{
		return 1;
	}

	int defense = this->GetTargetElementalDefense(lpObj,lpTarget,&effect);

	damage = this->GetAttackDamageElemental(lpObj,lpTarget,lpSkill,&effect,damage,defense);

	if(miss != 0)
	{
		damage = (damage*30)/100;
	}

	if(lpObj->Type == OBJECT_USER && lpTarget->Type == OBJECT_USER)
	{
		damage -= (damage*lpTarget->PentagramJewelOption.AddElementalDamageReductionPvP)/100;
	}

	if(lpObj->Type != OBJECT_USER && lpTarget->Type == OBJECT_USER)
	{
		damage -= (damage*lpTarget->PentagramJewelOption.AddElementalDamageReductionPvM)/100;
	}

	int MinDamage = (lpObj->Level+lpObj->MasterLevel)/10;

	MinDamage = ((MinDamage<1)?1:MinDamage);

	damage = ((damage<MinDamage)?MinDamage:damage);

	#pragma endregion

	#pragma region DAMAGE_CONFIG

	if(lpObj->Type == OBJECT_USER)
	{
		if(lpTarget->Type == OBJECT_USER)
		{
			damage = (damage*gServerInfo.m_GeneralElementalDamageRatePvP)/100;

			damage = (damage*gServerInfo.m_ElementalDamageRatePvP[lpObj->Class])/100;

			damage = (damage*gServerInfo.m_ElementalDamageRateTo[lpObj->Class][lpTarget->Class])/100;

			if(gDuel.CheckDuel(lpObj,lpTarget) != 0)
			{
				damage = (damage*gServerInfo.m_DuelElementalDamageRate)/100;
			}
			else if(gGensSystem.CheckGens(lpObj,lpTarget) != 0)
			{
				damage = (damage*gServerInfo.m_GensElementalDamageRate)/100;
			}
			else if(CA_MAP_RANGE(lpObj->Map) != 0 && CA_MAP_RANGE(lpTarget->Map) != 0)
			{
				damage = (damage*gServerInfo.m_CustomArenaElementalDamageRate)/100;
			}
			else if(CC_MAP_RANGE(lpObj->Map) != 0 && CC_MAP_RANGE(lpTarget->Map) != 0)
			{
				damage = (damage*gServerInfo.m_ChaosCastleElementalDamageRate)/100;
			}
			else if(IT_MAP_RANGE(lpObj->Map) != 0 && IT_MAP_RANGE(lpTarget->Map) != 0)
			{
				damage = (damage*gServerInfo.m_IllusionTempleElementalDamageRate)/100;
			}
			#if(GAMESERVER_TYPE==1)
			else if(gCastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE && lpObj->Map == MAP_CASTLE_SIEGE && lpTarget->Map == MAP_CASTLE_SIEGE)
			{
				if(lpObj->CsJoinSide == 0 || lpTarget->CsJoinSide == 0 || lpObj->CsJoinSide != lpTarget->CsJoinSide)
				{
					damage = (damage*gServerInfo.m_CastleSiegeElementalDamageRate1)/100;
				}
				else
				{
					damage = (damage*gServerInfo.m_CastleSiegeElementalDamageRate2)/100;
				}
			}
			#endif
		}
		else
		{
			damage = (damage*gServerInfo.m_GeneralElementalDamageRatePvM)/100;

			damage = (damage*gServerInfo.m_ElementalDamageRatePvM[lpObj->Class])/100;
		}
	}

	#pragma endregion

	#pragma region APPLY_EFFECT

	if(lpObj->Type == OBJECT_USER)
	{
		if((GetLargeRand()%100) < lpObj->PentagramJewelOption.AddElementalSlowRate)
		{
			gEffectManager.AddEffect(lpTarget,0,EFFECT_PENTAGRAM_JEWEL_SLOW,20,0,0,0,0);
		}

		if((GetLargeRand()%100) < lpObj->PentagramJewelOption.AddElementalDebuffRate)
		{
			switch(lpObj->ElementalAttribute)
			{
				case ELEMENTAL_ATTRIBUTE_FIRE:
					gEffectManager.AddEffect(lpTarget,0,EFFECT_PENTAGRAM_JEWEL_HALF_SD,5,0,0,0,0);
					break;
				case ELEMENTAL_ATTRIBUTE_WATER:
					gEffectManager.AddEffect(lpTarget,0,EFFECT_PENTAGRAM_JEWEL_HALF_MP,5,0,0,0,0);
					break;
				case ELEMENTAL_ATTRIBUTE_EARTH:
					gEffectManager.AddEffect(lpTarget,0,EFFECT_PENTAGRAM_JEWEL_HALF_SPEED,5,0,0,0,0);
					break;
				case ELEMENTAL_ATTRIBUTE_WIND:
					gEffectManager.AddEffect(lpTarget,0,EFFECT_PENTAGRAM_JEWEL_HALF_HP,5,0,0,0,0);
					break;
				case ELEMENTAL_ATTRIBUTE_DARK:
					gEffectManager.AddEffect(lpTarget,0,EFFECT_PENTAGRAM_JEWEL_STUN,5,0,0,0,0);
					break;
			}
		}
	}

	#pragma endregion

	#pragma region DAMAGE_APPLY

	int ShieldDamage = 0;

	if(lpObj->Type == OBJECT_USER && lpTarget->Type == OBJECT_USER)
	{
		ShieldDamage = this->GetShieldDamage(lpObj,lpTarget,damage);

		if(lpTarget->Life < (damage-ShieldDamage))
		{
			lpTarget->Life = 0;
		}
		else
		{
			lpTarget->Life -= damage-ShieldDamage;
		}

		if(lpTarget->Shield < ShieldDamage)
		{
			lpTarget->Shield = 0;
		}
		else
		{
			lpTarget->Shield -= ShieldDamage;
		}

		GCLifeSend(lpTarget->Index,0xFF,(int)lpTarget->Life,lpTarget->Shield);
	}
	else
	{
		if(lpTarget->Life < damage)
		{
			lpTarget->Life = 0;
		}
		else
		{
			lpTarget->Life -= damage;
		}
	}

	#pragma endregion

	#pragma region ATTACK_FINISH

	if(damage > 0)
	{
		gObjectManager.CharacterLifeCheck(lpObj,lpTarget,(damage-ShieldDamage),4,flag,effect,((lpSkill==0)?0:lpSkill->m_index),ShieldDamage);
	}
	else
	{
		GCElementalDamageSend(lpObj->Index,lpTarget->Index,(BYTE)effect,0);
	}

	#pragma endregion

	return 1;

	#else

	return 0;

	#endif
}

bool CAttack::DecreaseArrow(LPOBJ lpObj) // OK
{
		return 1;

	if(gEffectManager.CheckEffect(lpObj,EFFECT_INFINITY_ARROW) != 0 || gEffectManager.CheckEffect(lpObj,EFFECT_INFINITY_ARROW_IMPROVED) != 0)
	{
		return 1;
	}

	//내구력
	if(lpObj->Inventory[0].m_Index >= GET_ITEM(4,0) && lpObj->Inventory[0].m_Index < GET_ITEM(5,0) && lpObj->Inventory[0].m_Index != GET_ITEM(4,15) && lpObj->Inventory[0].m_Slot == 0)
	{
		if(lpObj->Inventory[1].m_Index != GET_ITEM(4,7) || lpObj->Inventory[1].m_Durability < 1)
		{
			return 0;
		}
		else
		{
			gItemManager.DecreaseItemDur(lpObj,1,1);
		}
	}

	if(lpObj->Inventory[1].m_Index >= GET_ITEM(4,0) && lpObj->Inventory[1].m_Index < GET_ITEM(5,0) && lpObj->Inventory[1].m_Index != GET_ITEM(4,7) && lpObj->Inventory[1].m_Slot == 1)
	{
		if(lpObj->Inventory[0].m_Index != GET_ITEM(4,15) || lpObj->Inventory[0].m_Durability < 1)
		{
			return 0;
		}
		else
		{
			gItemManager.DecreaseItemDur(lpObj,0,1);
		}
	}

	return 1;
}

void CAttack::WingSprite(LPOBJ lpObj,LPOBJ lpTarget,int* damage) // OK
{
	if(lpObj != 0 && lpObj->Type == OBJECT_USER)
	{
		CItem* lpItem = &lpObj->Inventory[7];

		if(lpItem->IsItem() != 0 && lpItem->m_Durability > 0)
		{
			if(lpObj->Class == CLASS_DW || lpObj->Class == CLASS_FE || lpObj->Class == CLASS_SU)
			{
				lpObj->Life -= 1;
			}
			else
			{
				lpObj->Life -= 3;
			}

			GCLifeSend(lpObj->Index,0xFF,(int)lpObj->Life,lpObj->Shield);

			if((lpItem->m_Index >= GET_ITEM(12,0) && lpItem->m_Index <= GET_ITEM(12,2)) || lpItem->m_Index == GET_ITEM(12,41)) // 1st wing
			{
				(*damage) = ((*damage)*(112+(lpItem->m_Level*1)))/100;
			}
			else if((lpItem->m_Index >= GET_ITEM(12,3) && lpItem->m_Index <= GET_ITEM(12,6)) || lpItem->m_Index == GET_ITEM(12,42)) // 2sd wing
			{
				(*damage) = ((*damage)*(130+(lpItem->m_Level*1)))/100;
			}
			else if((lpItem->m_Index >= GET_ITEM(12,36) && lpItem->m_Index <= GET_ITEM(12,40)) || lpItem->m_Index == GET_ITEM(12,43) || lpItem->m_Index == GET_ITEM(12,50)) // 3rd wing
			{
				(*damage) = ((*damage)*(140+(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(12,49)) // Cloak of Fighter
			{
				(*damage) = ((*damage)*(130+(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index >= GET_ITEM(12,130) && lpItem->m_Index <= GET_ITEM(12,135)) // Mini Wings
			{
				(*damage) = ((*damage)*(112+(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(12,262)) // Cloak of Death
			{
				(*damage) = ((*damage)*(144+(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(12,263)) // Wings of Chaos
			{
				(*damage) = ((*damage)*(135+(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(12,264)) // Wings of Magic
			{
				(*damage) = ((*damage)*(135+(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(12,265)) // Wings of Life
			{
				(*damage) = ((*damage)*(135+(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(12,266)) // Wings of Conqueror
			{
				(*damage) = ((*damage)*(145+(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(12,267)) // Wings of Angel and Devil
			{
				(*damage) = ((*damage)*(145+(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(13,30)) // Cloak of Lord
			{
				(*damage) = ((*damage)*(130+(lpItem->m_Level*1)))/100;
			}
			else if(gCustomWing.CheckCustomWingByItem(lpItem->m_Index) != 0)
			{
				//날개
				(*damage) = ((*damage)*gCustomWing.GetCustomWingIncDamage(lpItem->m_Index,lpItem->m_Level*1))/100;
			}
		}
	}

	if(lpTarget != 0 && lpTarget->Type == OBJECT_USER)
	{
		CItem* lpItem = &lpTarget->Inventory[7];

		if(lpItem->IsItem() != 0 && lpItem->m_Durability > 0)
		{
			if((lpItem->m_Index >= GET_ITEM(12,0) && lpItem->m_Index <= GET_ITEM(12,2)) || lpItem->m_Index == GET_ITEM(12,41)) // 1st wing
			{
				(*damage) = ((*damage)*(88-(lpItem->m_Level*1)))/100;
			}
			else if((lpItem->m_Index >= GET_ITEM(12,3) && lpItem->m_Index <= GET_ITEM(12,6)) || lpItem->m_Index == GET_ITEM(12,42)) // 2sd wing
			{
				(*damage) = ((*damage)*(75-(lpItem->m_Level*1)))/100;
			}
			else if((lpItem->m_Index >= GET_ITEM(12,36) && lpItem->m_Index <= GET_ITEM(12,39)) || lpItem->m_Index == GET_ITEM(12,43) || lpItem->m_Index == GET_ITEM(12,50)) // 3rd wing
			{
				(*damage) = ((*damage)*(65-(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(12,40)) // Mantle of Monarch
			{
				(*damage) = ((*damage)*(75-(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(12,49)) // Cloak of Fighter
			{
				(*damage) = ((*damage)*(75-(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index >= GET_ITEM(12,130) && lpItem->m_Index <= GET_ITEM(12,135)) // Mini Wings
			{
				(*damage) = ((*damage)*(88-(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(12,262)) // Cloak of Death
			{
				(*damage) = ((*damage)*(60-(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(12,263)) // Wings of Chaos
			{
				(*damage) = ((*damage)*(70-(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(12,264)) // Wings of Magic
			{
				(*damage) = ((*damage)*(70-(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(12,265)) // Wings of Life
			{
				(*damage) = ((*damage)*(70-(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(12,266)) // Wings of Conqueror
			{
				(*damage) = ((*damage)*(60-(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(12,267)) // Wings of Angel and Devil
			{
				(*damage) = ((*damage)*(60-(lpItem->m_Level*1)))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(13,30)) // Cloak of Lord
			{
				(*damage) = ((*damage)*(75-(lpItem->m_Level*1)))/100;
			}
			else if(gCustomWing.CheckCustomWingByItem(lpItem->m_Index) != 0)
			{
				//날개
				(*damage) = ((*damage)*gCustomWing.GetCustomWingDecDamage(lpItem->m_Index,lpItem->m_Level*1))/100;
			}
		}
	}
}

//펫
void CAttack::HelperSprite(LPOBJ lpObj,LPOBJ lpTarget,int* damage) // OK
{
	if(lpObj != 0 && lpObj->Type == OBJECT_USER)
	{
		CItem* lpItem = &lpObj->Inventory[8];

		if(lpItem->IsItem() != 0 && lpItem->m_Durability > 0)
		{
			if(lpItem->m_Index == GET_ITEM(13,1)) // Satan
			{
				lpObj->Life -= 3;

				GCLifeSend(lpObj->Index,0xFF,(int)lpObj->Life,lpObj->Shield);

				//(*damage) = ((*damage)*(100+gServerInfo.m_SatanIncDamageConstA))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(13,3)) // Dinorant
			{
				lpObj->Life -= 1;

				GCLifeSend(lpObj->Index,0xFF,(int)lpObj->Life,lpObj->Shield);

				(*damage) = ((*damage)*(100+gServerInfo.m_DinorantIncDamageConstA))/100;
			}

			else if(lpItem->m_Index == GET_ITEM(13,37)) // Fenrir
			{
				if((lpItem->m_NewOption & 1) != 0)
				{
					(*damage) = ((*damage)*(100+gServerInfo.m_BlackFenrirIncDamageConstA))/100;
				}
			}

			else if(lpItem->m_Index == GET_ITEM(13,64)) // Demon
			{
				lpObj->Life -= 4;

				GCLifeSend(lpObj->Index,0xFF,(int)lpObj->Life,lpObj->Shield);

				//(*damage) = ((*damage)*(100+gServerInfo.m_DemonIncDamageConstA))/100;
			}

			else if(lpItem->m_Index == GET_ITEM(13,123)) // Skeleton
			{
				lpObj->Life -= 2;

				GCLifeSend(lpObj->Index,0xFF,(int)lpObj->Life,lpObj->Shield);

				//(*damage) = ((*damage)*(100+gServerInfo.m_SkeletonIncDamageConstA))/100;
			}

			//유니콘
			else if(lpItem->m_Index == GET_ITEM(13,106)) // Skeleton
			{
				lpObj->Life -= 2;

				GCLifeSend(lpObj->Index,0xFF,(int)lpObj->Life,lpObj->Shield);

				//(*damage) = ((*damage)*(100+gServerInfo.m_UiConDamageConstA))/100;
			}


		}
	}

	if(lpTarget != 0 && lpTarget->Type == OBJECT_USER)
	{
		CItem* lpItem = &lpTarget->Inventory[8];

		if(lpItem->IsItem() != 0 && lpItem->m_Durability > 0)
		{
			if(lpItem->m_Index == GET_ITEM(13,0)) // Angel
			{
				(*damage) = ((*damage)*(100-gServerInfo.m_AngelDecDamageConstA))/100;
			}
			else if(lpItem->m_Index == GET_ITEM(13,3)) // Dinorant
			{
				(*damage) = ((*damage)*(100-gServerInfo.m_DinorantDecDamageConstA-(((lpItem->m_NewOption & 1)==0)?0:gServerInfo.m_DinorantDecDamageConstB)))/100;
			}

			//다크호스
			//else if(lpItem->m_Index == GET_ITEM(13,4)) // Dark Horse
			//{
			//	(*damage) = ((*damage)*(100-((gServerInfo.m_DarkHorseDecDamageConstA+lpItem->m_PetItemLevel)/gServerInfo.m_DarkHorseDecDamageConstB)))/100;
			//}

			else if(lpItem->m_Index == GET_ITEM(13,37)) // Fenrir
			{
				if((lpItem->m_NewOption & 2) != 0)
				{
					(*damage) = ((*damage)*(100-gServerInfo.m_BlueFenrirDecDamageConstA))/100;
				}
			}
			else if(lpItem->m_Index == GET_ITEM(13,65)) // Maria
			{
				(*damage) = ((*damage)*(100-gServerInfo.m_MariaDecDamageConstA))/100;
			}
		}
	}
}

void CAttack::DamageSprite(LPOBJ lpObj,int damage) // OK
{
	return; // disable for unlimit life for pets, mounts , etc

	if(lpObj->Type != OBJECT_USER)
	{
		return;
	}

	CItem* lpItem = &lpObj->Inventory[8];

	if(lpItem->IsItem() == 0 || lpItem->m_IsPeriodicItem != 0)
	{
		return;
	}

	float DurabilityValue = (1.0f/gServerInfo.m_GuardianDurabilityRate)*100;

	DurabilityValue = (DurabilityValue/lpObj->GuardianDurabilityRate)*100;

	if(lpItem->m_Index == GET_ITEM(13,0)) // Angel
	{
		lpItem->m_Durability -= (damage*(3.0f*DurabilityValue))/100;
	}
	else if(lpItem->m_Index == GET_ITEM(13,1)) // Satan
	{
		lpItem->m_Durability -= (damage*(2.0f*DurabilityValue))/100;
	}
	else if(lpItem->m_Index == GET_ITEM(13,2)) // Uniria
	{
		lpItem->m_Durability -= (damage*(1.0f*DurabilityValue))/100;
	}
	else if(lpItem->m_Index == GET_ITEM(13,3)) // Dinorant
	{
		lpItem->m_Durability -= (damage*(1.0f*DurabilityValue))/100;
	}
	else if(lpItem->m_Index == GET_ITEM(13, 4) || lpItem->m_Index == GET_ITEM(13, 5)) // Dark Horse or Dark Raven
{
    if(this->DarkHorseSprite(lpObj, damage) == 0)
    {
        return;
    }
}
	else if(lpItem->m_Index == GET_ITEM(13,37)) // Fenrir
	{
		if(this->FenrirSprite(lpObj,damage) == 0)
		{
			return;
		}
	}
	else if(lpItem->m_Index == GET_ITEM(13,64)) // Demon
	{
		lpItem->m_Durability -= (damage*(1.0f*DurabilityValue))/100;
	}
	else if(lpItem->m_Index == GET_ITEM(13,65)) // Maria
	{
		lpItem->m_Durability -= (damage*(2.0f*DurabilityValue))/100;
	}
	else if(lpItem->m_Index == GET_ITEM(13,67)) // Rudolf
	{
		lpItem->m_Durability -= (damage*(1.0f*DurabilityValue))/100;
	}
	else if(lpItem->m_Index == GET_ITEM(13,80)) // Panda
	{
		lpItem->m_Durability -= (damage*(1.0f*DurabilityValue))/100;
	}
	else if(lpItem->m_Index == GET_ITEM(13,106)) // Unicorn
	{
		lpItem->m_Durability -= (damage*(1.0f*DurabilityValue))/100;
	}
	else if(lpItem->m_Index == GET_ITEM(13,123)) // Skeleton
	{
		lpItem->m_Durability -= (damage*(1.0f*DurabilityValue))/100;
	}
	else
	{
		return;
	}

	gItemManager.GCItemDurSend(lpObj->Index,8,(BYTE)lpItem->m_Durability,0);

	if(lpItem->m_Durability < 1)
	{
		gItemManager.InventoryDelItem(lpObj->Index,8);

		gItemManager.GCItemDeleteSend(lpObj->Index,8,0);

		gObjectManager.CharacterMakePreviewCharSet(lpObj->Index);

		gItemManager.GCItemChangeSend(lpObj->Index,8);

		if(lpObj->Map == MAP_ICARUS && lpObj->Inventory[7].IsItem() == 0 && (lpItem->m_Index == GET_ITEM(13,3) || lpItem->m_Index == GET_ITEM(13,37)))
		{
			gObjMoveGate(lpObj->Index,22);
		}
	}
}

bool CAttack::DarkHorseSprite(LPOBJ lpObj, int damage) // OK
{
    CItem* lpItem = &lpObj->Inventory[8];

    if (lpItem->m_Durability < 1)
    {
        return 0;
    }

    lpItem = &lpObj->Inventory[1]; // Inventory[1]도 추가로 확인

    if (lpItem->m_Durability < 1)
    {
        return 0;
    }

    // 추가적인 처리를 여기에 구현


	lpItem->m_DurabilitySmall += ((damage*2)/100)+1;

	int MaxSmallDur = (1500*gServerInfo.m_PetDurabilityRate)/100;

	MaxSmallDur = (MaxSmallDur*lpObj->PetDurabilityRate)/100;

	if(lpItem->m_DurabilitySmall > MaxSmallDur)
	{
		lpItem->m_Durability = (((--lpItem->m_Durability)<1)?0:lpItem->m_Durability);
		lpItem->m_DurabilitySmall = 0;

		if(lpItem->CheckDurabilityState() != 0)
		{
			gObjectManager.CharacterCalcAttribute(lpObj->Index);
		}

		gItemManager.GCItemDurSend(lpObj->Index,8,(BYTE)lpItem->m_Durability,0);

		GCPetItemInfoSend(lpObj->Index,1,0,8,lpItem->m_PetItemLevel,lpItem->m_PetItemExp,(BYTE)lpItem->m_Durability);
	}

	return 0;
}

bool CAttack::FenrirSprite(LPOBJ lpObj,int damage) // OK
{
	CItem* lpItem = &lpObj->Inventory[8];

	if(lpItem->m_Durability < 1)
	{
		return 0;
	}

	lpItem->m_DurabilitySmall += ((damage*2)/100)+1;

	int MaxSmallDur = (200*gServerInfo.m_GuardianDurabilityRate)/100;

	MaxSmallDur = (MaxSmallDur*lpObj->GuardianDurabilityRate)/100;

	if(lpItem->m_DurabilitySmall > MaxSmallDur)
	{
		lpItem->m_Durability = (((--lpItem->m_Durability)<1)?0:lpItem->m_Durability);
		lpItem->m_DurabilitySmall = 0;

		if(lpItem->CheckDurabilityState() != 0)
		{
			gObjectManager.CharacterCalcAttribute(lpObj->Index);
		}

		gItemManager.GCItemDurSend(lpObj->Index,8,(BYTE)lpItem->m_Durability,0);
	}

	return 1;
}

void CAttack::WeaponDurabilityDown(LPOBJ lpObj,LPOBJ lpTarget) // OK
{
	if(lpObj->Type != OBJECT_USER)
	{
		return;
	}

	if(gEffectManager.GetEffect(lpObj,EFFECT_TALISMAN_OF_PROTECTION) != 0)
	{
		return;
	}

	for(int n=0;n < 2;n++)
	{
		if(lpObj->Inventory[n].IsItem() != 0)
		{
			bool result = 0;

			switch((lpObj->Inventory[n].m_Index/MAX_ITEM_TYPE))
			{
				case 0:
					result = lpObj->Inventory[n].WeaponDurabilityDown(lpObj->Index,lpTarget->Defense,0);
					break;
				case 1:
					result = lpObj->Inventory[n].WeaponDurabilityDown(lpObj->Index,lpTarget->Defense,0);
					break;
				case 2:
					result = lpObj->Inventory[n].WeaponDurabilityDown(lpObj->Index,lpTarget->Defense,0);
					break;
				case 3:
					result = lpObj->Inventory[n].WeaponDurabilityDown(lpObj->Index,lpTarget->Defense,0);
					break;
				case 4:
					result = lpObj->Inventory[n].WeaponDurabilityDown(lpObj->Index,lpTarget->Defense,1);
					break;
				case 5:
					result = lpObj->Inventory[n].WeaponDurabilityDown(lpObj->Index,lpTarget->Defense,((lpObj->Inventory[n].m_Slot==0)?2:3));
					break;
			}

			if(result != 0)
			{
				gItemManager.GCItemDurSend(lpObj->Index,n,(BYTE)lpObj->Inventory[n].m_Durability,0);
			}
		}
	}
}

void CAttack::ArmorDurabilityDown(LPOBJ lpObj,LPOBJ lpTarget) // OK
{
	if(lpTarget->Type != OBJECT_USER)
	{
		return;
	}

	if(gEffectManager.GetEffect(lpTarget,EFFECT_TALISMAN_OF_PROTECTION) != 0)
	{
		return;
	}

	int slot = 1+(GetLargeRand()%6);

	if(lpTarget->Inventory[slot].IsItem() != 0)
	{
		if(slot != 1 || (lpTarget->Inventory[slot].m_Index >= GET_ITEM(6,0) && lpTarget->Inventory[slot].m_Index < GET_ITEM(7,0)))
		{
			if(lpTarget->Inventory[slot].ArmorDurabilityDown(lpTarget->Index,lpObj->PhysiDamageMin) != 0)
			{
				gItemManager.GCItemDurSend(lpTarget->Index,slot,(BYTE)lpTarget->Inventory[slot].m_Durability,0);
			}
		}
	}
}

bool CAttack::CheckPlayerTarget(LPOBJ lpObj,LPOBJ lpTarget) // OK
{
	if(lpObj->Type != OBJECT_USER || lpTarget->Type != OBJECT_USER)
	{
		return 1;
	}

	if(lpTarget->Authority == 32)
	{
		return 0;
	}

	if(lpObj->PvP != 0 && lpTarget->PvP != 0)
	{
		return 1;
	}

	if(lpObj->HelperDelayTime != 0 && gParty.IsMember(lpObj->PartyNumber,lpTarget->Index) != 0)
	{
		return 0;
	}

	if(gServerInfo.m_PartyDisablePK != 0 && gParty.IsMember(lpObj->PartyNumber,lpTarget->Index) != 0)
	{
		return 0;
	}

	if(lpObj->HelperDelayTime != 0 && gParty.IsMember(lpObj->PartyNumber,lpTarget->Index) != 0)
	{
		return 0;
	}

	if(gObjGetRelationShip(lpObj,lpTarget) == 2 && gMapManager.GetMapNonPK(lpTarget->Map) == 0)
	{
		return 1;
	}


	//길드공격 불가
	if (lpObj->AutoGuildAttack != false || lpTarget->AutoGuildAttack != false)
	{
		if (CC_MAP_RANGE(lpObj->Map) != true && CC_MAP_RANGE(lpTarget->Map) != true)
		{

			if(lpObj->Guild && 0x01 != 0 && lpTarget->Guild && 0x01 != 0)
			if (lpObj->Guild != 0 && lpTarget->Guild != 0)
		{
				if (lpObj->Guild->Number == lpTarget->Guild->Number)
				{
					return 0;
				}
			}
		}
	}

	// 길드공격 가능

//if (lpObj->AutoGuildAttack != false || lpTarget->AutoGuildAttack != false)
//{
  //  if (CC_MAP_RANGE(lpObj->Map) != true && CC_MAP_RANGE(lpTarget->Map) != true)
   // {
        // 길드가 같더라도 공격이 이루어지도록 해당 조건을 제거함
   // }
//}


	//팀배틀
	if (gTvTEvent.CheckPlayerJoined(lpObj,lpTarget))
	{
		return 0;
	}

	if (gTvTEvent.CheckSelfTeam(lpObj, lpTarget))
	{
		return 0;
	}


	if(lpObj->Guild != 0 && lpTarget->Guild != 0)
	{
		if(lpObj->Guild->WarState != 0 && lpTarget->Guild->WarState != 0)
		{
			if(lpObj->Guild->Number == lpTarget->Guild->Number)
			{
				return 0;
			}
		}
	}

	if(gObjTargetGuildWarCheck(lpObj,lpTarget) == 0)
	{
		if(lpTarget->Guild != 0 && lpTarget->Guild->WarState != 0)
		{
			if(lpTarget->Guild->WarType == 1 && lpTarget->Map != MAP_ARENA && gMapManager.GetMapNonPK(lpTarget->Map) == 0)
			{
				return 1;
			}

			if(CA_MAP_RANGE(lpTarget->Map) == 0 && CC_MAP_RANGE(lpTarget->Map) == 0 && IT_MAP_RANGE(lpTarget->Map) == 0 && gDuel.CheckDuel(lpObj,lpTarget) == 0 && gGensSystem.CheckGens(lpObj,lpTarget) == 0)
			{
				return 0;
			}
		}
	}

	if(gDuel.CheckDuel(lpObj,lpTarget) == 0 && OBJECT_RANGE(lpTarget->DuelUser) != 0)
	{
		return 0;
	}

	if(gMapManager.GetMapGensBattle(lpObj->Map) != 0 && gMapManager.GetMapGensBattle(lpTarget->Map) != 0)
	{
		return ((gMapManager.GetMapNonPK(lpTarget->Map)==0)?gGensSystem.CheckGens(lpObj,lpTarget):0);
	}

	if(lpObj->KillAll == 1 && lpTarget->KillAll == 1 && gEventKillAll.CheckPlayerTarget(lpObj,lpTarget) == 0)
	{
		return 0;
	}

	if(CA_MAP_RANGE(lpObj->Map) != 0 && CA_MAP_RANGE(lpTarget->Map) != 0)
	{
		return ((gCustomArena.CheckPlayerTarget(lpObj,lpTarget)==0)?0:1);
	}

	if(DS_MAP_RANGE(lpObj->Map) != 0 && DS_MAP_RANGE(lpTarget->Map) != 0)
	{
		return 0;
	}

	if(BC_MAP_RANGE(lpObj->Map) != 0 && BC_MAP_RANGE(lpTarget->Map) != 0)
	{
		return 0;
	}

	if(CC_MAP_RANGE(lpObj->Map) != 0 && CC_MAP_RANGE(lpTarget->Map) != 0)
	{
		return ((gChaosCastle.GetState(GET_CC_LEVEL(lpObj->Map))==CC_STATE_START)?1:0);
	}

	#if(GAMESERVER_TYPE==1)

	if(lpObj->Map == MAP_CASTLE_SIEGE && lpTarget->Map == MAP_CASTLE_SIEGE)
	{
		if(gCastleSiege.GetCastleState() == CASTLESIEGE_STATE_STARTSIEGE)
		{
			if(lpObj->CsJoinSide != 0 && lpTarget->CsJoinSide != 0)
			{
				if(gServerInfo.m_CastleSiegeDamageRate2 == 0 && lpObj->CsJoinSide == lpTarget->CsJoinSide)
				{
					return 0;
				}
				else
				{
					return 1;
				}
			}
		}
	}

	#endif

	if(lpObj->Map == MAP_KANTURU3 && lpTarget->Map == MAP_KANTURU3)
	{
		return 0;
	}

	if(IT_MAP_RANGE(lpObj->Map) != 0 && IT_MAP_RANGE(lpTarget->Map) != 0)
	{
		return gIllusionTemple.CheckPlayerTarget(lpObj,lpTarget);
	}

	if(lpObj->Map == MAP_RAKLION2 && lpTarget->Map == MAP_RAKLION2)
	{
		return 0;
	}

	if(DG_MAP_RANGE(lpObj->Map) != 0 && DG_MAP_RANGE(lpTarget->Map) != 0)
	{
		return 0;
	}

	if(IG_MAP_RANGE(lpObj->Map) != 0 && IG_MAP_RANGE(lpTarget->Map) != 0)
	{
		return 0;
	}
	//EnablePK level 1
	//if(lpObj->Level <= 5 || lpTarget->Level <= 5)
	//{
	//	return 0;
	//}

	if(gMapManager.GetMapNonPK(lpTarget->Map) != 0)
	{
		return 0;
	}

	//팀배틀
	//if (gTvTEvent.CheckPlayerJoined(lpObj,lpObj) && !gTvTEvent.CheckPlayerJoined(lpTarget,lpTarget))
	//{
	//	return 0;
	//}

	//if (gTvTEvent.CheckPlayerJoined(lpTarget,lpTarget) && !gTvTEvent.CheckPlayerJoined(lpObj,lpObj))
	//{
	//	return 0;
	//}

	return 1;
}

void CAttack::MissSend(LPOBJ lpObj,LPOBJ lpTarget,CSkill* lpSkill,int send,int count) // OK
{
	WORD effect = 0;

	if(count > 0 && lpSkill != 0 && (lpSkill->m_skill == SKILL_UPPER_BEAST || lpSkill->m_skill == SKILL_DARK_SIDE))
	{
		effect |= (((count%2)==0)?0x20:0x10);
	}

	if(count > 0 && lpSkill != 0 && (lpSkill->m_skill == SKILL_LARGE_RING_BLOWER || lpSkill->m_skill == SKILL_CHAIN_DRIVER || lpSkill->m_skill == SKILL_DRAGON_LORE || lpSkill->m_skill == SKILL_PHOENIX_SHOT))
	{
		effect |= (((count%4)==0)?0x20:0x10);
	}

	GCDamageSend(lpObj->Index,lpTarget->Index,0,0,effect,0);

	if(send != 0 && lpSkill != 0)
	{
		gSkillManager.GCSkillAttackSend(lpObj,lpSkill->m_index,lpTarget->Index,0);
	}
}

bool CAttack::MissCheck(LPOBJ lpObj,LPOBJ lpTarget,CSkill* lpSkill,int send,int count,BYTE* miss) // OK
{
	int AttackSuccessRate = lpObj->AttackSuccessRate;

	AttackSuccessRate += lpObj->EffectOption.AddAttackSuccessRate;

	AttackSuccessRate += (AttackSuccessRate*lpObj->EffectOption.MulAttackSuccessRate)/100;

	AttackSuccessRate -= (AttackSuccessRate*lpObj->EffectOption.DivAttackSuccessRate)/100;

	AttackSuccessRate = ((AttackSuccessRate<0)?0:AttackSuccessRate);

	int DefenseSuccessRate = lpTarget->DefenseSuccessRate;

	DefenseSuccessRate += lpTarget->EffectOption.AddDefenseSuccessRate;

	DefenseSuccessRate += (DefenseSuccessRate*lpTarget->EffectOption.MulDefenseSuccessRate)/100;

	DefenseSuccessRate -= (DefenseSuccessRate*lpTarget->EffectOption.DivDefenseSuccessRate)/100;

	DefenseSuccessRate = ((DefenseSuccessRate<0)?0:DefenseSuccessRate);

	if(AttackSuccessRate < DefenseSuccessRate)
	{
		(*miss) = 1;

		if((GetLargeRand()%100) >= 5)
		{
			this->MissSend(lpObj,lpTarget,lpSkill,send,count);
			return 0;
		}
	}
	else
	{
		(*miss) = 0;

		if((GetLargeRand()%((AttackSuccessRate==0)?1:AttackSuccessRate)) < DefenseSuccessRate)
		{
			this->MissSend(lpObj,lpTarget,lpSkill,send,count);
			return 0;
		}
	}

	return 1;
}

bool CAttack::MissCheckPvP(LPOBJ lpObj,LPOBJ lpTarget,CSkill* lpSkill,int send,int count,BYTE* miss) // OK
{
	(*miss) = 0;

	return true;	//added for disable miss on pvp

	int AttackSuccessRate = (int)(((100*(((lpObj->AttackSuccessRatePvP*10000.0f)/(lpObj->AttackSuccessRatePvP+lpTarget->DefenseSuccessRatePvP))/10000.0f))*gServerInfo.m_ShieldGaugeAttackRate)*(((lpObj->Level*10000.0f)/(lpObj->Level+lpTarget->Level))/10000.0f));

	if((lpTarget->Level-lpObj->Level) >= 100)
	{
		AttackSuccessRate -= 5;
	}
	else if((lpTarget->Level-lpObj->Level) >= 200)
	{
		AttackSuccessRate -= 10;
	}
	else if((lpTarget->Level-lpObj->Level) >= 300)
	{
		AttackSuccessRate -= 15;
	}

	if((GetLargeRand()%100) > AttackSuccessRate)
	{
		this->MissSend(lpObj,lpTarget,lpSkill,send,count);

		if(gServerInfo.m_ShieldGaugeAttackComboMiss != 0 && lpObj->ComboSkill.m_index >= 0)
		{
			lpObj->ComboSkill.Init();
		}

		return 0;
	}

	return 1;
}

bool CAttack::MissCheckElemental(LPOBJ lpObj,LPOBJ lpTarget,CSkill* lpSkill,int send,int count,BYTE* miss) // OK
{
	#if(GAMESERVER_UPDATE>=701)

	int ElementalAttackSuccessRate = lpObj->ElementalAttackSuccessRate;

	if(lpObj->Type == OBJECT_USER)
	{
		ElementalAttackSuccessRate += (ElementalAttackSuccessRate*lpObj->PentagramOption.MulElementalAttackSuccessRate)/100;

		ElementalAttackSuccessRate += (ElementalAttackSuccessRate*lpObj->PentagramJewelOption.MulElementalAttackSuccessRate)/100;

		ElementalAttackSuccessRate = ((ElementalAttackSuccessRate<0)?0:ElementalAttackSuccessRate);
	}

	int ElementalDefenseSuccessRate = lpTarget->ElementalDefenseSuccessRate;

	if(lpTarget->Type == OBJECT_USER)
	{
		ElementalDefenseSuccessRate += (ElementalDefenseSuccessRate*lpTarget->PentagramOption.MulElementalDefenseSuccessRate)/100;

		ElementalDefenseSuccessRate += (ElementalDefenseSuccessRate*lpTarget->PentagramJewelOption.MulElementalDefenseSuccessRate)/100;

		ElementalDefenseSuccessRate = ((ElementalDefenseSuccessRate<0)?0:ElementalDefenseSuccessRate);
	}

	if(ElementalAttackSuccessRate < ElementalDefenseSuccessRate)
	{
		(*miss) = 1;

		if((GetLargeRand()%100) >= 5)
		{
			GCElementalDamageSend(lpObj->Index,lpTarget->Index,lpObj->ElementalAttribute,0);
			return 0;
		}
	}
	else
	{
		(*miss) = 0;

		if((GetLargeRand()%((ElementalAttackSuccessRate==0)?1:ElementalAttackSuccessRate)) < ElementalDefenseSuccessRate)
		{
			GCElementalDamageSend(lpObj->Index,lpTarget->Index,lpObj->ElementalAttribute,0);
			return 0;
		}
	}

	return 1;

	#else

	return 0;

	#endif
}

bool CAttack::ApplySkillEffect(LPOBJ lpObj,LPOBJ lpTarget,CSkill* lpSkill,int damage) // OK
{
	if(lpTarget->Type != OBJECT_USER && ((lpTarget->Class >= 204 && lpTarget->Class <= 209) || (lpTarget->Class >= 215 && lpTarget->Class <= 219) || lpTarget->Class == 277 || lpTarget->Class == 278 || lpTarget->Class == 283 || lpTarget->Class == 288))
	{
		return 0;
	}

	if(lpTarget->Type == OBJECT_USER && (gEffectManager.CheckEffect(lpTarget,EFFECT_IRON_DEFENSE) != 0 || gEffectManager.CheckEffect(lpTarget,EFFECT_IRON_DEFENSE_IMPROVED) != 0))
	{
		return 0;
	}

	if(gSkillManager.GetSkillType(lpSkill->m_index) != -1 && gObjCheckResistance(lpTarget,gSkillManager.GetSkillType(lpSkill->m_index)) != 0)
	{
		return 0;
	}

	if (gSkillDamage.GetEffectRate(lpSkill) != 0)
	{
		return 0;
	}

	switch(lpSkill->m_skill)
	{
		case SKILL_POISON:
			gEffectManager.AddEffect(lpTarget,0,gSkillManager.GetSkillEffect(lpSkill->m_index),20,lpObj->Index,2,3,0);
			break;
		case SKILL_METEORITE:
			gSkillManager.ApplyMeteoriteEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_LIGHTNING:
			if (gServerInfo.m_DisableLightningEffect == 0)	gObjAddMsgSendDelay(lpTarget,2,lpObj->Index,150,0);
			break;
		case SKILL_ICE:
			gEffectManager.AddEffect(lpTarget,0,gSkillManager.GetSkillEffect(lpSkill->m_index),10,0,0,0,0);
			break;
		case SKILL_FALLING_SLASH:
			if (gServerInfo.m_DisableFallingEffect == 0)	gObjAddMsgSendDelay(lpTarget, 2,lpObj->Index,50,0);//old 750
			break;
		case SKILL_LUNGE:
			if (gServerInfo.m_DisableLungEffect == 0)		gObjAddMsgSendDelay(lpTarget,2,lpObj->Index,150,0);
			break;
		case SKILL_UPPERCUT:
			if (gServerInfo.m_DisableUpperCutEffect == 0)	gObjAddMsgSendDelay(lpTarget,2,lpObj->Index,150,0);
			break;
		case SKILL_CYCLONE:
			if (gServerInfo.m_DisableCycloneEffect == 0) 	gObjAddMsgSendDelay(lpTarget,2, lpObj->Index,150, 0);//old 750
			break;
		case SKILL_SLASH:
			if (gServerInfo.m_DisableTwistEffect == 0)		gObjAddMsgSendDelay(lpTarget,2,lpObj->Index,150,0);
			break;
		case SKILL_DECAY:
			gEffectManager.AddEffect(lpTarget,0,gSkillManager.GetSkillEffect(lpSkill->m_index),10,lpObj->Index,2,3,0);
			break;
		case SKILL_ICE_STORM:
			gSkillManager.ApplyIceStormEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_ICE_ARROW:
			gEffectManager.AddEffect(lpTarget,0,gSkillManager.GetSkillEffect(lpSkill->m_index),7,0,0,0,0);
			break;
		case SKILL_TWISTING_SLASH:
			gSkillManager.ApplyTwistingSlashEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_RAGEFUL_BLOW:
			gSkillManager.ApplyRagefulBlowEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_DEATH_STAB:
			gSkillManager.ApplyDeathStabEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_FIRE_SLASH:
			gSkillManager.ApplyFireSlashEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_FIRE_BURST:
			gSkillManager.ApplyFireBurstEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_PLASMA_STORM:
			gSkillManager.ApplyPlasmaStormEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_FIRE_SCREAM:
			gSkillManager.ApplyFireScreamEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_EARTHQUAKE:
			gSkillManager.ApplyEarthquakeEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_DRAIN_LIFE:
			gSkillManager.ApplyDrainLifeEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_SAHAMUTT:
			gSkillManager.ApplySahamuttEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_NEIL:
			gSkillManager.ApplyNeilEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_GHOST_PHANTOM:
			gSkillManager.ApplyGhostPhantomEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_RED_STORM:
			gEffectManager.AddEffect(lpTarget,0,gSkillManager.GetSkillEffect(lpSkill->m_index),1,0,0,0,0);
			break;
		case SKILL_FROZEN_STAB:
			gSkillManager.ApplyFrozenStabEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_FIVE_SHOT:
			gSkillManager.ApplyFiveShotEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_SWORD_SLASH:
			gSkillManager.ApplySwordSlashEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_LIGHTNING_STORM:
			gEffectManager.AddEffect(lpTarget,0,gSkillManager.GetSkillEffect(lpSkill->m_index),1,0,0,0,0);
			break;
		case SKILL_LARGE_RING_BLOWER:
			gSkillManager.ApplyLargeRingBlowerEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_UPPER_BEAST:
			gSkillManager.ApplyUpperBeastEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_CHAIN_DRIVER:
			gSkillManager.ApplyChainDriverEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_DRAGON_LORE:
			gSkillManager.ApplyDragonLoreEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_DRAGON_SLAYER:
			gSkillManager.ApplyDragonSlayerEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_PHOENIX_SHOT:
			gSkillManager.ApplyPhoenixShotEffect(lpObj,lpTarget,lpSkill,damage);
			break;
		case SKILL_POISON_ARROW:
			gEffectManager.AddEffect(lpTarget,0,gSkillManager.GetSkillEffect(lpSkill->m_index),10,lpObj->Index,2,3,0);
			break;
		case SKILL_EARTH_PRISON:
			gSkillManager.ApplyEarthPrisonEffect(lpObj,lpTarget,lpSkill,damage);
			break;
	}

	return 1;
}

int CAttack::GetTargetDefense(LPOBJ lpObj,LPOBJ lpTarget,WORD* effect) // OK
{
	int defense = lpTarget->Defense;

	defense += lpTarget->EffectOption.AddDefense;
	defense -= lpTarget->EffectOption.SubDefense;

	gSkillManager.SkillSwordPowerGetDefense(lpObj->Index,&defense);

	if(lpObj->Type == OBJECT_USER && lpTarget->Type == OBJECT_USER)
	{
		defense += lpTarget->DefensePvP;
	}

	if(lpTarget->MonsterSkillElementOption.CheckDefenseTime() != 0)
	{
		defense += lpTarget->MonsterSkillElementOption.m_SkillElementDefense;
	}

	if(lpTarget->EffectOption.MulDefense > 0)
	{
		defense += (defense*lpTarget->EffectOption.MulDefense)/100;
	}

	if(lpTarget->EffectOption.DivDefense > 0)
	{
		defense -= (defense*lpTarget->EffectOption.DivDefense)/100;
	}

	if(lpTarget->Type == OBJECT_USER)
	{
		defense = (defense*50)/100;
	}

	if((GetLargeRand()%100) < ((lpObj->IgnoreDefenseRate+lpObj->EffectOption.AddIgnoreDefenseRate)-lpTarget->ResistIgnoreDefenseRate))
	{
		(*effect) = 1;

		defense = 0;
	}

	defense = ((defense<0)?0:defense);

	return defense;
}

int CAttack::GetTargetElementalDefense(LPOBJ lpObj,LPOBJ lpTarget,WORD* effect) // OK
{
	#if(GAMESERVER_UPDATE>=701)

	int defense = lpTarget->ElementalDefense;

	if(lpTarget->Type == OBJECT_USER)
	{
		defense += (((lpTarget->Inventory[236].IsItem()==0)?0:lpTarget->Inventory[236].m_Defense)*lpTarget->PentagramOption.MulPentagramDefense)/100;

		defense += (lpTarget->Defense*lpTarget->PentagramOption.AddElementalDefenseTransferRate)/100;

		defense += lpTarget->PentagramJewelOption.AddElementalDefense;

		if(lpObj->Type == OBJECT_USER)
		{
			defense += lpTarget->PentagramJewelOption.AddElementalDefensePvP;

			if(lpObj->Class == CLASS_DW || lpObj->Class == CLASS_FE || lpObj->Class == CLASS_MG || lpObj->Class == CLASS_SU)
			{
				defense += lpTarget->PentagramJewelOption.AddElementalDefenseRange;
			}
			else
			{
				defense += lpTarget->PentagramJewelOption.AddElementalDefenseMelee;
			}
		}
		else
		{
			defense += lpTarget->PentagramJewelOption.AddElementalDefensePvM;
		}
	}

	gPentagramSystem.GetPentagramRelationshipDefense(lpTarget,lpObj,&defense);

	defense = ((defense<0)?0:defense);

	return defense;

	#else

	return 0;

	#endif
}

int CAttack::GetAttackDamage(LPOBJ lpObj,LPOBJ lpTarget,CSkill* lpSkill,WORD* effect,int TargetDefense) // OK
{
	CItem* Right = &lpObj->Inventory[0];
	CItem* Left = &lpObj->Inventory[1];

	int damage = 0;
	int DamageMin = 0;
	int DamageMax = 0;
	int SkillDamageMin = 0;
	int SkillDamageMax = 0;
	bool DualHandWeapon = 0;

	if(lpObj->Type == OBJECT_MONSTER || lpObj->Type == OBJECT_NPC)
	{
		DamageMin = lpObj->PhysiDamageMin;
		DamageMax = lpObj->PhysiDamageMax;

		DamageMin += lpObj->EffectOption.AddPhysiDamage;
		DamageMax += lpObj->EffectOption.AddPhysiDamage;

		DamageMin += lpObj->EffectOption.AddMinPhysiDamage;
		DamageMax += lpObj->EffectOption.AddMaxPhysiDamage;

		DamageMin += (DamageMin*lpObj->EffectOption.MulPhysiDamage)/100;
		DamageMax += (DamageMax*lpObj->EffectOption.MulPhysiDamage)/100;

		DamageMin -= (DamageMin*lpObj->EffectOption.DivPhysiDamage)/100;
		DamageMax -= (DamageMax*lpObj->EffectOption.DivPhysiDamage)/100;

		int range = (DamageMax-DamageMin);

		range = ((range<1)?1:range);

		damage = DamageMin+(GetLargeRand()%range);
	}
	else
	{
		if(lpObj->Class == CLASS_DK || lpObj->Class == CLASS_MG || lpObj->Class == CLASS_DL || lpObj->Class == CLASS_RF)
		{
			if(Right->m_Index >= GET_ITEM(0,0) && Right->m_Index < GET_ITEM(4,0) && Left->m_Index >= GET_ITEM(0,0) && Left->m_Index < GET_ITEM(4,0))
			{
				if(Right->m_IsValidItem != 0 && Left->m_IsValidItem != 0)
				{
					DualHandWeapon = 1;
				}
			}
		}

		if(lpSkill != 0)
		{
			SkillDamageMin = lpSkill->m_DamageMin;
			SkillDamageMax = lpSkill->m_DamageMax;

			SkillDamageMin += gMasterSkillTree.GetMasterSkillDamageMin(lpObj,lpSkill->m_skill);
			SkillDamageMax += gMasterSkillTree.GetMasterSkillDamageMax(lpObj,lpSkill->m_skill);

			SkillDamageMin += lpObj->SkillDamageBonus;
			SkillDamageMax += lpObj->SkillDamageBonus;

			int type = gSkillManager.GetSkillType(lpSkill->m_index);

			if(CHECK_RANGE(type,MAX_RESISTANCE_TYPE) != 0)
			{
				SkillDamageMin += lpObj->AddResistance[type];
				SkillDamageMax += lpObj->AddResistance[type];
			}

			if(lpObj->Class == CLASS_DL)
			{
				switch(lpSkill->m_skill)
				{
					case SKILL_EARTHQUAKE:
						SkillDamageMin += ((lpObj->Strength+lpObj->AddStrength)/gServerInfo.m_EarthquakeDamageConstA)+((lpObj->Leadership+lpObj->AddLeadership)/gServerInfo.m_EarthquakeDamageConstB)+(lpObj->Inventory[8].m_PetItemLevel*gServerInfo.m_EarthquakeDamageConstC);
						SkillDamageMax += ((lpObj->Strength+lpObj->AddStrength)/gServerInfo.m_EarthquakeDamageConstA)+((lpObj->Leadership+lpObj->AddLeadership)/gServerInfo.m_EarthquakeDamageConstB)+(lpObj->Inventory[8].m_PetItemLevel*gServerInfo.m_EarthquakeDamageConstC);
						break;
					case SKILL_ELECTRIC_SPARK:
						SkillDamageMin += ((lpObj->Leadership+lpObj->AddLeadership)/gServerInfo.m_ElectricSparkDamageConstA)+gServerInfo.m_ElectricSparkDamageConstB;
						SkillDamageMax += ((lpObj->Leadership+lpObj->AddLeadership)/gServerInfo.m_ElectricSparkDamageConstA)+gServerInfo.m_ElectricSparkDamageConstB;
						break;
					default:
						//스킬
						//SkillDamageMin += ((lpObj->Strength+lpObj->AddStrength)/gServerInfo.m_DLSkillDamageConstA)+((lpObj->Energy+lpObj->AddEnergy)/gServerInfo.m_DLSkillDamageConstB);
						//SkillDamageMax += ((lpObj->Strength+lpObj->AddStrength)/gServerInfo.m_DLSkillDamageConstA)+((lpObj->Energy+lpObj->AddEnergy)/gServerInfo.m_DLSkillDamageConstB);
						SkillDamageMin += ((lpObj->Strength+lpObj->AddStrength)/gServerInfo.m_DLSkillDamageConstA);
						SkillDamageMax += ((lpObj->Strength+lpObj->AddStrength)/gServerInfo.m_DLSkillDamageConstA);
						break;
				}
			}
		}

		if(DualHandWeapon != 0)
		{
			DamageMin = lpObj->PhysiDamageMinRight+lpObj->PhysiDamageMinLeft+SkillDamageMin;
			DamageMax = lpObj->PhysiDamageMaxRight+lpObj->PhysiDamageMaxLeft+SkillDamageMax;
		}
		else if((Right->m_Index >= GET_ITEM(0,0) && Right->m_Index < GET_ITEM(4,0)) || (Right->m_Index >= GET_ITEM(5,0) && Right->m_Index < GET_ITEM(6,0)))
		{
			DamageMin = lpObj->PhysiDamageMinRight+SkillDamageMin;
			DamageMax = lpObj->PhysiDamageMaxRight+SkillDamageMax;
		}
		else if(Right->m_Index >= GET_ITEM(4,0) && Right->m_Index < GET_ITEM(5,0) && Right->m_Index != GET_ITEM(4,15) && Right->m_Slot == 0)
		{
			DamageMin = lpObj->PhysiDamageMinRight+SkillDamageMin;
			DamageMax = lpObj->PhysiDamageMaxRight+SkillDamageMax;
		}
		else if(Left->m_Index >= GET_ITEM(4,0) && Left->m_Index < GET_ITEM(5,0) && Left->m_Index != GET_ITEM(4,7) && Left->m_Slot == 1)
		{
			DamageMin = lpObj->PhysiDamageMinLeft+SkillDamageMin;
			DamageMax = lpObj->PhysiDamageMaxLeft+SkillDamageMax;
		}
		else
		{
			DamageMin = lpObj->PhysiDamageMinLeft+SkillDamageMin;
			DamageMax = lpObj->PhysiDamageMaxLeft+SkillDamageMax;
		}

		DamageMin += lpObj->EffectOption.AddPhysiDamage;
		DamageMax += lpObj->EffectOption.AddPhysiDamage;

		DamageMin += lpObj->EffectOption.AddMinPhysiDamage;
		DamageMax += lpObj->EffectOption.AddMaxPhysiDamage;

		gSkillManager.SkillSwordPowerGetPhysiDamage(lpObj->Index,&DamageMin,&DamageMax);

		DamageMin += (DamageMin*lpObj->EffectOption.MulPhysiDamage)/100;
		DamageMax += (DamageMax*lpObj->EffectOption.MulPhysiDamage)/100;

		DamageMin -= (DamageMin*lpObj->EffectOption.DivPhysiDamage)/100;
		DamageMax -= (DamageMax*lpObj->EffectOption.DivPhysiDamage)/100;

		int range = (DamageMax-DamageMin);

		range = ((range<1)?1:range);

		damage = DamageMin+(GetLargeRand()%range);

		if((GetLargeRand()%100) < ((lpObj->CriticalDamageRate+lpObj->EffectOption.AddCriticalDamageRate)-lpTarget->ResistCriticalDamageRate))
		{
			(*effect) = 3;

			damage = DamageMax;
			damage += lpObj->CriticalDamage;
			damage += lpObj->EffectOption.AddCriticalDamage;
		}

		if((GetLargeRand()%100) < ((lpObj->ExcellentDamageRate+lpObj->EffectOption.AddExcellentDamageRate)-lpTarget->ResistExcellentDamageRate))
		{
			(*effect) = 2;

			damage = (DamageMax*120)/100;
			damage += lpObj->ExcellentDamage;
			damage += lpObj->EffectOption.AddExcellentDamage;
		}
	}

	if(lpObj->Type == OBJECT_USER && lpTarget->Type == OBJECT_USER)
	{
		damage += lpObj->DamagePvP;
	}

	if(lpObj->MonsterSkillElementOption.CheckAttackTime() != 0)
	{
		damage += lpObj->MonsterSkillElementOption.m_SkillElementAttack;
	}

	damage -= TargetDefense;

	damage = ((damage<0)?0:damage);

	return gSkillDamage.GetDamageRate(lpSkill, damage);
}

int CAttack::GetAttackDamageWizard(LPOBJ lpObj,LPOBJ lpTarget,CSkill* lpSkill,WORD* effect,int TargetDefense) // OK
{
	CItem* Right = &lpObj->Inventory[0];
	CItem* Left = &lpObj->Inventory[1];

	int DamageMin = lpObj->MagicDamageMin;
	int DamageMax = lpObj->MagicDamageMax;

	//헬파이어스킬
	if(lpSkill->m_skill == SKILL_NOVA && lpObj->SkillNovaCount >= 0)
	{
		DamageMin += (gServerInfo.m_NovaDamageConstA*(lpObj->SkillNovaCount*gServerInfo.m_NovaDamageConstB))+((lpObj->Strength+lpObj->AddStrength)/gServerInfo.m_NovaDamageConstC);
		DamageMax += (gServerInfo.m_NovaDamageConstA*(lpObj->SkillNovaCount*gServerInfo.m_NovaDamageConstB))+((lpObj->Strength+lpObj->AddStrength)/gServerInfo.m_NovaDamageConstC);
	}
	else
	{
		DamageMin += lpSkill->m_DamageMin;
		DamageMax += lpSkill->m_DamageMax;
	}

	DamageMin += gMasterSkillTree.GetMasterSkillDamageMin(lpObj,lpSkill->m_skill);
	DamageMax += gMasterSkillTree.GetMasterSkillDamageMax(lpObj,lpSkill->m_skill);

	DamageMin += lpObj->SkillDamageBonus;
	DamageMax += lpObj->SkillDamageBonus;

	DamageMin += lpObj->EffectOption.AddMagicDamage;
	DamageMax += lpObj->EffectOption.AddMagicDamage;

	DamageMin += lpObj->EffectOption.AddMinMagicDamage;
	DamageMax += lpObj->EffectOption.AddMaxMagicDamage;

	gSkillManager.SkillSwordPowerGetMagicDamage(lpObj->Index,&DamageMin,&DamageMax);

	int type = gSkillManager.GetSkillType(lpSkill->m_index);

	if(CHECK_RANGE(type,MAX_RESISTANCE_TYPE) != 0)
	{
		DamageMin += lpObj->AddResistance[type];
		DamageMax += lpObj->AddResistance[type];
	}

	DamageMin += (DamageMin*lpObj->EffectOption.MulMagicDamage)/100;
	DamageMax += (DamageMax*lpObj->EffectOption.MulMagicDamage)/100;

	DamageMin -= (DamageMin*lpObj->EffectOption.DivMagicDamage)/100;
	DamageMax -= (DamageMax*lpObj->EffectOption.DivMagicDamage)/100;

	//양손
	if(Right->IsItem() != 0 && Right->m_IsValidItem != 0 && ((Right->m_Index >= GET_ITEM(0,0) && Right->m_Index < GET_ITEM(1,0)) || (Right->m_Index >= GET_ITEM(5,0) && Right->m_Index < GET_ITEM(6,0))))
	{
		int rise = (int)(((Right->m_MagicDamageRate/2)+(Right->m_Level*2))*Right->m_CurrentDurabilityState);
		DamageMin += (DamageMin*rise)/100;
		DamageMax += (DamageMax*rise)/100;
	}

	int range = (DamageMax-DamageMin);

	range = ((range<1)?1:range);

	int damage = DamageMin+(GetLargeRand()%range);

	if((GetLargeRand()%100) < ((lpObj->CriticalDamageRate+lpObj->EffectOption.AddCriticalDamageRate)-lpTarget->ResistCriticalDamageRate))
	{
		(*effect) = 3;

		damage = DamageMax;
		damage += lpObj->CriticalDamage;
		damage += lpObj->EffectOption.AddCriticalDamage;
	}

	if((GetLargeRand()%100) < ((lpObj->ExcellentDamageRate+lpObj->EffectOption.AddExcellentDamageRate)-lpTarget->ResistExcellentDamageRate))
	{
		(*effect) = 2;

		damage = (DamageMax*120)/100;
		damage += lpObj->ExcellentDamage;
		damage += lpObj->EffectOption.AddExcellentDamage;
	}

	if(lpObj->Type == OBJECT_USER && lpTarget->Type == OBJECT_USER)
	{
		damage += lpObj->DamagePvP;
	}

	damage -= TargetDefense;

	damage = ((damage<0)?0:damage);

	return gSkillDamage.GetDamageRate(lpSkill, damage);
}

int CAttack::GetAttackDamageCursed(LPOBJ lpObj,LPOBJ lpTarget,CSkill* lpSkill,WORD* effect,int TargetDefense) // OK
{
	CItem* Right = &lpObj->Inventory[0];
	CItem* Left = &lpObj->Inventory[1];

	int DamageMin = lpObj->CurseDamageMin;
	int DamageMax = lpObj->CurseDamageMax;

	DamageMin += lpSkill->m_DamageMin;
	DamageMax += lpSkill->m_DamageMax;

	DamageMin += gMasterSkillTree.GetMasterSkillDamageMin(lpObj,lpSkill->m_skill);
	DamageMax += gMasterSkillTree.GetMasterSkillDamageMax(lpObj,lpSkill->m_skill);

	DamageMin += lpObj->SkillDamageBonus;
	DamageMax += lpObj->SkillDamageBonus;

	DamageMin += lpObj->EffectOption.AddCurseDamage;
	DamageMax += lpObj->EffectOption.AddCurseDamage;

	DamageMin += lpObj->EffectOption.AddMinCurseDamage;
	DamageMax += lpObj->EffectOption.AddMaxCurseDamage;

	gSkillManager.SkillSwordPowerGetCurseDamage(lpObj->Index,&DamageMin,&DamageMax);

	int type = gSkillManager.GetSkillType(lpSkill->m_index);

	if(CHECK_RANGE(type,MAX_RESISTANCE_TYPE) != 0)
	{
		DamageMin += lpObj->AddResistance[type];
		DamageMax += lpObj->AddResistance[type];
	}

	DamageMin += (DamageMin*lpObj->EffectOption.MulCurseDamage)/100;
	DamageMax += (DamageMax*lpObj->EffectOption.MulCurseDamage)/100;

	DamageMin -= (DamageMin*lpObj->EffectOption.DivCurseDamage)/100;
	DamageMax -= (DamageMax*lpObj->EffectOption.DivCurseDamage)/100;

	if(Left->IsItem() != 0 && Left->m_IsValidItem != 0 && Left->m_Index >= GET_ITEM(5,21) && Left->m_Index <= GET_ITEM(5,23))
	{
		int rise = (int)(((Left->m_MagicDamageRate/2)+(Left->m_Level*2))*Left->m_CurrentDurabilityState);
		DamageMin += (DamageMin*rise)/100;
		DamageMax += (DamageMax*rise)/100;
	}

	int range = (DamageMax-DamageMin);

	range = ((range<1)?1:range);

	int damage = DamageMin+(GetLargeRand()%range);

	if((GetLargeRand()%100) < ((lpObj->CriticalDamageRate+lpObj->EffectOption.AddCriticalDamageRate)-lpTarget->ResistCriticalDamageRate))
	{
		(*effect) = 3;

		damage = DamageMax;
		damage += lpObj->CriticalDamage;
		damage += lpObj->EffectOption.AddCriticalDamage;
	}

	if((GetLargeRand()%100) < ((lpObj->ExcellentDamageRate+lpObj->EffectOption.AddExcellentDamageRate)-lpTarget->ResistExcellentDamageRate))
	{
		(*effect) = 2;

		damage = (DamageMax*120)/100;
		damage += lpObj->ExcellentDamage;
		damage += lpObj->EffectOption.AddExcellentDamage;
	}

	if(lpObj->Type == OBJECT_USER && lpTarget->Type == OBJECT_USER)
	{
		damage += lpObj->DamagePvP;
	}

	damage -= TargetDefense;

	damage = ((damage<0)?0:damage);

	return gSkillDamage.GetDamageRate(lpSkill, damage);
}

int CAttack::GetAttackDamageFenrir(LPOBJ lpObj,LPOBJ lpTarget,CSkill* lpSkill,WORD* effect,int TargetDefense) // OK
{
	int BaseDamage = 0;

	//펜릴스킬
	if(lpObj->Class == CLASS_DW)
	{
//		BaseDamage = (lpObj->Strength/gServerInfo.m_DWPlasmaStormDamageConstA)+(lpObj->Dexterity/gServerInfo.m_DWPlasmaStormDamageConstB)+(lpObj->Vitality/gServerInfo.m_DWPlasmaStormDamageConstC)+(lpObj->Energy/gServerInfo.m_DWPlasmaStormDamageConstD);
		BaseDamage = (lpObj->Dexterity/gServerInfo.m_DWPlasmaStormDamageConstB)+(lpObj->Vitality/gServerInfo.m_DWPlasmaStormDamageConstC)+(lpObj->Energy/gServerInfo.m_DWPlasmaStormDamageConstD);

	}
	else if(lpObj->Class == CLASS_DK)
	{
		//BaseDamage = (lpObj->Strength/gServerInfo.m_DKPlasmaStormDamageConstA)+(lpObj->Dexterity/gServerInfo.m_DKPlasmaStormDamageConstB)+(lpObj->Vitality/gServerInfo.m_DKPlasmaStormDamageConstC)+(lpObj->Energy/gServerInfo.m_DKPlasmaStormDamageConstD);
		BaseDamage = (lpObj->Strength/gServerInfo.m_DKPlasmaStormDamageConstA)+(lpObj->Dexterity/gServerInfo.m_DKPlasmaStormDamageConstB)+(lpObj->Vitality/gServerInfo.m_DKPlasmaStormDamageConstC);

	}
	else if(lpObj->Class == CLASS_FE)
	{
//		BaseDamage = (lpObj->Strength/gServerInfo.m_FEPlasmaStormDamageConstA)+(lpObj->Dexterity/gServerInfo.m_FEPlasmaStormDamageConstB)+(lpObj->Vitality/gServerInfo.m_FEPlasmaStormDamageConstC)+(lpObj->Energy/gServerInfo.m_FEPlasmaStormDamageConstD);
		BaseDamage = (lpObj->Dexterity/gServerInfo.m_FEPlasmaStormDamageConstB)+(lpObj->Vitality/gServerInfo.m_FEPlasmaStormDamageConstC)+(lpObj->Energy/gServerInfo.m_FEPlasmaStormDamageConstD);

	}
	else if(lpObj->Class == CLASS_MG)
	{
//		BaseDamage = (lpObj->Strength/gServerInfo.m_MGPlasmaStormDamageConstA)+(lpObj->Dexterity/gServerInfo.m_MGPlasmaStormDamageConstB)+(lpObj->Vitality/gServerInfo.m_MGPlasmaStormDamageConstC)+(lpObj->Energy/gServerInfo.m_MGPlasmaStormDamageConstD);
		BaseDamage = (lpObj->Strength/gServerInfo.m_MGPlasmaStormDamageConstA)+(lpObj->Dexterity/gServerInfo.m_MGPlasmaStormDamageConstB)+(lpObj->Vitality/gServerInfo.m_MGPlasmaStormDamageConstC)+(lpObj->Energy/gServerInfo.m_MGPlasmaStormDamageConstD);

	}
	else if(lpObj->Class == CLASS_DL)
	{
//		BaseDamage = (lpObj->Strength/gServerInfo.m_DLPlasmaStormDamageConstA)+(lpObj->Dexterity/gServerInfo.m_DLPlasmaStormDamageConstB)+(lpObj->Vitality/gServerInfo.m_DLPlasmaStormDamageConstC)+(lpObj->Energy/gServerInfo.m_DLPlasmaStormDamageConstD)+(lpObj->Leadership/gServerInfo.m_DLPlasmaStormDamageConstE);
		BaseDamage = (lpObj->Strength/gServerInfo.m_MGPlasmaStormDamageConstA)+(lpObj->Dexterity/gServerInfo.m_MGPlasmaStormDamageConstB)+(lpObj->Vitality/gServerInfo.m_MGPlasmaStormDamageConstC);

	}
	else if(lpObj->Class == CLASS_SU)
	{
//		BaseDamage = (lpObj->Strength/gServerInfo.m_SUPlasmaStormDamageConstA)+(lpObj->Dexterity/gServerInfo.m_SUPlasmaStormDamageConstB)+(lpObj->Vitality/gServerInfo.m_SUPlasmaStormDamageConstC)+(lpObj->Energy/gServerInfo.m_SUPlasmaStormDamageConstD);
		BaseDamage = (lpObj->Dexterity/gServerInfo.m_SUPlasmaStormDamageConstB)+(lpObj->Vitality/gServerInfo.m_SUPlasmaStormDamageConstC)+(lpObj->Energy/gServerInfo.m_SUPlasmaStormDamageConstD);

	}
	else if(lpObj->Class == CLASS_RF)
	{
//		BaseDamage = (lpObj->Strength/gServerInfo.m_RFPlasmaStormDamageConstA)+(lpObj->Dexterity/gServerInfo.m_RFPlasmaStormDamageConstB)+(lpObj->Vitality/gServerInfo.m_RFPlasmaStormDamageConstC)+(lpObj->Energy/gServerInfo.m_RFPlasmaStormDamageConstD);
		BaseDamage = (lpObj->Strength/gServerInfo.m_RFPlasmaStormDamageConstA)+(lpObj->Dexterity/gServerInfo.m_RFPlasmaStormDamageConstB)+(lpObj->Vitality/gServerInfo.m_RFPlasmaStormDamageConstC);

	}

	int range = (lpSkill->m_DamageMax-lpSkill->m_DamageMin);

	range = ((range<1)?1:range);

	int damage = (BaseDamage+lpSkill->m_DamageMin)+(GetLargeRand()%range);

	if((GetLargeRand()%100) < ((lpObj->CriticalDamageRate+lpObj->EffectOption.AddCriticalDamageRate)-lpTarget->ResistCriticalDamageRate))
	{
		(*effect) = 3;

		damage = (BaseDamage+lpSkill->m_DamageMax);
		damage += lpObj->CriticalDamage;
		damage += lpObj->EffectOption.AddCriticalDamage;
	}

	if((GetLargeRand()%100) < ((lpObj->ExcellentDamageRate+lpObj->EffectOption.AddExcellentDamageRate)-lpTarget->ResistExcellentDamageRate))
	{
		(*effect) = 2;

		damage = ((BaseDamage+lpSkill->m_DamageMax)*120)/100;
		damage += lpObj->ExcellentDamage;
		damage += lpObj->EffectOption.AddExcellentDamage;
	}

	if(lpObj->Type == OBJECT_USER && lpTarget->Type == OBJECT_USER)
	{
		damage += lpObj->DamagePvP;
	}

	damage -= TargetDefense;

	damage = ((damage<0)?0:damage);

	return gSkillDamage.GetDamageRate(lpSkill, damage);
}

int CAttack::GetAttackDamageElemental(LPOBJ lpObj,LPOBJ lpTarget,CSkill* lpSkill,WORD* effect,int AttackDamage,int TargetDefense) // OK
{
	#if(GAMESERVER_UPDATE>=701)

	int DamageMin = lpObj->ElementalDamageMin;
	int DamageMax = lpObj->ElementalDamageMax;

	if(lpObj->Type == OBJECT_USER)
	{
		DamageMin += (((lpObj->Inventory[236].IsItem()==0)?0:lpObj->Inventory[236].m_DamageMin)*lpObj->PentagramOption.MulPentagramDamage)/100;
		DamageMax += (((lpObj->Inventory[236].IsItem()==0)?0:lpObj->Inventory[236].m_DamageMax)*lpObj->PentagramOption.MulPentagramDamage)/100;

		DamageMin += (AttackDamage*lpObj->PentagramOption.AddElementalAttackTransferRate)/100;
		DamageMax += (AttackDamage*lpObj->PentagramOption.AddElementalAttackTransferRate)/100;

		DamageMin += lpObj->PentagramJewelOption.AddElementalDamage;
		DamageMax += lpObj->PentagramJewelOption.AddElementalDamage;

		if(lpTarget->Type == OBJECT_USER)
		{
			DamageMin += lpObj->PentagramJewelOption.AddElementalDamagePvP;
			DamageMax += lpObj->PentagramJewelOption.AddElementalDamagePvP;

			if(lpTarget->Class == CLASS_DW || lpTarget->Class == CLASS_FE || lpTarget->Class == CLASS_MG || lpTarget->Class == CLASS_SU)
			{
				DamageMin += lpObj->PentagramJewelOption.AddElementalDamageRange;
				DamageMax += lpObj->PentagramJewelOption.AddElementalDamageRange;
			}
			else
			{
				DamageMin += lpObj->PentagramJewelOption.AddElementalDamageMelee;
				DamageMax += lpObj->PentagramJewelOption.AddElementalDamageMelee;
			}

			DamageMin += (DamageMin*lpTarget->PentagramJewelOption.MulElementalDamagePvP)/100;
			DamageMax += (DamageMax*lpTarget->PentagramJewelOption.MulElementalDamagePvP)/100;
		}
		else
		{
			DamageMin += lpObj->PentagramJewelOption.AddElementalDamagePvM;
			DamageMax += lpObj->PentagramJewelOption.AddElementalDamagePvM;

			DamageMin += (DamageMin*lpTarget->PentagramJewelOption.MulElementalDamagePvM)/100;
			DamageMax += (DamageMax*lpTarget->PentagramJewelOption.MulElementalDamagePvM)/100;
		}
	}

	int range = (DamageMax-DamageMin);

	range = ((range<1)?1:range);

	int damage = DamageMin+(GetLargeRand()%range);

	if((GetLargeRand()%100) < (lpObj->PentagramOption.AddElementalCriticalDamageRate+((lpTarget->Type==OBJECT_USER)?lpObj->PentagramJewelOption.AddElementalCriticalDamageRatePvP:lpObj->PentagramJewelOption.AddElementalCriticalDamageRatePvM)))
	{
		(*effect) = 6;

		damage = DamageMax;
	}

	if((GetLargeRand()%100) < ((lpTarget->Type==OBJECT_USER)?lpObj->PentagramJewelOption.AddElementalExcellentDamageRatePvP:lpObj->PentagramJewelOption.AddElementalExcellentDamageRatePvM))
	{
		(*effect) = 7;

		damage = (DamageMax*120)/100;
	}

	gPentagramSystem.GetPentagramRelationshipDamage(lpObj,lpTarget,&damage);

	damage -= TargetDefense;

	damage = ((damage<0)?0:damage);

	return gSkillDamage.GetDamageRate(lpSkill, damage);

	#else

	return 0;

	#endif
}

int CAttack::GetShieldDamage(LPOBJ lpObj,LPOBJ lpTarget,int damage) // OK
{
	int rate = lpTarget->ShieldGaugeRate;

	if((GetLargeRand()%100) < ((lpObj->IgnoreShieldGaugeRate)-lpTarget->ResistIgnoreShieldGaugeRate))
	{
		rate = 0;
	}
	else
	{
		rate -= lpObj->DecreaseShieldGaugeRate;
	}

	rate = ((rate<0)?0:((rate>100)?100:rate));

	int SDDamage = (damage*rate)/100;
	int HPDamage = damage-SDDamage;

	if(lpTarget->Shield < SDDamage)
	{
		HPDamage = HPDamage+(SDDamage-lpTarget->Shield);
		SDDamage = lpTarget->Shield;

		if(lpTarget->Shield > 0 && HPDamage > (((lpTarget->MaxLife+lpTarget->AddLife)*20)/100))
		{
			if(CC_MAP_RANGE(lpTarget->Map) == 0 || IT_MAP_RANGE(lpTarget->Map) == 0)
			{
				GCEffectInfoSend(lpTarget->Index,17);
			}
		}
	}

	return SDDamage;
}

void CAttack::GetPreviewDefense(LPOBJ lpObj,DWORD* defense) // OK
{
	(*defense) = lpObj->Defense;

	(*defense) += lpObj->EffectOption.AddDefense;

	(*defense) -= lpObj->EffectOption.SubDefense;

	gSkillManager.SkillSwordPowerGetDefense(lpObj->Index,(int*)defense);

	(*defense) += ((*defense)*lpObj->EffectOption.MulDefense)/100;

	(*defense) -= ((*defense)*lpObj->EffectOption.DivDefense)/100;
}

//양손
void CAttack::GetPreviewPhysiDamage(LPOBJ lpObj,DWORD* DamageMin,DWORD* DamageMax,DWORD* MulDamage,DWORD* DivDamage) // OK
{
	CItem* Right = &lpObj->Inventory[0];
	CItem* Left = &lpObj->Inventory[1];

	bool DualHandWeapon = 0;

	if(lpObj->Class == CLASS_DK || lpObj->Class == CLASS_MG || lpObj->Class == CLASS_DL || lpObj->Class == CLASS_RF)
	{
		if(Right->m_Index >= GET_ITEM(0,0) && Right->m_Index < GET_ITEM(4,0) && Left->m_Index >= GET_ITEM(0,0) && Left->m_Index < GET_ITEM(4,0))
		{
			if(Right->m_IsValidItem != 0 && Left->m_IsValidItem != 0)
			{
				DualHandWeapon = 1;
			}
		}
	}

	if(DualHandWeapon != 0)
	{
		(*DamageMin) = lpObj->PhysiDamageMinRight+lpObj->PhysiDamageMinLeft;
		(*DamageMax) = lpObj->PhysiDamageMaxRight+lpObj->PhysiDamageMaxLeft;
	}
	else if((Right->m_Index >= GET_ITEM(0,0) && Right->m_Index < GET_ITEM(4,0)) || (Right->m_Index >= GET_ITEM(5,0) && Right->m_Index < GET_ITEM(6,0)))
	{
		(*DamageMin) = lpObj->PhysiDamageMinRight;
		(*DamageMax) = lpObj->PhysiDamageMaxRight;
	}
	else if(Right->m_Index >= GET_ITEM(4,0) && Right->m_Index < GET_ITEM(5,0) && Right->m_Index != GET_ITEM(4,15) && Right->m_Slot == 0)
	{
		(*DamageMin) = lpObj->PhysiDamageMinRight;
		(*DamageMax) = lpObj->PhysiDamageMaxRight;
	}
	else if(Left->m_Index >= GET_ITEM(4,0) && Left->m_Index < GET_ITEM(5,0) && Left->m_Index != GET_ITEM(4,7) && Left->m_Slot == 1)
	{
		(*DamageMin) = lpObj->PhysiDamageMinLeft;
		(*DamageMax) = lpObj->PhysiDamageMaxLeft;
	}
	else
	{
		(*DamageMin) = lpObj->PhysiDamageMinLeft;
		(*DamageMax) = lpObj->PhysiDamageMaxLeft;
	}

	(*DamageMin) += lpObj->EffectOption.AddPhysiDamage;
	(*DamageMax) += lpObj->EffectOption.AddPhysiDamage;

	(*DamageMin) += lpObj->EffectOption.AddMinPhysiDamage;
	(*DamageMax) += lpObj->EffectOption.AddMaxPhysiDamage;

	gSkillManager.SkillSwordPowerGetPhysiDamage(lpObj->Index,(int*)DamageMin,(int*)DamageMax);

	(*MulDamage) = lpObj->EffectOption.MulPhysiDamage;
	(*DivDamage) = lpObj->EffectOption.DivPhysiDamage;
}

void CAttack::GetPreviewMagicDamage(LPOBJ lpObj,DWORD* DamageMin,DWORD* DamageMax,DWORD* MulDamage,DWORD* DivDamage,DWORD* DamageRate) // OK
{
	CItem* Right = &lpObj->Inventory[0];
	CItem* Left = &lpObj->Inventory[1];

	(*DamageMin) = lpObj->MagicDamageMin;
	(*DamageMax) = lpObj->MagicDamageMax;

	(*DamageMin) += lpObj->EffectOption.AddMagicDamage;
	(*DamageMax) += lpObj->EffectOption.AddMagicDamage;

	(*DamageMin) += lpObj->EffectOption.AddMinMagicDamage;
	(*DamageMax) += lpObj->EffectOption.AddMaxMagicDamage;

	gSkillManager.SkillSwordPowerGetMagicDamage(lpObj->Index,(int*)DamageMin,(int*)DamageMax);

	(*MulDamage) = lpObj->EffectOption.MulMagicDamage;
	(*DivDamage) = lpObj->EffectOption.DivMagicDamage;

	//양손
	if(Right->IsItem() != 0 && Right->m_IsValidItem != 0 && ((Right->m_Index >= GET_ITEM(0,0) && Right->m_Index < GET_ITEM(1,0)) || (Right->m_Index >= GET_ITEM(5,0) && Right->m_Index < GET_ITEM(6,0))))
	{
		(*DamageRate) = (int)(((Right->m_MagicDamageRate/2)+(Right->m_Level*2))*Right->m_CurrentDurabilityState);
	}
	else
	{
		(*DamageRate) = 0;
	}
}

//양손
void CAttack::GetPreviewCurseDamage(LPOBJ lpObj,DWORD* DamageMin,DWORD* DamageMax,DWORD* MulDamage,DWORD* DivDamage,DWORD* DamageRate) // OK
{
	CItem* Right = &lpObj->Inventory[0];
	CItem* Left = &lpObj->Inventory[1];

	(*DamageMin) = lpObj->CurseDamageMin;
	(*DamageMax) = lpObj->CurseDamageMax;

	(*DamageMin) += lpObj->EffectOption.AddCurseDamage;
	(*DamageMax) += lpObj->EffectOption.AddCurseDamage;

	(*DamageMin) += lpObj->EffectOption.AddMinCurseDamage;
	(*DamageMax) += lpObj->EffectOption.AddMaxCurseDamage;

	gSkillManager.SkillSwordPowerGetCurseDamage(lpObj->Index,(int*)DamageMin,(int*)DamageMax);

	(*MulDamage) = lpObj->EffectOption.MulCurseDamage;
	(*DivDamage) = lpObj->EffectOption.DivCurseDamage;

	if(Left->IsItem() != 0 && Left->m_IsValidItem != 0 && Left->m_Index >= GET_ITEM(5,21) && Left->m_Index <= GET_ITEM(5,23))
	{
		(*DamageRate) = (int)(((Left->m_MagicDamageRate/2)+(Left->m_Level*2))*Left->m_CurrentDurabilityState);
	}
	else
	{
		(*DamageRate) = 0;
	}
}

void CAttack::GetPreviewDamageMultiplier(LPOBJ lpObj,DWORD* DamageMultiplier,DWORD* RFDamageMultiplierA,DWORD* RFDamageMultiplierB,DWORD* RFDamageMultiplierC) // OK
{
	switch(lpObj->Class)
	{
		case CLASS_DW:
			(*DamageMultiplier) = 200;
			(*RFDamageMultiplierA) = 100;
			(*RFDamageMultiplierB) = 100;
			(*RFDamageMultiplierC) = 100;
			break;
		case CLASS_DK:
			(*DamageMultiplier) = lpObj->DKDamageMultiplierRate;
			(*RFDamageMultiplierA) = 100;
			(*RFDamageMultiplierB) = 100;
			(*RFDamageMultiplierC) = 100;
			break;
		case CLASS_FE:
			(*DamageMultiplier) = 200;
			(*RFDamageMultiplierA) = 100;
			(*RFDamageMultiplierB) = 100;
			(*RFDamageMultiplierC) = 100;
			break;
		case CLASS_MG:
			(*DamageMultiplier) = 200;
			(*RFDamageMultiplierA) = 100;
			(*RFDamageMultiplierB) = 100;
			(*RFDamageMultiplierC) = 100;
			break;
		case CLASS_DL:
			(*DamageMultiplier) = lpObj->DLDamageMultiplierRate;
			(*RFDamageMultiplierA) = 100;
			(*RFDamageMultiplierB) = 100;
			(*RFDamageMultiplierC) = 100;
			break;
		case CLASS_SU:
			(*DamageMultiplier) = 200;
			(*RFDamageMultiplierA) = 100;
			(*RFDamageMultiplierB) = 100;
			(*RFDamageMultiplierC) = 100;
			break;
		case CLASS_RF:
			//(*DamageMultiplier) = 200;
			//(*RFDamageMultiplierA) = lpObj->RFDamageMultiplierRate[0];
			//(*RFDamageMultiplierB) = lpObj->RFDamageMultiplierRate[1];
			//(*RFDamageMultiplierC) = lpObj->RFDamageMultiplierRate[2];

			(*DamageMultiplier) = lpObj->RFDamageMultiplierRate;
			(*RFDamageMultiplierA) = 100;
			(*RFDamageMultiplierB) = 100;
			(*RFDamageMultiplierC) = 100;
			break;
	}
}

void CAttack::CGAttackRecv(PMSG_ATTACK_RECV* lpMsg,int aIndex) // OK
{
	LPOBJ lpObj = &gObj[aIndex];

	if(gObjIsConnected(aIndex) == 0)
	{
		return;
	}

	int bIndex = MAKE_NUMBERW(lpMsg->index[0],lpMsg->index[1]);

	if(OBJECT_RANGE(bIndex) == 0)
	{
		return;
	}

	LPOBJ lpTarget = &gObj[bIndex];

	if(lpTarget->Live == 0)
	{
		return;
	}

	if(lpObj->Map != lpTarget->Map)
	{
		return;
	}

	#if(GAMESERVER_UPDATE>=402)

	if(gDuel.GetDuelArenaBySpectator(aIndex) != 0 || gDuel.GetDuelArenaBySpectator(bIndex) != 0)
	{
		return;
	}

	#endif

	if(gMap[lpObj->Map].CheckAttr(lpObj->X,lpObj->Y,1) != 0 || gMap[lpTarget->Map].CheckAttr(lpTarget->X,lpTarget->Y,1) != 0)
	{
		return;
	}

	if(lpObj->Type == OBJECT_USER && sqrt(pow(((float)lpObj->X-(float)lpTarget->X),2)+pow(((float)lpObj->Y-(float)lpTarget->Y),2)) > ((lpObj->Class==CLASS_FE)?6:3))
	{
		return;
	}

	lpObj->Dir = lpMsg->dir;

	lpObj->MultiSkillIndex = 0;

	lpObj->MultiSkillCount = 0;

	GCActionSend(lpObj,lpMsg->action,aIndex,bIndex);

	lpObj->ComboSkill.Init();

	this->Attack(lpObj,lpTarget,0,0,0,0,0,0);
}

